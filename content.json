{"meta":{"title":"星家|不会搬砖的码农","subtitle":"（//▽//）","description":null,"author":"罗炜光","url":"https://luoweiguang.github.io"},"pages":[{"title":"","date":"2017-02-19T06:10:36.435Z","updated":"2017-02-19T06:10:36.435Z","comments":false,"path":"tags/index.html","permalink":"https://luoweiguang.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"使用CMake编译NDK","slug":"使用CMake编译NDK","date":"2017-01-02T14:00:00.000Z","updated":"2017-07-31T14:06:35.488Z","comments":true,"path":"2017/01/02/使用CMake编译NDK/","link":"","permalink":"https://luoweiguang.github.io/2017/01/02/使用CMake编译NDK/","excerpt":"新建Android项目使用Android Studio2.2新建一个Android项目\n在新建项目时勾选Include C++ Support","text":"新建Android项目使用Android Studio2.2新建一个Android项目 在新建项目时勾选Include C++ Support CMake支持在Settings点击Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK在右面板点击SDK Tools勾选CMake和LLDB,点击Apply即可 修改build.gradleapply plugin: 'com.android.application' android { compileSdkVersion 25 buildToolsVersion \"25.0.0\" defaultConfig { applicationId \"luoweiguang.github.io.video\" minSdkVersion 19 targetSdkVersion 25 versionCode 1 versionName \"1.0\" //选择要编译的CPU类型 ndk { abiFilters 'x86', 'armeabi-v7a' } externalNativeBuild { cmake { cppFlags \"-frtti -fexceptions\" } } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } //设置CMakeLists.txt的路径,根路径是app externalNativeBuild { cmake { path \"CMakeLists.txt\" } } //选择so所放的目录。不填此项默认目录是在app/src/main/jniLibs sourceSets { main { jniLibs.srcDirs = ['libs'] } } } dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:25.1.0' testCompile 'junit:junit:4.12' } 修改CMakeLists.txtcmake_minimum_required(VERSION 3.4.1) # 设置变量，方便底下使用 set(INC_DIR ${PROJECT_SOURCE_DIR}/src/main/cpp/include) set(LINK_DIR ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}) # 添加so库对应的头文件目录 include_directories(${INC_DIR}) # 引入so库,IMPORT代表从第三方引入的意思 add_library( avcodec-57 SHARED IMPORTED) # 设置编译的库文件存放的目录 set_target_properties( avcodec-57 PROPERTIES IMPORTED_LOCATION ${LINK_DIR}/libavcodec-57.so) add_library( avfilter-6 SHARED IMPORTED) set_target_properties( avfilter-6 PROPERTIES IMPORTED_LOCATION ${LINK_DIR}/libavfilter-6.so) add_library( avformat-57 SHARED IMPORTED) set_target_properties( avformat-57 PROPERTIES IMPORTED_LOCATION ${LINK_DIR}/libavformat-57.so) add_library( avutil-55 SHARED IMPORTED) set_target_properties( avutil-55 PROPERTIES IMPORTED_LOCATION ${LINK_DIR}/libavutil-55.so) add_library( swresample-2 SHARED IMPORTED) set_target_properties( swresample-2 PROPERTIES IMPORTED_LOCATION ${LINK_DIR}/libswresample-2.so) add_library( swscale-4 SHARED IMPORTED) set_target_properties( swscale-4 PROPERTIES IMPORTED_LOCATION ${LINK_DIR}/libswscale-4.so) # 自己本地的代码所编译的库 add_library( # 库的名称 native-lib SHARED # 编译文件的目录 src/main/cpp/native-lib.cpp ) find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log ) # 将其他库文件链接到native-lib上 target_link_libraries( native-lib avcodec-57 avfilter-6 avformat-57 avutil-55 swresample-2 swscale-4 ${log-lib}) 注意事项当调用的库为C代码写时，需要用 extern \"C\" { // #include &lt;*> //内容 } 其中{}也是必不可少的 例如: #include &lt;jni.h> #include &lt;string> extern \"C\" { #include &lt;libavcodec/avcodec.h> JNIEXPORT jstring JNICALL Java_luoweiguang_github_io_video_MainActivity_getString(JNIEnv *env, jobject instance) { char info[10000] = { 0 }; sprintf(info, \"%s\\n\", avcodec_configuration()); return env->NewStringUTF(info); } } 参考资料cmake 学习笔记(一)Android Studio中的CmakeList NDK配置最简单的基于FFmpeg的移动端例子：Android HelloWorld","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://luoweiguang.github.io/tags/FFmpeg/"},{"name":"NDK","slug":"NDK","permalink":"https://luoweiguang.github.io/tags/NDK/"}]},{"title":"Win7下编译ffmpeg","slug":"Win7下编译ffmpeg","date":"2016-12-31T14:00:00.000Z","updated":"2017-11-14T15:23:24.170Z","comments":true,"path":"2016/12/31/Win7下编译ffmpeg/","link":"","permalink":"https://luoweiguang.github.io/2016/12/31/Win7下编译ffmpeg/","excerpt":"下载ffmpeg源码并解压地址http://www.ffmpeg.org/download.html","text":"下载ffmpeg源码并解压地址http://www.ffmpeg.org/download.html 安装MinGW下载MinGW安装器，下载地址http://www.mingw.org/；下载完成后安装，安装完成后点运行，标记上以下几项： 然后在Installation菜单下点击Apply Changes 下载android NDK假如使用android studio,可在Settings中点击Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK，在右侧面板点击SDK Tools勾选，点击Apply即可 修改ffmpeg/configure文件将该文件中的如下四行： SLIBNAME_WITH_MAJOR=&#39;$(SLIBNAME).$(LIBMAJOR)&#39; LIB_INSTALL_EXTRA_CMD=&#39;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&#39; SLIB_INSTALL_NAME=&#39;$(SLIBNAME_WITH_VERSION)&#39; SLIB_INSTALL_LINKS=&#39;$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)&#39; 替换为 SLIBNAME_WITH_MAJOR=&#39;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#39; LIB_INSTALL_EXTRA_CMD=&#39;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&#39; SLIB_INSTALL_NAME=&#39;$(SLIBNAME_WITH_MAJOR)&#39; SLIB_INSTALL_LINKS=&#39;$(SLIBNAME)&#39; 假如不修改会导致编译的so文件的版本号在so后面，导致android无法识别加载 编写build_android.sh脚本文件在ffmpeg根目录编写一个文件名为build_android.sh的脚本文件 ARM内容如下: NDK=D:/Users/Administrator/AppData/Local/Android/sdk/ndk-bundle SYSROOT=$NDK/platforms/android-19/arch-arm/ TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/windows-x86_64 CPU=arm PREFIX=$(pwd)/android/$CPU ADDI_CFLAGS=\"-marm\" function build_one { ./configure \\ --prefix=$PREFIX \\ --enable-shared \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-asm \\ --enable-gpl \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --target-os=linux \\ --arch=arm \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" make clean make make install } build_one 其中要修改NDK,SYSROOT和TOOLCHAIN为自己的目录，注意android-19和arm-linux-androideabi-4.9版本，要修改为自己NDK中的版本 x86内容如下: NDK=D:/Users/Administrator/AppData/Local/Android/sdk/ndk-bundle SYSROOT=$NDK/platforms/android-19/arch-x86/ TOOLCHAIN=$NDK/toolchains/x86-4.9/prebuilt/windows-x86_64 CPU=x86 PREFIX=$(pwd)/android/$CPU function build_one { ./configure \\ --prefix=$PREFIX \\ --enable-shared \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-asm \\ --enable-gpl \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/i686-linux-android- \\ --target-os=linux \\ --arch=x86 \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" make clean make make install } build_one arm与x86两个脚本不能在同一个ffmpeg目录编译，否则会报错 编译 点击MinGW/msys/1.0/目录下的msys.bat 输入跳转到ffmpeg源码目录下的命令，如:(cd D:/ffmpeg) 输入chmod +x build_android.sh给build_android.sh增加执行权限 输入build_android.sh编译 等待很长时间后，编译会完成 假如报./configure: line &lt;xxx&gt;: pr: command not found的解决方案下载coreutils-5.97-MSYS-1.0.11-snapshot.tar.bz2之后把bin目录下的内容全部拷贝到了MinGW下的bin目录下面，重新开始上面的步骤即可 完成编译完的so会在ffmpeg下的android目录下 参考资料win7下编译android版ffmpegFFmpeg的Android平台移植—编译篇MSys中使用configure出现无法找到pr错误解决方案","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://luoweiguang.github.io/tags/FFmpeg/"}]},{"title":"Android系统服务概要","slug":"Android系统服务概要","date":"2016-10-05T14:00:00.000Z","updated":"2017-11-14T15:26:46.282Z","comments":true,"path":"2016/10/05/Android系统服务概要/","link":"","permalink":"https://luoweiguang.github.io/2016/10/05/Android系统服务概要/","excerpt":"本篇基于android2.2.3Android系统服务提供系统最基本、最核心的功能,如设备控制、位置信息、通知设定、以及消息显示等。这些服务分别存于Application Framework与Libraries层之中","text":"本篇基于android2.2.3Android系统服务提供系统最基本、最核心的功能,如设备控制、位置信息、通知设定、以及消息显示等。这些服务分别存于Application Framework与Libraries层之中 系统服务分类本地系统服务本地系统服务使用C++编写，运行在Libraries层，主要包含Audio Flinger、Surface Flinger等 Audio Flinger服务Audio Flinger服务混合多种Android应用程序的音频数据，并发送到耳机、扬声器等音频输出设备中。在Android设备中，所有音频数据均经由Audio Flinger进行输出 Surface Flinger服务Surface Flinger是Android Multimedia的一部分，在Android的实现中，它是一个服务，提供系统范围内的surface composer功能，能够将各种应用程序的Surface组合后渲染到Frame Buffer设备中 Java系统服务核心平台服务一般而已,核心平台服务(Core Platform Service)不会直接与Android应用程序进行交互但它们是Android Framework运行所必须的服务，其中主要服务如下: Activity Manager Service管理所有Activity的生命周期与堆栈(Stack) Window Manager Service位于Surface Flinger之上，将要绘制到机器画面上的内容传递给Surface Flinger Package Manager Service加载apk文件(Android包文件)的信息，提供信息显示系统中设置了哪些包，以及加载了哪些包 硬件服务硬件服务(Hardware Service)提供了一系列API，用于控制底层硬件，主要包括如下服务 Alarm Manager Service在特定时间后运行指定的应用程序，就像定时器 Connectivity Service提供有关网络当前状态的信息 Location Service提供终端当前的位置信息 Power Service设备电源管理 Sensor Service提供Android中各种传感器的感应值 Telephony Service提供话机状态及电话服务 Wifi Service控制无线网络连接 使用Java系统服务无论在Framework内部，还是Android应用程序中，若想使用Java系统服务，必须使用能够与各服务通信的Local Manager对象 应用程序若想使用Location Service,获取终端设备当前的位置信息，需要先调用getSystemService()函数,创建与Location Service相应的Local Manager对象，而后应用程序使用生成的Local Manager对象，调用Location Service提供的各种函数，执行相应的功能。 运行系统服务在使用应用程序服务前，Android应用程序会先调用startService()函数，启动指定的应用程序服务，而后再使用它。与之不同的是，使用系统服务时，客户端不需要启动它，直接调用getSystemService()使用即可。因为Android系统的启动过程中,init进程已经启动了这些系统服务。 在Android启动时，系统服务具体由媒体服务器(Media Service)与系统服务器(System Service)两个系统进程运行。媒体服务器进程用来启动除Surface Flinger之外的Audio Flinger、Media Player Service等本地服务。而系统服务器是Zygote最初生成的基于Java进程，它会启动所有Java系统服务，例如本地系统服务Surface Flinger 媒体服务器的运行代码媒体服务器是个系统进程，它运行Audio Flinger、Media Player Service、Camera Service、Audio Policy Service等本地系统服务，由init进程启动运行 init.rc service media /system/bin/mediaserver user media group system audio camera graphics inet net_bt net_bt_admin net_raw 生成并初始化本地服务main_mediaserver int main(int argc, char** argv) { ... AudioFlinger::instantiate(); MediaPlayerService::instantiate(); CameraService::instantiate(); AudioPolicyService::instantiate(); ... } 分析各系统服务的初始化代码系统服务与Framework中的其他模块通信时,使用Binder IPC,系统服务这类服务提供者必须把相关信息注册到Context Manager中，以便Android应用程序这类服务使用者能够使用其提供的服务 各本地服务的初始化代码形式都相似，即首先使用new运算符生成服务的实例，而后调用addService()函数将各个服务注册到Context Manager中 AudioFlinger::instantiate void AudioFlinger::instantiate() { defaultServiceManager()->addService( String16(\"media.audio_flinger\"), new AudioFlinger()); } MediaPlayerService::instantiate void MediaPlayerService::instantiate() { defaultServiceManager()->addService( String16(\"media.player\"), new MediaPlayerService()); } CameraService::instantiate void CameraService::instantiate() { defaultServiceManager()->addService( String16(\"media.camera\"), new CameraService()); } AudioPolicyService::instantiate void AudioPolicyService::instantiate() { defaultServiceManager()->addService( String16(\"media.audio_policy\"), new AudioPolicyService()); } defaultServiceManager()函数会返回Service Manager对象，它是一个代理对象，用来实现Context Manager与Binder之间的通信。在Framework中，若想使用Context Manager的注册或获取服务等功能,必须使用Service Manager 系统服务器的运行代码系统服务器(System Service)是一个Java进程，由Zygote进程生成。 System Service由Zygote进程最初生成，运行在Dalvik虚拟机中的Java进程，它用来运行多种Java系统服务，还有Surface Flinger本地系统服务。 由脚本可知，在Zygote运行行带有“-start-system-server”选项时，该选项请求在Zygote中生成System Server. init.rc service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server socket zygote stream 666 onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media 加载android_servers库启动运行SystemServer SystemServer main()方法的主要功能是加载android_servers库(libandroid_server.so),并调用init()方法。init1()通过JNI调用system_init()本地函数。system_init()函数的主要功能是生成并初始化本地系统服务Surface Flinger Surface Flinger是基于C++的系统服务，而System Server是Java进程，它不能直接调用Surface Flinger服务。System Server必须经由JNI通过调用system_init()函数来运行Surface Flinger服务。Surface Flinger是本地系统服务，它采用类似Audio Flinger的代码来进行初始化 Surface Flinger运行后，执行runtime-&gt;callStaic(&quot;com/android/server/SystemServer&quot;,&quot;init2&quot;)语句，调用SystemServer类的init2()方法。callStaic()函数是JNI包装函数，它运行在C++代码中经由JNI调用Java类的静态方法 Java系统服务的初始化及注册在SystemServer的执行中，先初始化Surface Flinger,而后调用init2()方法，该方法能够生成并初始化从Entropy服务到AppWidge服务的所有Java系统服务 init2()方法会首先创建ServerThread对象，而后启动它。ServerThread是一个Java线程，它可以运行Android的所有Java系统服务 init2 public static final void init2() { Slog.i(TAG, \"Entered the Android system server!\"); Thread thr = new ServerThread(); thr.setName(\"android.server.ServerThread\"); thr.start(); } 同本地系统服务一样，Java系统服务必须先把相关服务注册到Context Manager中，其他模块才能使用这些服务。但是Java系统服务的注册方式与基于C++的本地系统服务不同，它通过调用ServiceManager类的addService()静态方法，将自身注册到Context Manager中 SystemServer class ServerThread extends Thread { ... @Override public void run() { ... try { Slog.i(TAG, &quot;Entropy Service&quot;); ServiceManager.addService(&quot;entropy&quot;, new EntropyService()); Slog.i(TAG, &quot;Power Manager&quot;); power = new PowerManagerService(); ServiceManager.addService(Context.POWER_SERVICE, power); Slog.i(TAG, &quot;Activity Manager&quot;); context = ActivityManagerService.main(factoryTest); Slog.i(TAG, &quot;Telephony Registry&quot;); ServiceManager.addService(&quot;telephony.registry&quot;, new TelephonyRegistry(context)); ... } ... } } 参考资料Amdroid框架揭秘","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android Framework","slug":"Android-Framework","permalink":"https://luoweiguang.github.io/tags/Android-Framework/"}]},{"title":"Service的使用","slug":"Service的使用","date":"2016-10-04T14:00:00.000Z","updated":"2017-11-14T15:35:41.165Z","comments":true,"path":"2016/10/04/Service的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/10/04/Service的使用/","excerpt":"概述\nService是一种没有界面且能长时间运行于后台的应用组件．其它应用的组件可以启动一个服务运行于后台，即使用户切换到另一个应用也会继续运行．另外，一个组件可以绑定到一个service来进行交互，即使这个交互是进程间通讯也没问题．例如，一个service可能处理网络事物，播放音乐，执行文件I/O，或与一个内容提供者交互，所有这些都在后台进行．\n","text":"概述 Service是一种没有界面且能长时间运行于后台的应用组件．其它应用的组件可以启动一个服务运行于后台，即使用户切换到另一个应用也会继续运行．另外，一个组件可以绑定到一个service来进行交互，即使这个交互是进程间通讯也没问题．例如，一个service可能处理网络事物，播放音乐，执行文件I/O，或与一个内容提供者交互，所有这些都在后台进行． Service与Thread的区别进程是系统最小资源分配单位，而线程是则是最小的执行单位，线程需要的资源通过它所在的进程获取 Thread：Thread 是程序执行的最小单元，可以用 Thread 来执行一些异步的操作。 Service：Service 是android的一种机制，当它运行的时候如果是本地Service，那么对应的 Service 是运行在主进程的主线程上的。如果是远程Service，那么对应的 Service 则是运行在独立进程的主线程上。 Thread 的运行是独立的，也就是说当一个 Activity 被 finish 之后，如果没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，不再持有该 Thread 的引用，也就是不能再控制该Thread。另一方面，没有办法在不同的 Activity 中对同一 Thread 进行控制。 例如：如果 一个Thread 需要每隔一段时间连接服务器校验数据，该Thread需要在后台一直运行。这时候如果创建该Thread的Activity被结束了而该Thread没有停止，那么将没有办法再控制该Thread，除非kill掉该程序的进程。这时候如果创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题(因为任何 Activity 都可以控制同一个Service，而系统也只会创建一个对应 Service 的实例)。 因此可以把 Service 想象成一种消息服务，可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService、Context.unbindService来控制它，也可以在 Service 里注册 BroadcastReceiver，通过发送 broadcast 来达到控制的目的，这些都是 Thread 做不到的。 重要的回调方法public void onCreate() 系统在service第一次创建时执行此方法，来执行只运行一次的初始化工作(在调用它方法如onStartCommand()或onBind()之前)．如果service已经运行，这个方法不会被调用． public int onStartCommand(Intent intent, int flags, int startId ) 系统在其它组件比如activity通过调用startService()请求service启动时调用这个方法．一旦这个方法执行，service就启动并且在后台长期运行．如果你实现了它，你需要负责在service完成任务时停止它，通过调用stopSelf()或stopService()．(如果你只想提供绑定，你不需实现此方法)． onStartCommand的返回值onStartCommand()必须返回一个整数．这个整数描述了在系统杀死它的事件中系统如何继续这个服务 START_NOT_STICKY 如果系统在onStartCommand()方法返回之后杀死这个服务，那么直到接受到新的Intent对象，这个服务才会被重新创建。这是最安全的选项，用来避免在不需要的时候运行你的服务。 START_STICKY 如果系统在onStartCommand()返回后杀死了这个服务，系统就会重新创建这个服务并且调用onStartCommand()方法，但是它不会重新传递最后的Intent对象，系统会用一个null的Intent对象来调用onStartCommand()方法，在这个情况下，除非有一些被发送的Intent对象在等待启动服务。这适用于不执行命令的媒体播放器（或类似的服务），它只是无限期的运行着并等待工作的到来。 START_REDELIVER_INTENT 如果系统在onStartCommand()方法返回后，系统就会重新创建了这个服务，并且用发送给这个服务的最后的Intent对象调用了onStartCommand()方法。任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 START_STICKY_COMPATIBILITY START_STICKY的兼容版本，但不保证服务被kill后一定能重启。 onStartCommand的参数flags START_FLAG_REDELIVERY 如果你实现onStartCommand()来安排异步工作或者在另一个线程中工作, 那么你可能需要使用START_FLAG_REDELIVERY来让系统重新发送一个intent。这样如果你的服务在处理它的时候被Kill掉, Intent不会丢失. START_FLAG_RETRY 表示服务之前被设为START_STICKY，则会被传入这个标记。启动service的时候，onCreate方法只有第一次会调用，onStartCommand和onStart每次都被调用。onStartCommand会告诉系统如何重启服务，如判断是否异常终止后重新启动，在何种情况下异常终止. public IBinder onBind(Intent intent) 当组件调用bindService()想要绑定到service时(比如想要执行进程间通讯)系统调用此方法．在你的实现中，你必须提供一个返回一个IBinder来以使客户端能够使用它与service通讯，你必须总是实现这个方法，但是如果你不允许绑定，那么你应返回null． public boolean onUnbind(Intent intent) 绑定的所有客户端断开连接的时候回调 public void onDestroy() 系统在service不再被使用并要销毁时调用此方法．你的service应在此方法中释放资源，比如线程，已注册的侦听器，接收器等等．这是service收到的最后一个调用． public void onRebind(Intent intent) onUnbind返回true且Service重新绑定时回调 startService public ComponentName startService(Intent service) 开始服务 一个应用组件，比如一个activity可以通过调用startService()启动service同时传递一个指定service和service所用的数据的Intent，service在方法onStartCommand()中接收这个Intent． public boolean stopService(Intent name) 停止服务 一个启动的service，在被其它组件调用startService()来启动时，会导致service的onStartCommand()方法被调用． bindService public boolean bindService(Intent service, ServiceConnection conn,int flags) 绑定服务 应用组件(客户端)可以调用bindService()绑定到一个service．Android系统之后调用service的onBind()方法，它返回一个用来与service交互的IBinder． 绑定是异步的．它不会立即返回IBinder给客户端．要接收IBinder，客户端必须创建一个ServiceConnection的实例并传给bindService()．ServiceConnection包含一个回调方法，系统调用这个方法来传递要返回的IBinder． public void unbindService(ServiceConnection conn) 解绑服务 ServiceConnection public void onServiceConnected(ComponentName name, IBinder service) 系统调用这个来传送在service的onBind()中返回的IBinder． public void onServiceDisconnected(ComponentName name) Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用． bindService的Flags BIND_AUTO_CREATE 表示当收到绑定请求时，如果服务尚未创建，则即刻创建，在系统内存不足，需要先销毁优先级组件来释放内存，且只有驻留该服务的进程成为被销毁对象时，服务才可被销毁； BIND_DEBUG_UNBIND 通常用于调试场景中判断绑定的服务是否正确，但其会引起内存泄漏，因此非调试目的不建议使用； BIND_NOT_FOREGROUND 表示系统将阻止驻留该服务的进程具有前台优先级，仅在后台运行 终止服务被启动类型的服务必须管理它自己的生命周期。也就是说除非系统要回收系统内存，否则系统不会终止或销毁这个服务，在onStartCommand()方法返回后，这个服务会继续运行。因此而这种类型的服务必须通过调用stopSelf()方法或另一个组件通过调用stopService()方法才能终止。一旦用stopSelf()方法或stopService()方法请求终止服务，那么系统一有可能就会销毁这个服务。 但是，如果你的服务同时处理多个对onStartCommand()方法的请求，那么在你完成请求启动过程时，不应该终止这个服务，因为你的服务可能正在接受一个新的启动请求（在第一个请求结束时终止服务有可能会终止第二个请求）。要避免这个问题，你能够使用stopSelf(int)方法来确保你请求终止的服务始终是基于最近启动的请求。也就是说，调用stopSelf(int)方法时，你要把那个要终止的服务ID传递给这个方法（这个ID是发送给onStartCommand()方法的）。这样如果服务在你调用stopSelf(int)方法之前收到了一个新的启动请求，那么这个ID就会因不匹配而不被终止。 警告：重要的是你的应用程序要在工作结束时终止它们的服务，从而避免浪费系统资源和电池电量。如果需要，其他的组件能够调用stopService()方法终止服务。即使对于能够绑定的服务，如果这个服务接收了对onStartCommand()方法的调用，你也必须自己来终止这个服务。 Service组件表示在不影响用户的情况下执行耗时的操作或者提供其他应用使用的功能 5.0开始，必须使用显示Intent启动Service组件 当程序使用startService()和stopService()启动、关闭Service时,Service与访问者之间基本上不存在太多关联，因此Service和访问者之间也无法进行通讯,交换数据 实现ServiceConnection. 你的实现必须重写两个回调方法： onServiceConnected() 系统调用这个来传送在service的onBind()中返回的IBinder． OnServiceDisconnected() Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用． 在你的service中，创建一个Binder实例，提供以下三种功能之一： Binder包含一些可供客户端调用的公开方法． 返回当前的Service实例，它具有一些客户端可以调用的公开方法． 或者，返回另一个类的实例，这个类具有客户端可调用的公开方法并托管于service． IntentService这是一个Service类的子类，它使用工作线程来依次处理所有的启动请求，如果你不想要服务同时处理多个请求，那么这是最好的选择。需要你做的所有工作就是实现onHandleIntent()方法，它接受每个启动请求的Intent对象，以便完成后台工作。 因为大多被启动类型的服务不需要同时处理多个请求（这实际是一个危险的多线程场景），因此使用IntentService类来实现自己的服务可能是最好的。IntentService类执行以下操作： 创建一个独立与应用程序主线程的默认工作线程，执行所有的给onStartCommand()方法Intent的处理； 创建一个工作队列，以便每次只给你的onHandleIntent()方法实现传递一个Intent，因此你不必担心多线程的问题； 所有的启动请求都被处理之后终止这个服务，因此你不需要自己去调用stopSelf()方法； 提供返回null的onBind()方法的默认实现； 提供一个给工作队列发送Intent对象的onStartCommand()方法的默认实现和onHandleIntent()方法的实现。 所以这些加起来实际上只需要实现onHandleIntent()方法，来完成由客户提供的工作（虽然，你还需要给服务提供一个小的构造器）。 例如： public class HelloIntentService extends IntentService { /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() { super(\"HelloIntentService\"); } /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. long endTime = System.currentTimeMillis() + 5*1000; while (System.currentTimeMillis() &lt; endTime) { synchronized (this) { try { wait(endTime - System.currentTimeMillis()); } catch (Exception e) { } } } } } 以上就是你做的全部：一个构造器和一个onHandleIntent()方法的实现。 如果你还决定要重写其他的回调方法，如onCreate()、onStartCommand()、或onDestroy()，那么就要确保调用父类的实现，以便IntentService对象能够适当的处理工作线程的活动。 例如，onStartCommand()方法必须返回默认的实现（默认的实现获取Intent并把它交付给onHandleIntent()方法）： @Override public int onStartCommand(Intent intent, int flags, int startId) { Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId); } 除了onHandleIntent()方法以外，唯一不需要调用实现的方法是onBind()方法（但是如果你的服务允许绑定，就要实现这个方法）。 Service的生命周期无绑定Service 有绑定Service 后绑定Service 前台服务Service如果要防止尽可能不被系统杀掉，需要设置为在前台运行。 启动为前台服务 创建Notification对象 调用startForeground()方法 终止前台服务 调用stopForeground()方法 检查是否运行1.如何检查Android后台服务线程（Service类）是否正在运行 Android系统自己提供了一个函数ActivityManager.getRunningServices，可以列出当前正在运行的后台服务线程 private boolean isServiceRunning() { ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE); for (RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) { if (\"com.example.MyService\".equals(service.service.getClassName())) { return true; } } return false; } 参考资料FireOfStar的专栏Android开发进阶从小工到专家疯狂Android讲义","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"Zygote","slug":"Zygote","date":"2016-10-03T14:00:00.000Z","updated":"2017-11-14T15:41:23.466Z","comments":true,"path":"2016/10/03/Zygote/","link":"","permalink":"https://luoweiguang.github.io/2016/10/03/Zygote/","excerpt":"本篇基于android2.2.3Zygote是Android系统应用中一个相当重要的进程，它的主要功能就是执行Android应用程序","text":"本篇基于android2.2.3Zygote是Android系统应用中一个相当重要的进程，它的主要功能就是执行Android应用程序 Zygote进程运行时，会初始化Dalvik虚拟机，并启动它。 在Android中，应用程序运行前，Zygote进程通过共享已运行的虚拟机的代码与内存信息，缩短应用程序运行所耗费的时间。并且，它会实现将应用程序要使用的Android Framework中的类与资源加载到内存中，并组织形成所用资源的链接信息。新运行的Android应用程序在使用所需资源时不必每次重新形成资源的链接信息，这会节省大量时间，提供程序运行速度 Android的服务与应用程序都由Zygote进程启动运行 Zygote启动后，初始化运行Dalvik虚拟机，而后将需要的类与资源加载到内存中。随后调用fork()创建出Zygote的子进程，接着Zygote的子进程动态加载并运行Android应用程序A。运行的应用程序A会使用Zygote已经初始化并启动运行的Dalvik虚拟机代码，通过使用已加载至内存中的类与资源来加快运行速度。 与其他本地服务或Daemon不同的是，Zygote由Java编写而成，不能直接由init进程启动运行。若想运行Zygote类，必须先生成Dalvik虚拟机，再在Dalvik虚拟机上装载ZygoteInit类，执行这一任务的就是app_process进程。 app_process int main(int argc, const char* const argv[]) { mArgC = argc; mArgV = argv; mArgLen = 0; for (int i=0; i&lt;argc; i++) { mArgLen += strlen(argv[i]) + 1; } mArgLen--; AppRuntime runtime; ... int i = runtime.addVmArguments(argc, argv); if (i &lt; argc) { runtime.mParentDir = argv[i++]; if (0 == strcmp(\"--zygote\", arg)) { bool startSystemServer = (i &lt; argc) ? strcmp(argv[i], \"--start-system-server\") == 0 : false; setArgv0(argv0, \"zygote\"); //设置本进程的名称为zygote set_process_name(\"zygote\"); //注意第二个参数为true runtime.start(\"com.android.internal.os.ZygoteInit\",startSystemServer); } else { set_process_name(argv0); runtime.mClassName = arg; runtime.mArgC = argc-i; runtime.mArgV = argv+i; ... runtime.start(); } } ... } AndroidRuntimeAppRuntime类继承字AndroidRuntime类，AndroidRuntime类用于初始化并运行Dalvik虚拟机，为运行Android应用程序做好准备。 在运行Dalvik虚拟机之前，通过AppRuntime对象，分析环境变量以及运行的参数，并以此生成虚拟机选项。 AndroidRuntime::start void AndroidRuntime::start(const char* className, const bool startSystemServer) { //className的值\"com.android.internal.os.ZygoteInit\" //startSystemServer的值是true char* slashClassName = NULL; char* cp; JNIEnv* env; blockSigpipe(); //处理SIGPIPE信号 ... const char* rootDir = getenv(\"ANDROID_ROOT\"); if (rootDir == NULL) { //如果环境变量中没有ANDROID_ROOT,则新增该变量。并设置值为\"/system\" rootDir = \"/system\"; ... setenv(\"ANDROID_ROOT\", rootDir, 1); } //创建虚拟机 if (startVm(&amp;mJavaVM, &amp;env) != 0) goto bail; ... //注册JNI函数 if (startReg(env) &lt; 0) { ... goto bail; } ... stringClass = env->FindClass(\"java/lang/String\"); //创建一个有两个元素的String数组，即Java代码String strArray[] = new String[2]; strArray = env->NewObjectArray(2, stringClass, NULL); classNameStr = env->NewStringUTF(className); //设置第一个元素\"com.android.internal.os.ZygoteInit\" env->SetObjectArrayElement(strArray, 0, classNameStr); startSystemServerStr = env->NewStringUTF(startSystemServer ?\"true\" : \"false\"); //设置第二个元素为\"true\"，注意这两个元素都是String类型，即字符串 env->SetObjectArrayElement(strArray, 1, startSystemServerStr); jclass startClass; jmethodID startMeth; slashClassName = strdup(className); /* 将字符串\"com.android.internal.os.ZygoteInot\"中的\".\"换成\"/\". 即\"com/android/internal/os/ZygoteInit\",这个名称符合JNI规范。 */ for (cp = slashClassName; *cp != '\\0'; cp++) if (*cp == '.') *cp = '/'; startClass = env->FindClass(slashClassName); if (startClass == NULL) { } else { //找到ZygoteInit类的static main函数的jMethodId startMeth = env->GetStaticMethodID(startClass, \"main\",\"([Ljava/lang/String;)V\"); if (startMeth == NULL) { } else { /* 通过JNI调用Java函数，注意调用的函数是main，传入的参数为\"true\" 所属的类是com.android.internal.os.ZygoteInit 在调用ZygoteInit的main函数后，Zygote便进入Java世界 */ env->CallStaticVoidMethod(startClass, startMeth, strArray); //zygote退出,在正常情况下，zygote不需要退出 if (mJavaVM->DetachCurrentThread() != JNI_OK) ... if (mJavaVM->DestroyJavaVM() != 0) ... bail: free(slashClassName); } AndroidRuntime::startVmint AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv) { //设置虚拟机参数，创建虚拟机 ... } AndroidRuntime::startRegint AndroidRuntime::startReg(JNIEnv* env) { //设置Thread类的线程创建函数为javaCreateThreadEtc androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); env->PushLocalFrame(200); //注册JNI函数，gRegJNI是一个全局数组 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) { env->PopLocalFrame(NULL); return -1; } env->PopLocalFrame(NULL); ... return 0; } ZygoteInitpublic static void main(String argv[]) { try { SamplingProfilerIntegration.start(); //注册Zygote用的socket registerZygoteSocket(); ... //预加载类和资源 preloadClasses(); preloadResources(); ... //强制执行一次垃圾收集 gc(); ... if (argv[1].equals(\"true\")) { startSystemServer();//启动system_server } else if (!argv[1].equals(\"false\")) { throw new RuntimeException(argv[0] + USAGE_STRING); } ... if (ZYGOTE_FORK_MODE) { runForkMode(); } else { //处理新Android应用程序运行请求 runSelectLoopMode(); } closeServerSocket();//关闭socket } catch (MethodAndArgsCaller caller) { caller.run(); } catch (RuntimeException ex) { ... closeServerSocket(); throw ex; } } ZygoteInit类的功能 绑定套接字，接收新Android应用程序运行请求为了从ActivityManager接收新Android应用程序的运行请求，Zygote使用UDS(Unix Domain Socket),init进程在运行app_process时，使用init.rc文件中以”/dev/zygote”形式注册的套接字registerZygoteSocket private static void registerZygoteSocket() { if (sServerSocket == null) { int fileDesc; try { //从环境变量中获取Socket的fd String env = System.getenv(ANDROID_SOCKET_ENV); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(ANDROID_SOCKET_ENV + \" unset or invalid\", ex); } try { //创建服务端Socket，这个Socket将listen并accept Client sServerSocket = new LocalServerSocket(createFileDescriptor(fileDesc)); } catch (IOException ex) { throw new RuntimeException(\"Error binding to local socket '\" + fileDesc + \"'\", ex); } } } 加载Android Application Framework使用的类与资源将应用程序框架中的类、平台资源(图像、XML信息、字符串等)预先加载到内存中。新进程直接使用这些类与资源，而不需要重新加载它们，这大大加快了程序的执行速度preloadClasses private static final String PRELOADED_CLASSES = \"preloaded-classes\"; private static void preloadClasses() { final VMRuntime runtime = VMRuntime.getRuntime(); //预加载类的信息存储在PRELOADED_CLASSES变量中，它的值为\"preloaded-classes\" InputStream is = ZygoteInit.class.getClassLoader().getResourceAsStream(PRELOADED_CLASSES); if (is == null) { Log.e(TAG, \"Couldn't find \" + PRELOADED_CLASSES + \".\"); } else { ...//做一些统计和准备工作 try { //读取\"preloaded-classes\"文件的内容 BufferedReader br = new BufferedReader(new InputStreamReader(is), 256); int count = 0; String line; String missingClasses = null; while ((line = br.readLine()) != null) { //读取文件的每一行，忽略#开头的注释行 line = line.trim(); if (line.startsWith(\"#\") || line.equals(\"\")) { continue; } try { if (Config.LOGV) { Log.v(TAG, \"Preloading \" + line + \"...\"); } //通过Java反射来记载类，line中存储的是预加载的类名 Class.forName(line); ... count++; } catch (ClassNotFoundException e) { ... } catch (Throwable t) { ... } } ...//扫尾工作 } } } preloaded-classes # Classes which are preloaded by com.android.internal.os.ZygoteInit. 2# Automatically generated by frameworks/base/tools/preload/WritePreloadedClassFile.java. 3# MIN_LOAD_TIME_MICROS=1250 4android.R$styleable 5android.accounts.AccountManager 6android.accounts.AccountManager$4 7android.accounts.AccountManager$6 8android.accounts.AccountManager$AmsTask ... preload_class文件由framework/base/tools/preload工具生成，它判断每个类的加载的时间是否大于1250微秒（1.25毫秒）即MIN_LOAD_TIME_MICROS=1250，超时的类会被写入到preload-classes文件中，最后由zygote预加载preloadResources private static void preloadResources() { final VMRuntime runtime = VMRuntime.getRuntime(); Debug.startAllocCounting(); try { runtime.gcSoftReferences(); runtime.runFinalizationSync(); //预加载系统资源 mResources = Resources.getSystem(); mResources.startPreloading(); if (PRELOAD_RESOURCES) { Log.i(TAG, \"Preloading resources...\"); long startTime = SystemClock.uptimeMillis(); //加载Drawable资源 TypedArray ar = mResources.obtainTypedArray(com.android.internal.R.array.preloaded_drawables); int N = preloadDrawables(runtime, ar); Log.i(TAG, \"...preloaded \" + N + \" resources in \"+ (SystemClock.uptimeMillis()-startTime) + \"ms.\"); startTime = SystemClock.uptimeMillis(); //加载Color State资源 ar = mResources.obtainTypedArray(com.android.internal.R.array.preloaded_color_state_lists); N = preloadColorStateLists(runtime, ar); Log.i(TAG, \"...preloaded \" + N + \" resources in \"+ (SystemClock.uptimeMillis()-startTime) + \"ms.\"); } mResources.finishPreloading(); } catch (RuntimeException e) { Log.w(TAG, \"Failure preloading resources\", e); } finally { Debug.stopAllocCounting(); } } 加载Drawable与Color State资源,preloaded_drawables与preloaded_color_state_lists记录的会被加载到内存中 启动运行SystemServer通过app_process运行zygote时，参数”–start-system-server”会调用startSystemServer方法启动系统服务器，系统服务器用来运行Android平台需要的一些主要的本地服务startSystemServer private static boolean startSystemServer()throws MethodAndArgsCaller, RuntimeException { //该数组保存SystemServer的启动参数 String args[] = { \"--setuid=1000\", //uid \"--setgid=1000\", //gid \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,3001,3002,3003\", \"--capabilities=130104352,130104352\", \"--runtime-init\", \"--nice-name=system_server\", //进程名 \"com.android.server.SystemServer\", //启动的类名 }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { //把上面字符串数组参数转换成Arguments对象 parsedArgs = new ZygoteConnection.Arguments(args); int debugFlags = parsedArgs.debugFlags; if(\"1\".equals(SystemProperties.get(\"ro.debuggable\"))) debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER; //fork一个子进程 pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } //如果pid为0，表示处在子进程中，也就是处于system_server进程中 if (pid == 0) { //system_server进程工作 handleSystemServerProcess(parsedArgs); } return true; } 与运行其他应用程序不同，startSystemServer方法会调用forkSystemServer()方法来创建新进程，并运行SystemServer。系统在运行普通Android应用程序时，只负责创建应用程序进程，至于进程是否创建成功并不检查。与此不同，SystemServer是必须运行的，因此在forkSystemServer()方法中必须检查生成的SystemServer进程是否正常 在生成的SystemServer进程中运行com.android.server.SystemServer类的main()方法main public static void main(String[] args) { ... VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); System.loadLibrary(\"android_servers\"); init1(args); } 执行main()方法时会加载名称为android_server的本地库。本地库加载完毕后，继续加载init1()函数，它是一个JNI本地方法。init1()函数调用system_init()函数，启动Audio Flinger、Surface Flinger、MediaPlayerService、CameraService等本地服务system_init extern \"C\" status_t system_init() { ... if (strcmp(propBuf, \"1\") == 0) { SurfaceFlinger::instantiate(); } if (!proc->supportsProcesses()) { AudioFlinger::instantiate(); MediaPlayerService::instantiate(); CameraService::instantiate(); AudioPolicyService::instantiate(); } ... AndroidRuntime* runtime = AndroidRuntime::getRuntime(); ... runtime->callStatic(\"com/android/server/SystemServer\", \"init2\"); if (proc->supportsProcesses()) { LOGI(\"System server: entering thread pool.\\n\"); ProcessState::self()->startThreadPool(); IPCThreadState::self()->joinThreadPool(); LOGI(\"System server: exiting thread pool.\\n\"); } return NO_ERROR; } 本地服务组成完毕后，再此调用SystemServer类的静态方法init2(),init2()方法创建android.server.ServerThread线程，并启动它，从而运行Android Framework的主要服务init2 public static final void init2() { Slog.i(TAG, \"Entered the Android system server!\"); Thread thr = new ServerThread(); thr.setName(\"android.server.ServerThread\"); thr.start(); } 当ServerThread线程创建好并运行后，Thread类的run()方法被调用，此时ServerThread类中重定义的run()方法被调用。在run()方法中包含主要服务生成与注册的代码当所有服务正常启动后，Zygote才做好运行新应用程序的准备 处理新Android应用程序运行请求监视UDS,若收到新Android应用程序生成请求，则进入处理循环 在SystemServer运行后，程序会进入一个循环，处理来自多有绑定的套接字的请求，若ZYGOTE_FORK_MODE为false，程序就会调用runSelectLoopMode()方法，直到Zygote进程终止，该方法才会返回runSelectLoopMode private static void runSelectLoopMode() throws MethodAndArgsCaller { ArrayList&lt;FileDescriptor> fds = new ArrayList(); ArrayList&lt;ZygoteConnection> peers = new ArrayList(); FileDescriptor[] fdArray = new FileDescriptor[4]; //sServerSocket是我们先前在registerZygoteSocket中建立的Socket fds.add(sServerSocket.getFileDescriptor()); peers.add(null); int loopCount = GC_LOOP_COUNT; while (true) { int index; if (loopCount &lt;= 0) { gc(); loopCount = GC_LOOP_COUNT; } else { loopCount--; } try { fdArray = fds.toArray(fdArray); /* selectReadable内部调用select,使用多路复用I/O模型 当有客户端连接或有数据时，则selectReadable就会返回 */ index = selectReadable(fdArray); } catch (IOException ex) { throw new RuntimeException(\"Error in select()\", ex); } if (index &lt; 0) { throw new RuntimeException(\"Error in select()\"); } else if (index == 0) { ZygoteConnection newPeer = acceptCommandPeer(); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); } else { boolean done; //客户端发送了请求,peers.get返回的是ZygoteConnection done = peers.get(index).runOnce(); if (done) { peers.remove(index); fds.remove(index); } } } } runOnce boolean runOnce() throws ZygoteInit.MethodAndArgsCaller { String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try { //读取请求信息，请求信息包含创建新进程的参数选项 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); } catch (IOException ex) { Log.w(TAG, \"IOException on command socket \" + ex.getMessage()); closeSocket(); return true; } if (args == null) { closeSocket(); return true; } PrintStream newStderr = null; if (descriptors != null &amp;&amp; descriptors.length >= 3) { newStderr = new PrintStream( new FileOutputStream(descriptors[2])); } int pid; try { /* 分析请求信息中的字符串数组，为运行进程设置好各个选项，具体 包括了设置应用程序的gid、uid、调试标记处理,设置rlimit，以及检查运行权限等 */ parsedArgs = new Arguments(args); applyUidSecurityPolicy(parsedArgs, peer); applyDebuggerSecurityPolicy(parsedArgs); applyRlimitSecurityPolicy(parsedArgs, peer); applyCapabilitiesSecurityPolicy(parsedArgs, peer); int[][] rlimits = null; if (parsedArgs.rlimits != null) { rlimits = parsedArgs.rlimits.toArray(intArray2d); } //创建新进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits); } catch (IllegalArgumentException ex) { logAndPrintError (newStderr, \"Invalid zygote arguments\", ex); pid = -1; } catch (ZygoteSecurityException ex) { logAndPrintError(newStderr,\"Zygote security policy preventsrequest: \", ex); pid = -1; } if (pid == 0) { handleChildProc(parsedArgs, descriptors, newStderr); return true; } else { return handleParentProc(pid, descriptors, parsedArgs); } } 参考资料Amdroid框架揭秘深入理解Android卷I","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android Framework","slug":"Android-Framework","permalink":"https://luoweiguang.github.io/tags/Android-Framework/"}]},{"title":"JNI(直接注册JNI本地函数)","slug":"JNI(直接注册JNI本地函数)","date":"2016-09-30T14:00:00.000Z","updated":"2017-11-14T15:49:20.773Z","comments":true,"path":"2016/09/30/JNI(直接注册JNI本地函数)/","link":"","permalink":"https://luoweiguang.github.io/2016/09/30/JNI(直接注册JNI本地函数)/","excerpt":"JNI机制提供了名称为RegisterNatives()的JNI函数，该函数运行C/C++开发者将JNI本地函数与Java类的本地方法直接映射在一起。当不调用RegisterNatives()函数时，Java虚拟机会自动检索并将JNI本地函数与相应的Java本地方法链接在一起。但当开发者直接调用RegisterNatives()函数进行映射时，Java虚拟机就不必进行映射处理，这会极大提高运行速度，提高运行效率。","text":"JNI机制提供了名称为RegisterNatives()的JNI函数，该函数运行C/C++开发者将JNI本地函数与Java类的本地方法直接映射在一起。当不调用RegisterNatives()函数时，Java虚拟机会自动检索并将JNI本地函数与相应的Java本地方法链接在一起。但当开发者直接调用RegisterNatives()函数进行映射时，Java虚拟机就不必进行映射处理，这会极大提高运行速度，提高运行效率。 实例HelloJNI.java public class HelloJNI { //本地方法声明 native void printHello(); native void printString(String str); //加载库 static { System.loadLibrary(\"hellojni\"); } public static void main(String[] args) { HelloJNI myJNI = new HelloJNI(); //调用本地方法(实际调用的是使用C语言编写的JNI本地函数) myJNI.printHello(); myJNI.printString(\"Hello World from printString fun\"); } } hellojnimap.cpp #include \"jni.h\" #include &lt;stdio.h> //JNI本地函数原型 void printHelloNative(JNIEnv *env,jobject obj); void printStringNative(JNIEnv *env,jobject obj,jstring string); JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) { JNIEnv* env = NULL; JNINativeMethod nm[2]; jclass cls; jint result = -1; if(vm->GetEnv((void**) &amp;env,JNI_VERSION_1_4) != JNI_OK) { printf(\"Error\"); return JNI_ERR; } cls = env->FindClass(\"HelloJNI\"); nm[0].name = (char *)\"printHello\"; nm[0].signature = (char *)\"()V\"; nm[0].fnPtr = (void *)printHelloNative; nm[1].name = (char *)\"printString\"; nm[1].signature = (char *)\"(Ljava/lang/String;)V\"; nm[1].fnPtr = (void *)printStringNative; env->RegisterNatives(cls,nm,2); return JNI_VERSION_1_4; } //实现JNI本地函数 void printHelloNative(JNIEnv *env,jobject obj) { printf(\"Hello World!\\n\"); return; } void printStringNative(JNIEnv *env,jobject obj,jstring string) { const char *str = env->GetStringUTFChars(string,0); printf(\"%s!\\n\",str); return; } 编译: gcc -shared -o hellojni.dll hellojnimap.cpp javac HelloJNI.java 运行: java HelloJNI 结果: Hello World! Hello World from printString fun! JNI_OnLoad()讲解在加载指定库文件时，JNI_OnLoad()函数会被自动调用执行，程序开发者若想手工映射本地方法与JNI本地函数，需要在JNI_OnLoad()函数内调用RegisterNatives()函数进行映射匹配。 JNI_OnLoad() 形式:jint JNI_OnLoad(JavaVM *vm,void *reserved) 说明:Java虚拟机加载本地库时(System.loadLibrary()等方法被调用时)会调用JNI_OnLoad()函数。在使用加载库的过程中，JNI_OnLoad()函数会向Java虚拟机确认JNI的版本。若库中不包含JNI_OnLoad()函数,Java虚拟机会认为相关库要求JNI1.1版本支持 参数: vm JavaVM接口指针 reserved 预定参数 返回值:若执行成功，则返回所生成的数组引用，若失败，则返回NULL 判断支持版本GetEnv() 形式:jnit GetEnv(JavaVM *vm,void **env,jint version) 说明:判断Java虚拟机是否支持version指定的JNI版本，而后将JNI接口指针设置到*env中 参数: vm JavaVM接口指针的地址 env JNI接口指针地址 version JNI版本 返回值:若执行成功，返回0，失败,返回负数 注册绑定JNINativeMethod用来保存待映射的本地方法与JNI本地函数的相关信息 typedef struct { char *name;//本地方法名称 char *signature;//本地方法签名 void *fnPtr;//与本地方法相对应的JNI本地函数指针 } JNINativeMethod RegisterNatives() 形式:jarray RegisterNatives(JNIEnv *env,jclass clazz,const JNINativeMethod *methods,jnit nMethods) 说明:将clazz指定类中的本地方法与JNI本地函数链接在一起，链接信息保存在JNINativeMethod结构体数组中 参数 env JNI接口指针 clazz Java类 methods 包含本地方法与JNI本地函数的链接信息 nMethods methods数组元素的个数 返回值若执行成功，返回数组引用，否则，返回NULL 参考资料Amdroid框架揭秘","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"JNI","slug":"JNI","permalink":"https://luoweiguang.github.io/tags/JNI/"},{"name":"Java进阶","slug":"Java进阶","permalink":"https://luoweiguang.github.io/tags/Java进阶/"}]},{"title":"JNI(在C程序中运行Java类)","slug":"JNI(在C程序中运行Java类)","date":"2016-09-29T14:00:00.000Z","updated":"2017-11-14T15:55:14.573Z","comments":true,"path":"2016/09/29/JNI(在C程序中运行Java类)/","link":"","permalink":"https://luoweiguang.github.io/2016/09/29/JNI(在C程序中运行Java类)/","excerpt":"C/C++代码中调用Java代码的几种典型情况\n\n需要在C/C++编写的本地应用程序中访问用Java语言编写的代码或代码库\n希望在C/C++编写的本地应用程序中使用标准Java类库\n当需要把已有的C/C++程序与Java程序组织链接在一起时，使用Invocation API,可以将它们组织成一个完整的程序\n","text":"C/C++代码中调用Java代码的几种典型情况 需要在C/C++编写的本地应用程序中访问用Java语言编写的代码或代码库 希望在C/C++编写的本地应用程序中使用标准Java类库 当需要把已有的C/C++程序与Java程序组织链接在一起时，使用Invocation API,可以将它们组织成一个完整的程序 应用示例步骤 使用Invocation API加载Java虚拟机 加载Java类 执行被加载类的方法 销毁Java虚拟机 应用示例代码InvocationApiTest.java public class InvocationApiTest { public static void main(String[] args) { System.out.println(args[0]); } } invocationApi.c #include &lt;jni.h> int main() { JNIEnv *env; JavaVM *vm; JavaVMInitArgs vm_args; JavaVMOption options[1]; jint res; jclass cls; jmethodID mid; jstring jstr; jclass stringClass; jobjectArray args; //生成Java虚拟机选项 options[0].optionString = \"-Djava.class.path=.\"; vm_args.version = 0x00010002; vm_args.options = options; vm_args.nOptions = 1; vm_args.ignoreUnrecognized = JNI_TRUE; //生成Java虚拟机 res = JNI_CreateJavaVM(&amp;vm,(void**)&amp;env,&amp;vm_args); //查找并加载类 cls = (*env)->FindClass(env,\"InvocationApiTest\"); //获取main()方法的ID mid = (*env)->GetStaticMethodID(env,cls,\"main\",\"([Ljava/lang/String;)V\"); //生成字符串对象，用作main()方法的参数 jstr = (*env)->NewStringUTF(env,\"Hello Invocation API!!\"); stringClass = (*env)->FindClass(env,\"java/lang/String\"); args = (*env)->NewObjectArray(env,1,stringClass,jstr); // //调用main()方法 (*env)->CallStaticVoidMethod(env,cls,mid,args); //销毁Java虚拟机 (*vm)->DestroyJavaVM(vm); } 编译命令 gcc invocationApi.c &quot;C:\\Program Files\\Java\\jdk1.8.0_73\\lib\\jvm.lib&quot; -lstdc++ -o invocationApi.exe 运行命令 invocationApi.exe 结果 Hello Invocation API!! 创建虚拟机在生成Java虚拟机选项时，使用的JavaVMInitArgs与JavaVMOption结构体，它们定义在jni.h头文件中 typedef struct JavaVMOption { char *optionString; void *extraInfo; } JavaVMOption; typedef struct JavaVMInitArgs { jint version;//版本号设置 jint nOptions;//JavaVMOption结构体数组元素个数 JavaVMOption *options;//JavaVMOption结构体的地址 jboolean ignoreUnrecognized;//虚拟中读到错误设置是否忽略错误继续执行 } JavaVMInitArgs; JavaVMOption结构体用来指定Java虚拟机的选项值，其形式为-D&lt;property&gt;=&lt;value&gt; JNI_CreateJavaVM 形式:jint JNI_CreateJavaVM(JavaVM **vm,JNIEnv **env,void *vm_args) 说明:装载并初始化Java虚拟机 参数: vm JavaVM指针的地址 env JNI接口指针的地址 vm_args 传递给Java虚拟机的参数 返回值:成功，返回0，失败，返回负值 创建数组NewObjectArray 形式jarray NewObjectArray(JNIEnv *env,jsize length,jclass elementClass,jobject initalElement) 说明:生成由elementClass对象组成的数组。数组元素个数由length指定，initalElement参数用来初始化对象数组 参数: env JNI接口指针 length 数组元素个数 elementClass 数组元素对象的类型 initialElement 数组初始化值 返回值:若成功，则返回数组引用，失败，则返回NULL 字符串转换NewStringUTF 形式:jstring NewStringUTF(JNIEnv *env,const char *bytes) 说明:将UTF-8形式的C字符串转换成java.lang.String对象 参数: env JNI接口指针 bytes 待生成String对象的C字符串的地址 返回值:成功，返回String对象的jstring类型的引用,失败,返回NULL GetStringUTFChars 形式:const jbyte*GetStringUTFChars(JNIEnv *env,jstring string,jboolean *isCopy) 说明:将Java字符串对象转换成UTF-8字符串(C字符串)，并返回指针 参数: env JNI接口指针 string Java字符串对象 isCopy 当String对象中的字符串被转换成UTF-8字符串，被复制到内存，且指针被返回时，*isCopy 设置为JNI_TRUE,否则设置为JNI_FALSE 参考资料Amdroid框架揭秘","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"JNI","slug":"JNI","permalink":"https://luoweiguang.github.io/tags/JNI/"},{"name":"Java进阶","slug":"Java进阶","permalink":"https://luoweiguang.github.io/tags/Java进阶/"}]},{"title":"JNI(调用JNI函数)","slug":"JNI(调用JNI函数)","date":"2016-09-29T12:00:00.000Z","updated":"2017-11-14T16:00:36.759Z","comments":true,"path":"2016/09/29/JNI(调用JNI函数)/","link":"","permalink":"https://luoweiguang.github.io/2016/09/29/JNI(调用JNI函数)/","excerpt":"示例程序运行顺序\n调用JNI本地函数\n访问静态成员获取值\n创建JniTest对象\n调用JniTest对象的方法\n传递返回值\n访问成员变量设定其值\n","text":"示例程序运行顺序 调用JNI本地函数 访问静态成员获取值 创建JniTest对象 调用JniTest对象的方法 传递返回值 访问成员变量设定其值 JniFuncMain.java public class JniFuncMain { private static int staticIntField = 300; //加载本地库jinfunc.dll static {System.loadLibrary(\"jnifunc\");} //本地方法声明 public static native JniTest createJniObject(); public static void main(String[] args) { //从本地代码生成JniTest对象 System.out.println(\"[Java]createJniObject()调用本地方法\"); //使用static关键字，不需要创建对象，直接通过JniFuncMain类调用即可 JniTest jniObj = createJniObject(); //调用JniTest对象的方法 jniObj.callTest(); } } JniTest.java public class JniTest { private int intField; //构造方法 public JniTest(int num) { intField = num; System.out.println(\"[Java] 调用JniTest对象的构造方法:intField = \" + intField); } //此方法由JNI本地函数调用 public int callByNative(int num) { System.out.println(\"[Java] JniTest对象的callByNative(\" + num + \")调用\"); return num; } public void callTest() { System.out.println(\"[Java] JniTest对象的callTest()方法调用:intField=\"+intField); } } JniFuncMain.h /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class JniFuncMain */ #ifndef _Included_JniFuncMain #define _Included_JniFuncMain #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: JniFuncMain * Method: createJniObject * Signature: ()LJniTest; */ JNIEXPORT jobject JNICALL Java_JniFuncMain_createJniObject (JNIEnv *, jclass); #ifdef __cplusplus } #endif #endif jnifunc.cpp #include \"JniFuncMain.h\" #include &lt;stdio.h> JNIEXPORT jobject JNICALL Java_JniFuncMain_createJniObject(JNIEnv *env,jclass clazz) { jclass targetClass; jmethodID mid; jobject newObject; jstring helloStr; jfieldID fid; jint staticIntField; jint result; //获取JniFuncMain类的staticIntField变量值 fid = env->GetStaticFieldID(clazz,\"staticIntField\",\"I\"); //读取jclass与fieldid指定的成员变量值 staticIntField = env->GetStaticIntField(clazz,fid); printf(\"[CPP]获取JniFuncMain类的staticIntField变量值\\n\"); printf(\" JniFuncMain.staticIntField = %d\\n\", staticIntField); //查找生成对象的类 targetClass = env->FindClass(\"JniTest\"); //查找构造方法 mid = env->GetMethodID(targetClass,\"&lt;init>\",\"(I)V\"); //生成JniTest对象(返回对象的引用) printf(\"[CPP]JniTest对象生成\\n\"); newObject = env->NewObject(targetClass,mid,100); //调用对象的方法 mid = env->GetMethodID(targetClass,\"callByNative\",\"(I)I\"); result = env->CallIntMethod(newObject,mid,200); //设置JniObject对象的intField值 fid = env->GetFieldID(targetClass,\"intField\",\"I\"); printf(\"[CPP]设置JniObject对象的intField值为200\\n\"); env->SetIntField(newObject,fid,result); //返回对象的引用 return newObject; } 编译命令 gcc -finput-charset=UTF-8 -fexec-charset=GBK -shared -o jnifunc.dll jnifunc.cpp 运行命令 java JniFuncMain 输出结果 [Java]createJniObject()调用本地方法 [CPP]获取JniFuncMain类的staticIntField变量值 JniFuncMain.staticIntField = 300 [CPP]JniTest对象生成 [Java] 调用JniTest对象的构造方法:intField = 100 [Java] JniTest对象的callByNative(200)调用 [CPP]设置JniObject对象的intField值为200 [Java] JniTest对象的callTest()方法调用:intField=200 访问Java类/对象的成员变量步骤: 查找含待访问的成员变量的Java类的jclass值 查找此类成员变量的jfieldID值 使用jclass与jfieldID值，获取或设置成员变量值 若想要在本地代码中访问Java的成员变量，必须获取相应成员变量的ID值。成员变量的ID保存在jfieldID类型的变量中。由于待读取数值的staticIntField成员变量是JniFuncMain类的静态成员变量，在获取staticIntField的ID时，应调用名称为GetStaticFieldID()的JNI函数若想获取普通对象中的非静态成员变量的ID,应调用名称为GetFieldID()的JNI函数 获取jclass值FindClass() 形式:jclass FindClass(JNIEnv *env,const char *name) 说明:查找name指定的Java类 参数env JNI接口指针name 待查找的类名 返回值返回类的jclass值 GetObjectClass() 形式:jclass GetObjectClass(JNIEnv *env, jobject obj) 功能: 通过对象获取这个类。该函数比较简单，唯一注意的是对象不能为NULL，否则获取的class肯定返回也为NULL。 参数: env JNI 接口指针。 obj Java 类对象实例。 获取jfieldID值GetStaticFieldID() 形式:jfield GetStaticFieldID(JNIEnv *env,jclass clazz,const char *name,const *signature) 说明:返回指定类的指定的静态成员变量的jfieldID的值 参数: env JNI接口指针 clazz 包含成员变量的类的jclass name 成员变量名 signature 成员变量签名 GetFieldID() 形式:jfield GetFieldID(JNIEnv *env,jclass clazz,const char *name,const *signature) 说明:返回对象中指定的成员变量的jfieldID的值 参数: env JNI接口指针 clazz 包含成员变量的类的jclass name 成员变量名 signature 成员变量签名 获取签名在JNI中获取成员变量或成员方法签名 形式:javap [选项] ‘类名’选项: -s 输出Java签名 -p 输出所有类及成员 javap -s -p JniFuncMain 输出结果 Compiled from &quot;JniFuncMain.java&quot; public class JniFuncMain { private static int staticIntField; descriptor: I //签名 public JniFuncMain(); descriptor: ()V public static native JniTest createJniObject(); descriptor: ()LJniTest; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V static {}; descriptor: ()V } 获取成员变量值在获取成员变量所在的类的ID后，根据个成员变量的类型与存储区块，调用相应的JNI函数读取成员变量值即可。在JNI中有两种函数用来获取成员变量的值，分别为Get&lt;type&gt;Field函数与GetStatic&lt;type&gt;Field函数（&lt;type&gt;指Int、Char、Double等基本数据类型，具体参考JNI文档） GetStatic&lt;type&gt;Field() 形式:&lt;jnitype&gt; GetStatic&lt;type&gt;Field(JNIEnv *env,jclass clazz,jfieldID fieldID) 说明:返回clazz类中ID为fieldID的静态变量的值 参数: env JNI接口指针 clazz 包含成员变量的类 fieldID 成员变量的ID 参考:&lt;type&gt;指Object、Boolean、Byte、Char、Short、Int、Long、Float、Double九种基本类型。返回类型&lt;jnitype&gt;指jobject、jboolean、jbyte、jchar、jshort、jint、jlong、jfloat、jdouble九种基本类型这些类型也被应用到其他JNI函数的&lt;type&gt;中 返回值返回静态成员变量的值 Get&lt;type&gt;Field() 形式:&lt;jnitype&gt; Get&lt;type&gt;Field(JNIEnv *env,jobject obj,jfieldID fieldID) 说明:返回obj对象中ID为fieldID的成员变量的值 参数: env JNI接口指针 obj 包含成员变量的对象 fieldID 成员变量的ID 返回值返回成员变量的值 生成Java对象步骤: 查找指定的类，并将查找到的类赋给jclass类型的变量 查找Java类构造方法的ID值(类型为jmethodID) 生成Java类对象 首先调用JNi函数FindClass()，查找生成对象的类。 获取jmethodID值在JNI函数中有一个GetMethodID()函数用来获取指定类的指定方法ID.此函数除了可以用来获取指定类的构造方法的ID外，还可以获取类的其他方法的ID。若指定的方法是静态方法，则可以调用JNI函数中的GetStaticMethodID()函数，获取指定静态方法的ID 在生成指定类的对象之前，需要先调用GetMethodID()函数获取该类构造方法的ID。在调用GetMethodID()函数时，除了提供生成对象的类，还要提供类的构造方法名称(类的构造方法名称为“&lt;init&gt;”，其他非构造方法，直接提供方法名即可)，以及构造方法的签名。 GetMethodID() 形式:jmethodID GetMethodID(JNIEnv *env,jclass clazz,const char *name,const char *signature) 说明:获取clazz类对象的指定方法的ID。注意,方法名(name)与签名应当保持一致。若获取类构造方法的ID,方法名为”&lt;init&gt;“ 参数: env JNI接口指针 clazz Java类 name 方法名 signature 方法签名 返回值若方法ID错误，则返回NULL 生成Java类对象以获得的JniTest类的jclass与构造方法的ID为参数，调用JNI函数NewObject()，生成JniTest类的对象。JniTest类的构造方法JniTest(int num)带有一个int类型的参数，在调用NewObject()时,同时传入100这个int数据。在生成JniTest类的对象后，将对象的引用保存在jobject变量中。 NewObject() 形式:jobject NewObject(JNIEnv *env,jclass clazz,jmethodID methodID,...) 说明:生成指定类的对象。methodID指类的构造方法的ID 参数: env JNI接口指针 clazz Java类 methodID 类的构造方法的ID … 传递给类的构造方法的参数 返回值放回类对象的引用。若发生错误，返回NULL 调用Java方法步骤: 获取含待调方法的Java类的jclass 获取待调方法的ID 调用Java方法保存返回值 CallStatic&lt;type&gt;Method() 形式:&lt;jnitype&gt; CallStatic&lt;type&gt;Method(JNIEnv *env,jclass clazz,jmethodID methodID,...) 说明:调用methodID指定的类的静态方法 参数: env JNI接口指针 clazz 含待调方法的类 methodID 待调方法的ID … 传递给待调方法的参数 返回值:被调方法的返回值 参考:&lt;type&gt;指Object、Boolean、Byte、Char、Short、Int、Long、Float、Double、void十种基本类型。返回类型&lt;jnitype&gt;指jobject、jboolean、jbyte、jchar、jshort、jint、jlong、jfloat、jdouble、void十基本类型待调方法的返回值不同&lt;type&gt;也不同。若待调方法的返回值类型为int，则调用函数为CallStaticIntMethod() Call&lt;type&gt;Method() 形式:&lt;jnitype&gt; Call&lt;type&gt;Mrthod(JNIEnv *env,jobject obj,jmethodID method,...) 说明:调用methodID指定的Java对象的方法 参数: env JNI接口指针 obj 含待调方法的Java对象的方法 methodID 待调方法的ID … 传递给待调方法的参数 返回值:被调方法的返回值 设置成员变量的值步骤: 获取成员变量所在类的jclass值 获取对象的变量值 设置变量值 SetStatic&lt;type&gt;Field() 形式:void SetStatic&lt;type&gt;Field(JNIEnv *env,jclass clazz,jfieldID field,&lt;type&gt; value) 说明:设置fieldID指定的Java类静态成员变量的值 参数: env JNI接口指针 clazz 含待设置成员变量的类的引用 fieldID 待设成员变量的ID value 指定设置值 Set&lt;type&gt;Field() 形式void Set&lt;type&gt;Field(JNIEnv *env,jobject obj,jfieldID field,&lt;type&gt; value) 说明:设置fieldID指定的Java对象的成员变量的值 参数: env JNI接口指针 obj 含待设置成员变量的Java对象的引用 fieldID 待设成员变量的ID value 指定设置值 局部引用与全局引用在实现JNI本地函数时，由GetObjectClass()、FindClass()等JNI函数返回的jclass、jobject等引用都是局部引用。 局部引用是JNI默认的，它仅在JNI本地函数内才有效,即当JNI本地函数返回后,其内部的引用就会失效。 JNI提供了一个名称为NewGlobalRef()的JNI函数，用来为指定的类或对象生成全局引用(Global Reference),以便在JNI本地函数中在全局范围内使用该引用 NewGlobalRef() 形式:jobject NewGlobalRef(JNIEnv *env,jobject obj) 说明:为obj指定的类或对象，生成全局引用 参数: env JNI接口指针 obj 待生成全局引用的引用值 返回生成的全局引用,若发生错误,则返回NULL 当全局引用使用完毕后，应当调用名称为DeleteGlobalRef()的JNI函数,显性地将全局引用销毁。 例子 #include \"RefTestMain.h\" static jclass globalTargetClass = 0; JNIEXPORT jint JNICALL Java_RefTestMain_getMember(JNIEnv *env,jclass clazz) { jfieldID fid; jint intField; jclass targetClass; if(globalTargetClass == 0) { targetClass = env->FindClass(\"RefTest\"); globalTargetClass =(jclass) env->NewGlobalRef(targetClass); } fid = env->GetStaticFieldID(globalTargetClass,\"intField\",\"I\"); intField = env->GetStaticIntField(globalTargetClass,fid); return intField; } 参考资料Amdroid框架揭秘","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"JNI","slug":"JNI","permalink":"https://luoweiguang.github.io/tags/JNI/"},{"name":"Java进阶","slug":"Java进阶","permalink":"https://luoweiguang.github.io/tags/Java进阶/"}]},{"title":"JNI(在Java中调用C函数)","slug":"JNI(在Java中调用C函数)","date":"2016-09-26T14:00:00.000Z","updated":"2017-11-14T16:16:46.056Z","comments":true,"path":"2016/09/26/JNI(在Java中调用C函数)/","link":"","permalink":"https://luoweiguang.github.io/2016/09/26/JNI(在Java中调用C函数)/","excerpt":"JNI调用C函数的步骤\n编写Java代码\n编译Java代码\n生成C语言头文件\n编写C代码\n生成C共享库\n运行Java程序\n","text":"JNI调用C函数的步骤 编写Java代码 编译Java代码 生成C语言头文件 编写C代码 生成C共享库 运行Java程序 编写Java代码package com.jni; public class HelloJNI { //本地方法声明 native void printHello(); native void printString(String str); //加载库 static { System.loadLibrary(\"hellojni\"); } public static void main(String[] args) { HelloJNI myJNI = new HelloJNI(); //调用本地方法(实际调用的是使用C语言编写的JNI本地函数) myJNI.printHello(); myJNI.printString(\"Hello World from printString fun\"); } } 在Java类中，使用“native”关键字，声明本地方法，该方法与用C/C++编写的JNI本地函数相对应。 “native”关键字告知Java编译器，在Java代码中带有该关键字的方法只是声明，具体由C/C++等其他语言编写实现 在Java中加载本地运行库时通常使用“静态块”。如果本地库未被正常加载，在使用本地方法调用本地库的C函数时，就会发生错误 编译Java代码javac &lt;文件路径&gt; 例如: javac HelloJNI.java 生成C语言头文件javah &lt;包含以native关键字声明的方法的Java类名称&gt; 例如: javah HelloJNI HelloJNI.h /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class HelloJNI */ #ifndef _Included_HelloJNI #define _Included_HelloJNI #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: HelloJNI * Method: printHello * Signature: ()V */ JNIEXPORT void JNICALL Java_HelloJNI_printHello (JNIEnv *, jobject); /* * Class: HelloJNI * Method: printString * Signature: (Ljava/lang/String;)V */ JNIEXPORT void JNICALL Java_HelloJNI_printString (JNIEnv *, jobject, jstring); #ifdef __cplusplus } #endif #endif 编写C代码c文件中对应的方法名为生成的C语言头文件中对应的函数原型hellojni.c #include \"HelloJNI.h\" #include &lt;stdio.h> JNIEXPORT void JNICALL Java_HelloJNI_printHello(JNIEnv *env, jobject obj) { printf(\"Hello World!\\n\"); return; } JNIEXPORT void JNICALL Java_HelloJNI_printString(JNIEnv *env, jobject obj, jstring string) { //GetStringUTFChars()是JNI函数，用来将Java字符串转成C语言字符串 const char *str = (*env)->GetStringUTFChars(env,string,0); printf(\"%s\\n\", str); return; } 生成C共享库gcc -shared -o &lt;库的路径&gt; &lt;c文件路径&gt; gcc -shared -o hellojni.dll hellojni.c 注意事项 In file included from hellojni.c:1:com_jni_HelloJNI.h:2:17: jni.h: No such file or directory复制JDK目录以下的这三个文件至编译器的include文件夹下 jdk\\include\\jni.h jdk\\include\\win32\\jawt_md.h jdk\\include\\win32\\jni_md.h Exception in thread “main” java.lang.UnsatisfiedLinkError: H:\\hellojni.dll: Can’t load IA 32-bit .dll on a AMD 64-bit platform编译的版本应该与系统版本一致，64位的应使用64位的编译 运行Java程序java &lt;类名&gt; java HelloJNI 运行结果 Hello World! Hello World from printString fun 参考资料Amdroid框架揭秘","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"JNI","slug":"JNI","permalink":"https://luoweiguang.github.io/tags/JNI/"},{"name":"Java进阶","slug":"Java进阶","permalink":"https://luoweiguang.github.io/tags/Java进阶/"}]},{"title":"init进程","slug":"init进程","date":"2016-09-25T14:00:00.000Z","updated":"2017-11-14T16:45:39.643Z","comments":true,"path":"2016/09/25/init进程/","link":"","permalink":"https://luoweiguang.github.io/2016/09/25/init进程/","excerpt":"本篇基于android2.2.3\ninit进程是Android启动后，由内核启动的第一份用户级进程。","text":"本篇基于android2.2.3 init进程是Android启动后，由内核启动的第一份用户级进程。 内核启动过程init进程是在顺序执行完start_kernel()函数，init_post()函数，run_init_process()函数后，最后启动执行的 init/main.c static noinline int init_post(void) { if (execute_command) { run_init_process(execute_command); } run_init_process(\"/sbin/init\"); run_init_process(\"/etc/init\"); run_init_process(\"/bin/init\"); run_init_process(\"/bin/sh\"); ... } init_post()函数调用run_init_process()函数，获取注册在exxecute_command中的进程文件路径，执行execve()系统调用。execve()函数执行由参数传递过来的文件路径下的进程。 init执行init/init.c 1.init进程注册信号处理器(即指定信号对应的处理函数)(2.3版本后没有这步) act.sa_handler = sigchld_handler; act.sa_flags = SA_NOCLDSTOP; act.sa_mask = 0; act.sa_restorer = NULL; sigaction(SIGCHLD, &amp;act, 0); 2.对umask进行清零（umask设置了用户创建文件的默认权限） umask命令允许你设定文件创建时的缺省模式，对应每一类用户(文件属主、同组用户、其他用户)存在一个相应的umask值中的数字。对于文件来说，这一数字的最大值分别是6。系统不允许你在创建一个文本文件时就赋予它执行权限，必须在创建后用chmod命令增加这一权限。目录则允许设置执行权限，这样针对目录来说，umask中各个数字最大可以到7。 umask(0); 3.创建linux中根文件系统的目录，并挂载分区 mkdir(\"/dev\", 0755); mkdir(\"/proc\", 0755); mkdir(\"/sys\", 0755); mount(\"tmpfs\", \"/dev\", \"tmpfs\", 0, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); mount(\"proc\", \"/proc\", \"proc\", 0, NULL); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL); 4.生成/dev/_null_节点文件，标准输入，标准输出，标准错误文件描述符重定向到_null_ open_devnull_stdio(); 5.生成/dev/_kmsg_节点文件记录log log_init(); 6.解析init.rc文件(init.rc文件在Android系统运行过程中用于通用的环境设置及与进程相关的定义) parse_config_file(\"/init.rc\"); 7.初始化QEMU设备，设置模拟器环境(2.3版本后没有这步) qemu_init(); 8.从”/proc/cmdline”中读取内核命令行参数，并在读取完后修改此文件的权限，禁止非授权用户操作此文件 import_kernel_cmdline(0); 9.从”/proc/cpuinfo”中读取系统的CPU硬件信息。 get_hardware_name(); 10.根据读取的硬件信息来解析特定于硬件的配置信息 snprintf(tmp, sizeof(tmp), \"/init.%s.rc\", hardware); parse_config_file(tmp); 11.触发在init脚本文件中名字为early-init的action，并且执行其commands，其实是: on early-init action_for_each_trigger(\"early-init\", action_add_queue_tail); drain_action_queue(); 12.初始化动态设备管理，设备文件有变化时反应给内核 device_fd = device_init(); 13.加载启动动画，如果动画打开失败，则在屏幕上打印： A N D R O I D字样。 if( load_565rle_image(INIT_IMAGE_FILE) ) { fd = open(\"/dev/tty0\", O_WRONLY); if (fd >= 0) { const char *msg; msg = \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \"\\n\" \" A N D R O I D \"; write(fd, msg, strlen(msg)); close(fd); } } 14.触发在init脚本文件中名字为init的action，并且执行其commands，其实是：on init action_for_each_trigger(\"init\", action_add_queue_tail); drain_action_queue(); 15.启动系统属性服务： system property service property_set_fd = start_property_service(); 16.创建socket用来处理进程信号 if (socketpair(AF_UNIX, SOCK_STREAM, 0, s) == 0) { signal_fd = s[0]; signal_recv_fd = s[1]; fcntl(s[0], F_SETFD, FD_CLOEXEC); fcntl(s[0], F_SETFL, O_NONBLOCK); fcntl(s[1], F_SETFD, FD_CLOEXEC); fcntl(s[1], F_SETFL, O_NONBLOCK); } 17.触发在init脚本文件中名字为early-boot和boot的action，并且执行其commands action_for_each_trigger(\"early-boot\", action_add_queue_tail); action_for_each_trigger(\"boot\", action_add_queue_tail); drain_action_queue(); 18.启动所有属性变化触发命令，其实是： on property:ro.xx.xx=xx queue_all_property_triggers(); drain_action_queue(); 19.事件处理循环 for(;;) { int nr, i, timeout = -1; for (i = 0; i &lt; fd_count; i++) ufds[i].revents = 0; drain_action_queue(); restart_processes(); if (process_needs_restart) { timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; } 分析及运行init.rc文件分析init.rc文件动作列表用于创建所需目录，以及为某些特定文件指定权限。 服务列表用于记录初始化程序需要启动的一些程序 Android init脚本语言的规范Android初始化语言包含了四种类型的声明： Actions（动作） Commands（命令） Services（服务） Options（选项） 初始化语言以行为单位，以空格间隔的语言符号组成。 C风格的反斜杠转义符可以用来在语言符号中插入空格。 双引号也可以用来防止文本被空格分成多个语言符号。 当反斜杠在行末时，作为折行符。 以#开始的行为注释行 Actions和Service隐含声明一个新的段落，所有该段落下的Command与Option的声明皆属于该段落 Actions和Service的名称是唯一的。在它们之后声明相同命名的类将被视为无效 Actions（行为）Actions其实就是一系列的Commands（命令）。Actions都有一个trigger（触发器），它被用于决定action的执行时间。当一个符合action触发条件的事件发生时，action会被加入到执行队列的末尾，除非它已经在队列里了。队列中的每一个action都被依次提取出，而这个action中的每个command（命令）都将被依次执行。Actions的形式如下： on &lt;trigger> &lt;command1> &lt;command2> &lt;command3> on后面跟着一个触发器，当trigger被触发时，command1，command2，command3，会依次执行，直到下一个Action或下一个Service。简单来说，Actions就是Android在启动时定义的一个启动脚本，当条件满足时，会执行该脚本，脚本里都是一些命令commands，不同的脚本用on来区分。 Triggers（触发器）Triggers（触发器）是一个用于匹配特定事件类型的字符串，用于使Actions发生。 boot当init程序执行，并载入/init.conf文件时触发. &lt;name&gt;=&lt;value&gt;当改变属性值时触发 device-added-&lt;path&gt;当添加设备时触发. device-removed-&lt;path&gt;当设备移除时触发. service-exited-&lt;name&gt;当指定的服务退出时触发. Services（服务）Services（服务）是一个程序，它在初始化时启动，并在退出时可选择让其重启。Services（服务）的形式如下： service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... name:服务名 pathname:当前服务对应的程序位置 option：当前服务设置的选项 Options（选项）Options（选项）是一个Services（服务）的修饰。他们影响Services（服务）在何时，并以何种方式运行。 critical据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。 disabled服务不会自动运行，必须按照名称明确指定后才可以启动 setenv &lt;name&gt; &lt;value&gt;设置环境变量 socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; ] ]在/dev/socket/下创建一个unix domain的socket，并传递创建的文件描述符fd给服务进程.其中type必须为dgram或stream,seqpacket.用户名和组名默认为0 user &lt;username&gt;在执行此服务之前先切换用户名。当前默认为root. group &lt;groupname&gt; [ &lt;groupname&gt; ]*类似于user,切换组名，默认组名为root oneshot当此服务退出时不会自动重启. class &lt;name&gt;给服务指定一个类属,这样方便操作多个服务同时启动或停止.默认情况下为default. onrestart当服务重启时执行一条指令， Commands（命令） exec &lt;path&gt; [ &lt;argument&gt; ]*fork并执行指定路径下的程序，并传递参数.这将阻塞init进程直到程序执行完毕 export &lt;name&gt; &lt;value&gt;设置全局环境参数，此参数被设置后对所有进程都有效. ifup &lt;interface&gt;使指定的网络接口”上线”,相当激活指定的网络接口 import &lt;filename&gt;导入一个额外的init配置文件. hostname &lt;name&gt;设置主机名 chdir &lt;directory&gt;改变工作目录. chmod &lt;octal-mode&gt; &lt;path&gt;改变指定文件的读取权限. chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;改变指定文件的拥有都和组名的属性. chroot &lt;directory&gt;改变进行的根目录. class_start &lt;serviceclass&gt;启动所有指定服务类下的未运行服务 class_stop &lt;serviceclass&gt;停止指定服务类下的所有已运行的服务 domainname &lt;name&gt;设置域名 insmod &lt;path&gt;安装指定路径的模块. mkdir &lt;path&gt; [mode] [owner] [group]用指定参数创建一个目录，在默认情况下，创建的目录读取权限为755.用户名为root,组名为root. mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;mountoption&gt; ]* 类似于linux的mount(挂载)指令 setkeyTBD(To Be Determined),待定. setprop &lt;name&gt; &lt;value&gt;设置属性及对应的值. setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;设置资源的rlimit(资源限制） start &lt;service&gt;如果指定的服务未启动，则启动它. stop &lt;service&gt;如果指定的服务当前正在运行，则停止它. symlink &lt;target&gt; &lt;path&gt;创建一个符号链接. sysclktz &lt;mins_west_of_gmt&gt;设置系统基准时间. trigger &lt;event&gt;触发一个事件。用于将一个action与另一个 action排列 write &lt;path&gt; &lt;string&gt; [ &lt;string&gt; ]*往指定的文件写字符串. Properties（属性）Init更新一些系统属性以提供对正在发生的事件的监控能力: init.action当前正在执行的动作，如果没有则为空字符串”” init.command当前正在执行的命令.没有则为空字符串. init.svc.&lt;name&gt;当前某个服务的状态，可为”stopped”, “running”, “restarting” init.rc文件分析函数init/main.c调用parse_config_file(const char *fn)函数来分析init.rc脚本文件 int parse_config_file(const char *fn) { char *data; data = read_file(fn, 0);//读取文件 if (!data) return -1; parse_config(fn, data);//分析读入的字符串 DUMP(); return 0; } parse_config()函数会分析read_file()函数返回的字符串，并生成动作列表(Action List)与服务列表(Service List) static void parse_config(const char *fn, char *s) { ... for (;;) { switch (next_token(&amp;state)) {//以行为单位分割参数传递过来的字符串 ... case T_NEWLINE: if (nargs) { int kw = lookup_keyword(args[0]);//返回init.rc脚本中每行首个单词在keyword_list结构体数组中的数组编号 if (kw_is(kw, SECTION)) {//判断是否为SECTION state.parse_line(&amp;state, 0, 0); parse_new_section(&amp;state, kw, nargs, args); } else { state.parse_line(&amp;state, nargs, args); } nargs = 0; } break; ... } } } KEYWORD宏转换为keyword_info结构体数组形成的列表，其形式为:【“列表编号”】={“关键字”，“组”，“参数个数”，“映射函数”} parse_new_section()函数将kw_is()宏筛选出的命令，分别注册动动作列表或服务列表中。在parse_new_section()函数会将服务列表与动作列表分别保存到全局变量service_list与action_list中 执行early-init动作列表Android 中的ueventd是一个守护进程，主要作用是接收uevent来创建或删除/dev/xxx(设备节点) 执行init动作列表在“on init”根文件系统挂载部分，主要挂载/system与/data两个目录。两个目录挂载完毕后，Android的根文件系统就准备好了 动作列表的运行void drain_action_queue(void) { struct listnode *node; struct command *cmd; struct action *act; int ret; while ((act = action_remove_queue_head())) { INFO(\"processing action %p (%s)\\n\", act, act->name); list_for_each(node, &amp;act->commands) { cmd = node_to_item(node, struct command, clist);//从action_queue中取出动作列表，并转换成command结构体 ret = cmd->func(cmd->nargs, cmd->args); INFO(\"command '%s' r=%d\\n\", cmd->args[0], ret); } } } action_remove_queue_head()函数用来获取全局链表action_queue的head,action_queue保存有由待执行的命令构成的动作列表 command结构体的func变量指定与动作列表中的命令相对应的函数，即各命令的映射函数 服务列表的运行on boot段落中，最后一行命令为class_start，init进程通过该命令运行“service”段落中的所有程序。class_start命令对应的执行函数为do_class_start() int do_class_start(int nargs, char **args) { service_for_each_class(args[1], service_start_if_not_disabled); return 0; } do_class_start调用service_for_each_class void service_for_each_class(const char *classname, void (*func)(struct service *svc)) { struct listnode *node; struct service *svc; list_for_each(node, &amp;service_list) { // 遍历service的结构体 svc = node_to_item(node, struct service, slist); // 从slist里取出每一个结构体 if (!strcmp(svc->classname, classname)) { // 如果名字是匹配的话，就会进入这个判断 func(svc); // 执行service_start_if_not_disable, 并且将当前的service结构体给传递进去 } } } service_for_each_class()会遍历service_list链表，找到所有和classname匹配的service节点，如果这个节点没有被disabled的话，那么就启动其对应的服务 service_start_if_not_disabled static void service_start_if_not_disabled(struct service *svc) { if (!(svc->flags &amp; SVC_DISABLED)) { service_start(svc, NULL); } } service_start void service_start(struct service *svc, const char *dynamic_args) { struct stat s; pid_t pid; int needs_console; int n; // 这个service即将被启动，将其从disable或reset的状态给移除掉，置其为重新运行的状态 svc->flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING)); svc->time_started = 0; // 如果这个service仍然是运行态的话，即return if (svc->flags &amp; SVC_RUNNING) { return; } needs_console = (svc->flags &amp; SVC_CONSOLE) ? 1 : 0; if (needs_console &amp;&amp; (!have_console)) { ERROR(\"service '%s' requires console\\n\", svc->name); svc->flags |= SVC_DISABLED; return; } // 如果这个service的flags是初始console，但是这个已经启动了的话，就会设置当前的flags为disabled if (stat(svc->args[0], &amp;s) != 0) {// 如果要执行的这个service的start的command不存在的话，返回error ERROR(\"cannot find '%s', disabling '%s'\\n\", svc->args[0], svc->name); svc->flags |= SVC_DISABLED; return; } ... NOTICE(\"starting '%s'\\n\", svc->name); // fork一个子进程，即所有从init.rc启动的service，都是一个子进程 pid = fork(); if (pid == 0) { // pid = 0, 进入到子进程中 struct socketinfo *si; struct svcenvinfo *ei; char tmp[32]; int fd, sz; // 得到属性存储空间的信息并加入到环境变量中 get_property_workspace(&amp;fd, &amp;sz); sprintf(tmp, \"%d,%d\", dup(fd), sz); add_environment(\"ANDROID_PROPERTY_WORKSPACE\", tmp); // 将service自己声明的envvars加入到环境变量中 for (ei = svc->envvars; ei; ei = ei->next) add_environment(ei->name, ei->value); // 根据socket info设置socket for (si = svc->sockets; si; si = si->next) { int s = create_socket(si->name, !strcmp(si->type, \"dgram\") ? SOCK_DGRAM : SOCK_STREAM, si->perm, si->uid, si->gid); if (s >= 0) { publish_socket(si->name, s); } } if (svc->ioprio_class != IoSchedClass_NONE) { if (android_set_ioprio(getpid(), svc->ioprio_class, svc->ioprio_pri)) { ERROR(\"Failed to set pid %d ioprio = %d,%d: %s\\n\", getpid(), svc->ioprio_class, svc->ioprio_pri, strerror(errno)); } } if (needs_console) { setsid(); open_console(); } else { zap_stdio(); } #if 0 for (n = 0; svc->args[n]; n++) { INFO(\"args[%d] = '%s'\\n\", n, svc->args[n]); } for (n = 0; ENV[n]; n++) { INFO(\"env[%d] = '%s'\\n\", n, ENV[n]); } #endif setpgid(0, getpid()); if (svc->gid) { // 设置gid setgid(svc->gid); } if (svc->nr_supp_gids) { setgroups(svc->nr_supp_gids, svc->supp_gids); } if (svc->uid) { // 设置uid setuid(svc->uid); } // 因为dynamic_args设置的为null，我们在第一次从init.rc启动的时候，一定会进入到这个判断。 if (!dynamic_args) { //执行当前的service的启动的命令，也就是说从这边开始，我们就可以理解为已经从init进程中，去像kernel执行init一样，就去执行各个service所对应的启动函数了！ if (execve(svc->args[0], (char**) svc->args, (char**) ENV) &lt; 0) { ERROR(\"cannot execve('%s'): %s\\n\", svc->args[0], strerror(errno)); } } else { char *arg_ptrs[INIT_PARSER_MAXARGS+1]; int arg_idx = svc->nargs; char *tmp = strdup(dynamic_args); char *next = tmp; char *bword; ... } ... } 生成设备驱动节点init进程通过两种方式创建设备节点。第一种，以预先定义的设备信息为基础，当init进程被启动运行时，同一创建设备节点文件，这种连接已定义的设备的方法，称为“冷拔插”，第二种，在系统运行时，当有设备插入USB端口时，init经常就会接收到这一事件，为插入的设备动态创建设备节点文件，这种在系统运行的状态下连接设备，称为“热拔插” 从内核2.6X开始引入udev(userspace device)实用程序。udev以守护进程的形式运行，当设备驱动被加载时，它会掌握主设备号，次设备号，以及设备类型，而后在“/dev”目录下自动创建设备节点文件 在系统运行中，若某个设备被插入，内核就会加载与该设备相关的驱动程序。而后驱动程序会调用启动函数probe()，将主设备号，次设备号，以及设备类型保存到“/sys”文件系统中。然后发出uevent，并传递给udev守护进程 uevent是内核向用户空间进程传递信息的信号系统，即在添加或删除设备时，内核使用uevent将设备信息传递给用户空间。uevent包含设备名称、类别、主设备号、次设备号、设备节点文件创建的目录等信息，并将这些信息传递给udev守护进程 系统内核启动后，udev进程运行在用户空间内，它无法处理内核启动过程中发生的uevent。虽然内核空间内的设备驱动程序可以正常运行，但由于未创建访问设备驱动所需的设备节点文件，将会出现应用程序无法使用相关设备的问题。 Linuxx系统中，在udec守护经常运行前，通过提供与加载的设备驱动程序冷拔插机制，来解决设备节点文件没被创建的问题。 当内核启动后，冷拔插机制启动udev守护进程，从/sys目录下读取事先注册好的设备信息，而后引发与各设备相对应的uevent,创建设备节点文件。Android也采用这种处理方式来创建设备节点文件，不同的是使用init进程来扮演udev守护进程的角色。 创建静态设备节点内核启动完毕后，init进程启动，对于像Binder驱动程序这样无法创建设备节点文件的驱动，将采用冷拔插方式进行处理。init进程事先获知等待冷拔插处理的驱动程序，并事先定义好各驱动程序的设备节点文件。在Android源代码的devices.c文件中，列出了init进程创建的节点文件的目录。 static struct perms_ devperms[] = { 87 { \"/dev/null\", 0666, AID_ROOT, AID_ROOT, 0 }, 88 { \"/dev/zero\", 0666, AID_ROOT, AID_ROOT, 0 }, 89 { \"/dev/full\", 0666, AID_ROOT, AID_ROOT, 0 }, 90 { \"/dev/ptmx\", 0666, AID_ROOT, AID_ROOT, 0 }, 91 { \"/dev/tty\", 0666, AID_ROOT, AID_ROOT, 0 }, ... } 在冷拔插处理时，init进程会引起devperms结构体，在/dev 目录下创建设备节点文件。devperms结构体中，分别列出了等待冷拔插处理的设备节点文件的名称、访问权限、用户ID、组ID。若想为用户定义的新设备创建设备节点文件，需要将相关驱动信息添加到devperms结构体中。 init经常进行冷拔插处理的步骤。init进程调用device_init()函数 int device_init(void) { ... fd = open_uevent_socket(); ... t0 = get_usecs(); coldboot(fd, \"/sys/class\"); coldboot(fd, \"/sys/block\"); coldboot(fd, \"/sys/devices\"); t1 = get_usecs(); log_event_print(\"coldboot %ld uS\\n\", ((long) (t1 - t0))); ... } deviice_init()函数先创建一个套接字，用来接收uevenr。再通过coldboot()函数调用do_coldboot()函数，对内核启动时注册到/sys，目录下的驱动程序，进行冷拔插处理。do_coldboot static void do_coldboot(int event_fd, DIR *d) { ... fd = openat(dfd, \"uevent\", O_WRONLY); if(fd >= 0) { write(fd, \"add\\n\", 4); close(fd); handle_device_fd(event_fd); } ... } do_coldboot()函数接收参数传递过来的目录路径，通过该路径查找到保存的uevent文件，向相关文件写入“add”信息，而后强制引起uevent。然后在handler_ddevice_fd()函数中接收相关的uevent，获取uevent的信息 handle_device_fd void handle_device_fd(int fd) { for(;;) { ... struct uevent uevent; parse_event(msg, &amp;uevent); handle_device_event(&amp;uevent); ... } } handle_device_fd()函数在收到uevent时，调用parse_event()函数，将uevent信息希尔uevent结构体。uevent struct uevent { const char *action; const char *path; const char *subsystem; const char *firmware; int major; int minor; }; 向uevent结构体写完信息后，调用handle_device_event()函数，创建节点文件。 handle_device_event static void handle_device_event(struct uevent *uevent) { ... if(!strncmp(uevent->subsystem, \"block\", 5)) { block = 1; base = \"/dev/block/\"; mkdir(base, 0755); } ... if(!strcmp(uevent->action, \"add\")) { make_device(devpath, block, uevent->major, uevent->minor); return; } ... } handle_device_event()先检查uevent结构体的subsystem变量，而后在/dev目录下创建子目录。subsystem根据硬件用途的不同而表示不同的组。若硬件是存储设备，则subsystem是block，创建的目录为/dev/block。 在创建完所有下层目录后，调用make_device()函数，创建设备节点文件 make_device() static void make_device(const char *path, int block, int major, int minor) 301{ ... mode = get_device_perm(path, &amp;uid, &amp;gid) | (block ? S_IFBLK : S_IFCHR); dev = (major &lt;&lt; 8) | minor; setegid(gid); mknod(path, mode, dev); chown(path, uid, -1); setegid(AID_ROOT); } make_device（）函数从设备节点文件列表中获取用户ID、组ID信息。而后调用mknod函数，创建设备节点文件。 创建动态设备节点init经常支持热拔插处理，在系统运行中为新的设备创建节点文件。热插拔由init进程的事件处理循环来完成init.c int main(int argc, char **argv) { for(;;) { ... nr = poll(ufds, fd_count, timeout); ... if (ufds[0].revents == POLLIN) handle_device_fd(device_fd); ... } } init经常的事件处理循环循环调用poll()函数监听来自驱动程序的uevent，而后调用handle_device_fd()函数，创建设备节点文件。 处理子进程终止若init启动的某个进程终止，则会对系统的运行产生影响。比如“服务管理器”，它是应用程序使用系统服务必须运行的进程。如果该进程出现意外终止，那么进程间的通讯、图像输出、音频输出等功能将无法使用。因此，在init启动的进程中，除了一小部分外，其他大部分进程出现意外终止时，init进程要重新启动它们。 当init的子进程意外终止时，会向父进程init进程传递SIGCHLD信号，init进程接收该信号，检查进程选项是否设置为oneshot,若设置oneshot，init进程将放弃重启进程，否则重启进程。 init进程中的事件处理循环，当其子进程终止时，init会接收传递过来的SIGCHLD信号，并调用与之相对应的处理函数sigchld_handler() static void sigchld_handler(int s) { write(signal_fd, &amp;s, 1); } signal_fd记录信号标号，由套接字对创建，信号编号被传递至接收端套接字描述符signal_recv_fd中。由于接收信号编号的signal_recv_fd已被注册至POLL,wait_for_one_process()就会被调用执行 ... for(;;) { ... //当发生SIGCHLD信号时，程序就会从事件监听状态中跳出，而后执行poll()函数 nr = poll(ufds, fd_count, timeout); if(nr &lt;= 0) continue; if (ufds[2].revents == POLLIN) { read(signal_recv_fd, tmp, sizeof(tmp)); while (!wait_for_one_process(0)); continue; } ... } ... 当ufds[2]被注册进数据，即触发数据输出事件时，signal_recv_fd即调用并执行wait_for_one_process()函数。wait_for_one_process()函数在产生SIGCHLD信号的进程的服务列表中，检查进程的设置选项。若选项非oneshot，则添加重启选项(SVC_RESTARTING).oneshot选项被定义在init.rc文件的service部分中，若进程带有oneshot选项。进程终止时不会被重启 wait_for_one_process static int wait_for_one_process(int block) { ... while ( (pid = waitpid(-1, &amp;status, block ? 0 : WNOHANG)) == -1 &amp;&amp; errno == EINTR ); ... svc = service_find_by_pid(pid); ... if (!(svc->flags &amp; SVC_ONESHOT)) { kill(-pid, SIGKILL); ... } //删除进程持有的所有socketDescriptor for (si = svc->sockets; si; si = si->next) { ... unlink(tmp); } //删除SVC_RUNNING svc->pid = 0; svc->flags &amp;= (~SVC_RUNNING); //将已设置进程标记为SVC_DISABLED，并从wait_for_one_process()函数中跳出，相关进程将不被重新启动 if (svc->flags &amp; SVC_ONESHOT) { svc->flags |= SVC_DISABLED; } if (svc->flags &amp; SVC_DISABLED) { notify_service_state(svc->name, \"stopped\"); return 0; } ... //向当前服务项的标记中添加SVC_RESTART。 svc->flags |= SVC_RESTARTING; //检查待重启的进程在init.rc文件中是否带有onrestart选项 list_for_each(node, &amp;svc->onrestart.commands) { cmd = node_to_item(node, struct command, clist); cmd->func(cmd->nargs, cmd->args); } ... } 当产生信号的进程被终止时，waitpid()函数用来回收进程所占用的资源，它带有三个参数。其中，第一个参数pid为欲等待的子进程的识别码，设置为-1,表示查看所有子进程是否发出SIGCHLD信号,第二个参数status,用于返回子进程的结束状态，第三个参数决定waitpid()函数是否应用阻塞处理方式。waitpid()函数返回pid值，返回值即是产生SIGCHLD信号的进程的pid号 service_find_by_pid()函数用来取出与服务列表中终止经常相关的服务项目 在取出的服务项目选项中，检查SVC_ONESHOT是否已设置。SVC_ONESHOT表示经常仅运行一次，带有此选项的进程在运行一次后，不会被重新启动，由kill(-pid,SIGKILL)函数终止 当wait_for_one_process()函数 执行完毕后，事件处理循环中的restart_process()函数就会被调用执行。 static void restart_processes() { process_needs_restart = 0; service_for_each_flags(SVC_RESTARTING,restart_service_if_needed); } restart_processes()函数运行服务列表中带有SVC_RESTART标记的进程。当一个带有此标记的进程被终止，产生SIGCHLD信号时，restart_processes()函数将重新启动它。 属性服务属性变更请求是init事件处理循环处理的另一个事件。在Android平台中，为了让运行中的所有进程共享系统运行时所需要的各种设置值，系统开辟了属性存储区域，并提供了访问该区域的API.属性由键与值构造，其表现形式为“键=值” 在Android平台中，访问属性值时，添加了访问权限控制，增强了访问的安全性。 系统中所有运行的进程都可以访问属性值，但仅有init进程才能修改属性值。 在其他进程修改属性值时，必须向init进程提出请求，最终由init进程负责修改属性值。在此过程中，init进程会先检查各属性的访问权限，而后再修改属性值 当属性值更改后，若定义在init.rc文件中的某个特定条件得到满足，则与此条件相匹配的动作就会发生 init经常的main()函数中，调用property_init()函数，用来初始化属性域 int main(int argc, char **argv) { ... property_init(); ... } property_init void property_init(void) { init_property_area(); load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT); } property_init()函数首先在内存中开辟一块共享区域，而后将其作用在ashmen(Android Shared Menory)。外部进程可以访问这块共享内存域，获取属性值，但它们不能通过直接访问共享内存域的方法来更改属性值。一个进程若想更改属性值，必须先向init进程提交属性变更请求，由init进程更改共享内存中的属性值 init_property_area()函数被调用执行后，所创建的属性域被初始化。 属性域的起始1024个字节作为属性域头，用来保存管理属性表所需要的一些数值。其余31616个字节空间被划分成247块，每块大小为128字节，用来保存属性值。 访问属性值使用property_get()修改属性值使用property_set() 在属性域完成初始化之后，就会从指定的文件中读取初始值，并设置为属性值init的main()函数中调用了start_property_service()函数，用来创建启动属性服务所需要的Unix域套接字，并保存套接字描述符。 int main(int argc, char **argv) { ... property_set_fd = start_property_service(); ... } start_property_service int start_property_service(void) { int fd; //读取存储在各文件中的基本设置值，将它们设置为属性值 load_properties_from_file(PROP_PATH_SYSTEM_BUILD); load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT); load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE); //读取保存在/data/property目录中的属性值 load_persistent_properties(); //创建名称为/dev/socket/property_service的Unix域套接字 fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0); if(fd &lt; 0) return -1; fcntl(fd, F_SETFD, FD_CLOEXEC); fcntl(fd, F_SETFL, O_NONBLOCK); listen(fd, 8); return fd; } /data/property目录中保存着系统运行中其他进程新生成的属性值或更改的属性值，属性的key被用作文件名，value被保存在文件中。 通过上面创建的Unix域套接字，接收到属性变更请求后，init进程就会调用handle_property_set_fd()函数 void handle_property_set_fd(int fd) { ... struct ucred cr; ... //从套接字获取SO_PEERCRED值，以便检查传递信息的进程的访问权限 if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) { close(s); ERROR(\"Unable to recieve socket options\\n\"); return; } ... switch(msg.cmd) { case PROP_MSG_SETPROP: msg.name[PROP_NAME_MAX-1] = 0; msg.value[PROP_VALUE_MAX-1] = 0; if(memcmp(msg.name,\"ctl.\",4) == 0) { //检查访问权限，仅有system server、root以及相关进程才能使用ctl消息，终止或启动进程 if (check_control_perms(msg.value, cr.uid, cr.gid)) { handle_control_message((char*) msg.name + 4, (char*) msg.value); } ... } else { if (check_perms(msg.name, cr.uid, cr.gid)) { property_set((char*) msg.name, (char*) msg.value); } ... } break; default: break; } } 在struct ucred结构体,存储着传递次那个系的进程的uid、pid与gid值。通过此结构体中的值，以及消息的类型，检查进程的访问权限。 在属性消息中，以“ctl”开头的消息并非请求更改系统属性值的消息，而是请求进程启动与终止的消息。除此之外，其他消息都被用来更改系统的属性值，check_perms()函数检查访问权限。各属性的访问权限采用Linux的uid进行区分，其定义如下property_perms struct { const char *prefix; unsigned int uid; unsigned int gid; } property_perms[] = { { \"net.rmnet0.\", AID_RADIO, 0 }, { \"net.gprs.\", AID_RADIO, 0 }, { \"net.ppp\", AID_RADIO, 0 }, { \"ril.\", AID_RADIO, 0 }, { \"gsm.\", AID_RADIO, 0 }, { \"persist.radio\", AID_RADIO, 0 }, { \"net.dns\", AID_RADIO, 0 }, { \"net.\", AID_SYSTEM, 0 }, { \"dev.\", AID_SYSTEM, 0 }, { \"runtime.\", AID_SYSTEM, 0 }, { \"hw.\", AID_SYSTEM, 0 }, { \"sys.\", AID_SYSTEM, 0 }, { \"service.\", AID_SYSTEM, 0 }, { \"wlan.\", AID_SYSTEM, 0 }, { \"dhcp.\", AID_SYSTEM, 0 }, { \"dhcp.\", AID_DHCP, 0 }, { \"vpn.\", AID_SYSTEM, 0 }, { \"vpn.\", AID_VPN, 0 }, { \"debug.\", AID_SHELL, 0 }, { \"log.\", AID_SHELL, 0 }, { \"service.adb.root\", AID_SHELL, 0 }, { \"persist.sys.\", AID_SYSTEM, 0 }, { \"persist.service.\", AID_SYSTEM, 0 }, { \"persist.security.\", AID_SYSTEM, 0 }, { NULL, 0, 0 } }; 若要在系统运行中biang属性设置，应充分考虑各属性的访问权限。 property_set()函数会接着调用property_changed()函数 int property_set(const char *name, const char *value) { ... property_changed(name, value); ... } property_changed void property_changed(const char *name, const char *value) { if (property_triggers_enabled) { queue_property_triggers(name, value); drain_action_queue(); } } 在init.rc脚本文件中，记录着某个属性改变后要采取的动作，动作执行的条件以“on property:&lt;key&gt;=&lt;value&gt;”形式给出。当某个条件相关的键值被设定后，与该条件相关的触发其就会被触发。 参考资料Amdroid框架揭秘Android init进程启动Android init进程启动Android启动流程分析(十) action的执行和service的启动","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android Framework","slug":"Android-Framework","permalink":"https://luoweiguang.github.io/tags/Android-Framework/"}]},{"title":"Android命名规范","slug":"Android命名规范","date":"2016-09-22T14:00:00.000Z","updated":"2017-11-14T16:50:08.986Z","comments":true,"path":"2016/09/22/Android命名规范/","link":"","permalink":"https://luoweiguang.github.io/2016/09/22/Android命名规范/","excerpt":"自用","text":"自用 包的分类AndroidLib存放业务无关的逻辑 activity 存放与业务无关的Activity基类 net 存放网络底层封装 cache 存放缓存数据和图片的相关处理 ui 存放自定义控件 utils 存放各种与业务无关的公共方法 主项目划分 activity 将不同模块的Activity划分到不同的包下 fragment 将不同模块的fragment划分到不同的包下 adapter 存放适配器 broadcast 存放BroadcastReceive engine 将业务相关的类都放在一起 entity 将所有实体放在一起 db SQLLite相关逻辑的封装 interfaces 真正意义上的接口,命名以I作为开头 listener 基于Listener的接口，命名以On作为开头 service 存放Service ui 存放之定义控件 utils 将所有的公共方法放在这里 base 存放一些类的通用基类 文件命名规范 类 帕斯卡(pascal)命名法:即所有单词的第一个字母大写 接口 I+帕斯卡(pascal)命名法 常量 全部大写，单词用下划线分隔 静态变量 以s开头 成员变量 以m开头 Layout命名页面类型_页面名称/模块名称_名称 页面类型 说明 activity activity的布局文件 fragment fragment的布局文件 dlg Dialog的布局文件 ppw PopupWindow的布局文件 listitem listview或recycleview的item项 include 用于include标签的页面 base 基础页面的布局文件 common 通用的布局文件 activity_login 图片命名图片类型缩写_页面名称/模块名称/common/_图片名称_状态缩写(可选)_大小(可选) 图片类型缩写 说明 ic –icon 主要用于布局和子布局的图标 bg–background 主要用于布局和子布局的背景 di–divider 主要用于分隔线，不仅包括Listview中的还包括普通布局中的线 sl–selector 主要用于某一view多种状态，listview 按钮等 cl–color 主要用于颜色值 bt–button 主要用于按钮的表示 状态缩写 说明 normal 代表普通状态 press 代表按下状态 select 代表选中状态 unselect 代表没有被选中状态 focus 代表获得焦点 unfocus 代表未获得焦点 bt_login_activity_login_press 动画命名页面名称/模块名称/common/_说明动画类型\\方向 login_activity__fade_in 字符串常量命名页面名称_控件名称_文字概述 login_activity_btn_login_text 控件ID命名控件缩写_layout文件名称_功能名称 btn_activity_login_login 常用控件缩写 控件 缩写 AppBarLayout abl AutoCompleteTextView actv Button btn CardView cv CheckBox chk CheckedTextView chktv Chronometer cmt CollapsingToolbarLayout ctl ContentLoadingProgressBar cpbar DatePicker dp EditText et FrameLayout fl FloatingActionButton fabtn GridView gv HorizontalScrollView hsv ImageButton imgbtn ImageView iv ListView lv LinearLayout ll MultiAutoCompleteTextView mactv NavigationView nv NestedScrollView nsv ProgressBar pbar RadioGroup rg RadioButton rbtn RatingBar rbar RecyclerView rcv RelativeLayout rl ScrollView scrv SearchView seav SeekBar sbar Spinner spn Switch sw TextClock tc TextView tv TimePicker tp Toolbar tbar toggleButton tbtn ZoomButton zbtn 参考资料几行代码看程序员的水平——Android文件命名规范App研发录：架构设计、Crash分析和竞品技术分析","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android开发","slug":"Android开发","permalink":"https://luoweiguang.github.io/tags/Android开发/"}]},{"title":"Serializable与Parcelable","slug":"Serializable与Parcelable","date":"2016-09-12T14:00:00.000Z","updated":"2017-11-14T17:13:14.036Z","comments":true,"path":"2016/09/12/Serializable与Parcelable/","link":"","permalink":"https://luoweiguang.github.io/2016/09/12/Serializable与Parcelable/","excerpt":"Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口","text":"Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口 SerializableSerialization（序列化）是一种将对象以一连串的字节描述的过程；反序列化deserialization是一种将这些字节重建成一个对象的过程。 序列化只能保存对象的非静态成员交量，不能保存任何的成员方法和静态的成员变量，而且串行化保存的只是变量的值，对于变量的任何修饰符都不能保存 对于某些类型的对象，其状态是瞬时的，这样的对象是无法保存其状态的。例如一个Thread对象或一个FileInputStream对象，对于这些字段，我们必须用transient关键字标明，否则编译器将报措。 另外 ，串行化可能涉及将对象存放到磁盘上或在网络上发送数据，这时候就会产生安全问题。因为数据位于Java运行环境之外，不在Java安全机制的控制之中。对于这些需要保密的字段，不应保存在永久介质中，或者不应简单地不加处理地保存下来，为了保证安全性。应该在这些字段前加上transient关键字。 如果该类有父类，则分两种情况来考虑，如果该父类已经实现了可序列化接口。则其父类的相应字段及属性的处理和该类相同；如果该类的父类没有实现可序列化接口，则该类的父类所有的字段属性将不会序列化，并且反序列化时会调用父类的默认构造函数来初始化父类的属性，而子类却不调用默认构造函数，而是直接从流中恢复属性的值。 使用java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。 对象序列化包括如下步骤 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的writeObject()方法写对象。 对象反序列化的步骤 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 通过对象输入流的readObject()方法读取对象。 serialVersionUIdserialVersionUId的详细工作机制序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。 一般来说，我们应该手动指定serialVersionUId的值，比如1L也可以让IDE根据类的结构自动生成它的hash值，这样序列化和反序列化时两者的serialVersionUID是相同的，因此可以正常进行反序列化。如果不手动指定serialVersionUID的值，反序列化时当前类有所改变，比如增加或删除了某些成员变量，那么系统就会重新计算当前类的hash值并把它赋值给serialVersionUID，这个时候当前类的serialVersionUID就和序列化中的serialVersionUID不一致，于是反序列化失败。 Parcelablepublic class User implements Parcelable { public int userId; public String userName; public boolean isMale; public Book book; //返回当前对象的内容描述，如果含有文件描述符，返回1， // 否则返回0，几乎所有情况都返回0 @Override public int describeContents() { return 0; } //将当前对象写入序列化结构中 //flags标示有两种值:0或者1.为1时标识当前对象需要作为返回值返回， //不能立即释放资源，几乎所有情况都为0 @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(this.userId); dest.writeString(this.userName); dest.writeByte(this.isMale ? (byte) 1 : (byte) 0); dest.writeParcelable(this.book, flags); } public User() { } protected User(Parcel in) { this.userId = in.readInt( ); this.userName = in.readString( ); this.isMale = in.readByte( ) != 0; //因为book是另一个可序列化对象， //所以它的反序列化过程需要传递当前线程的上下文类加载器， //否则会报找到类的错误 this.book = in.readParcelable(Book.class.getClassLoader( )); } //该静态域是必须要有的，而且名字必须是CREATOR，否则会出错 public static final Parcelable.Creator&lt;User> CREATOR = new Parcelable.Creator&lt;User>( ) { //从序列化后的对象中创建原始对象 @Override public User createFromParcel(Parcel source) { //创建返回对象 return new User(source); } //创建指定长度的原始对象数组 @Override public User[] newArray(int size) { return new User[size]; } }; } 选择 在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。 Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。 Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。 对象的持久化可以选择Json,XML,网络传输也可以选择Json，XML 参考资料Android开发艺术探索Java中的Serializable浅谈，只是浅谈Java基础学习总结——Java对象的序列化和反序列化对象序列化与反序列化（Serializable、Externalizable）Android中Parcelable接口用法","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"},{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"}]},{"title":"Notification的使用","slug":"Notification的使用","date":"2016-09-08T14:00:00.000Z","updated":"2017-11-14T17:17:19.097Z","comments":true,"path":"2016/09/08/Notification的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/09/08/Notification的使用/","excerpt":"一般步骤使用状态栏通知一般有4个步骤：\n1、  通过getSystemService()方法获取NotificationManager服务。\n2、  创建一个Notification.Builder对象，并为其设置各种属性。\n3、  对Notification.Builder对象设置各种属性和事件信息，构造一个对Notification对象。\n4、  通过NotificationManager类的notify()方法将通知发送到状态栏。","text":"一般步骤使用状态栏通知一般有4个步骤： 1、 通过getSystemService()方法获取NotificationManager服务。 2、 创建一个Notification.Builder对象，并为其设置各种属性。 3、 对Notification.Builder对象设置各种属性和事件信息，构造一个对Notification对象。 4、 通过NotificationManager类的notify()方法将通知发送到状态栏。 NotificationManagerNotificationManager ： 是状态栏通知的管理类，负责发通知、清除通知等。NotificationManager 是一个系统Service，必须通过 getSystemService()方法来获取。 NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); public void cancel (int id)取消通知 public void cancel (String tag, int id)取消通知 public void cancelAll ()取消所有通知 public void notify (int id, Notification notification)发布通知 public void notify (String tag, int id, Notification notification)发布通知 Builder对象的方法 getNotification()API小于16时使用此方法构造一个Notification对象 build ()API大于等于16时使用此方法构造一个Notification对象 addAction (int icon, CharSequence title, PendingIntent intent)(在API23过时)添加按钮 addAction (Notification.Action action)(API20)添加按钮 setAutoCancel(boolean autoCancel)设置点击通知后，状态栏自动删除通知 setCategory(String category)(API21)设置通知类别 setColor(int argb)(API21)设置颜色 setContent(RemoteViews views)设置自定义视图 setContentInfo(CharSequence info)设置信息(即右下方显示的内容) setContentIntent(PendingIntent intent)设置点击后意图，即打开哪个组件 setContentText(CharSequence text)设置内容 setContentTitle(CharSequence title)设置标题 setDefaults(int defaults)向通知添加声音、闪灯和振动效果的最简单、最一致的方式是使用当前的用户默认设置，使用defaults属性，可以组合,如：setDefaults(Notification.DEFAULT_SOUND|Notification.DEFAULT_VIBRATE) Notification.DEFAULT_VIBRATE //添加默认震动提醒 需要 VIBRATE permission Notification.DEFAULT_SOUND // 添加默认声音提醒 Notification.DEFAULT_LIGHTS// 添加默认三色灯提醒 Notification.DEFAULT_ALL// 添加默认以上3种全部提醒 setDeleteIntent(PendingIntent intent)设置删除时的意图 setExtras(Bundle extras)(API19)设置数据 setFullScreenIntent(PendingIntent intent, boolean highPriority)设置悬挂式Notification setGroup(String groupKey)(API20)设置该通知组的密匙，即确认为哪一组 setGroupSummary(boolean isGroupSummary)(API20)设置是否为一组通知的汇总 setLargeIcon(Icon icon)(API23)设置大图标 setLargeIcon(Bitmap b)设置大图标 setLights(int argb, int onMs, int offMs)设置三色灯，ledARGB 表示灯光颜色、 ledOnMS 亮持续时间、ledOffMS 暗的时间 setLocalOnly(boolean localOnly)(API20)设置该通知是否应不桥接至其它设备。 setNumber(int number)设置一个数(即右下方显示的内容) setOngoing(boolean ongoing)设置为true时就不能滑动删除 setOnlyAlertOnce(boolean onlyAlertOnce)设置仅提醒一次 setPriority(int pri)(API16)设置优先级 优先级 用户 MAX 重要而紧急的通知，通知用户这个事件是时间上紧迫的或者需要立即处理的。 HIGH 高优先级用于重要的通信内容，例如短消息或者聊天，这些都是对用户来说比较有兴趣的。 DEFAULT 默认优先级用于没有特殊优先级分类的通知。 LOW 低优先级可以通知用户但又不是很紧急的事件。 MIN 用于后台消息(例如天气或者位置信息)。最低优先级通知将只在状态栏显示图标，只有用户下拉通知抽屉才能看到内容。 setProgress(int max, int progress, boolean indeterminate)(API14)设置进度条 setPublicVersion(Notification n)设置安全锁屏下的通知 setShowWhen(boolean show)(API17)是否显示时间 setSmallIcon(int icon, int level)设置小图标 setSmallIcon(int icon)设置小图标. setSmallIcon(Icon icon)设置小图标 setSortKey(String sortKey)(API20)设置排序键 setSound(Uri sound, AudioAttributes audioAttributes)(API21)设置铃声 setSound(Uri sound)设置铃声 setSound(Uri sound, int streamType)(在API21废弃)设置铃声 setStyle(Notification.Style style)(API16)设置样式 setSubText(CharSequence text)(API16)设置第三行的文本 setTicker(CharSequence tickerText, RemoteViews views)设置显示在状态栏的提醒内容（5.0及之后没有效果） setTicker(CharSequence tickerText)设置显示在状态栏的提醒内容（5.0及之后没有效果） setUsesChronometer(boolean b)(API16)使用计时器 setVibrate(long[] pattern)设置震动，其中数组的奇数位为暂停时间，偶数位为震动时间 setVisibility(int visibility)(API21)设置可达性 VISIBILITY_PUBLIC 只有在没有锁屏时会显示通知 VISIBILITY_PRIVATE 任何情况都会显示通知 VISIBILITY_SECRET 在安全锁和没有锁屏的情况下显示通知 setWhen(long when)设置显示通知的时间，不设置默认获取系统时间，这个值会在Notification上面显示出来 如果不设置LargeIcon，那么系统会默认将上面的SmallIcon显示在通知选项的最左侧，右下角的小图标将不再显示 notification.flags参数介绍Notification.FLAG_SHOW_LIGHTS //三色灯提醒，在使用三色灯提醒时候必须加该标志符 Notification.FLAG_ONGOING_EVENT //发起正在运行事件（活动中） Notification.FLAG_INSISTENT //让声音、振动无限循环，直到用户响应 （取消或者打开） Notification.FLAG_ONLY_ALERT_ONCE //发起Notification后，铃声和震动均只执行一次 Notification.FLAG_AUTO_CANCEL //用户单击通知后自动消失 Notification.FLAG_NO_CLEAR //只有全部清除时，Notification才会清除 ，不清楚该通知(QQ的通知无法清除，就是用的这个) Notification.FLAG_FOREGROUND_SERVICE //表示正在运行的服务 PendingIntentPendingIntent是一个Intent的描述、包装，给予了这个PendingIntent 的组件在指定的事件发生或指定的时间到达时启动Activty、Service或者Broadcast。 PendingIntent contentIntent = PendingIntent.getActivity(context, requestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT); PendingIntent contentIntent = PendingIntent.getBroadcast(context, requestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT); PendingIntent contentIntent = PendingIntent.getService(context, requestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT); FLAG_ONE_SHOT当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后续还有相同的PendingIntent，那么他们的send方法就会调用失败。对于通知栏消息来说，如果采用此标记，那么同类的通知只能使用一次，后续的通知单击后将无法打开 FLAG_NO_CREATE当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity、getService、getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标记很少见，它无法单独使用，因此在日常开发中它并没有太多的使用意义 FLAG_CANCEL_CURRENT如果描述的PendingIntent已经存在，那么它们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些cancel的消息单击后将无法打开。 FLAG_UPDATE_CURRENT当前描述的PendingIntent如果已经存在，那么它们都会被更新，即它们的Intent中的Extras会被替换成最新的 上面4个flag中最经常使用的是FLAG_UPDATE_CURRENT，因为描述的Intent有 更新的时候需要用到这个flag去更新你的描述，否则组件在下次事件发生或时间到达的时候extras永远是第一次Intent的extras。使用 FLAG_CANCEL_CURRENT也能做到更新extras，只不过是先把前面的extras清除，另外FLAG_CANCEL_CURRENT和 FLAG_UPDATE_CURRENT的区别在于能否新new一个Intent，FLAG_UPDATE_CURRENT能够新new一个 Intent，而FLAG_CANCEL_CURRENT则不能，只能使用第一次的Intent。 此外还需要注意参数： int requestCode 对于FLAG_UPDATE_CURRENT,如果上面的requestCode 为常量，则对于先后出现的若干Notification,则所有对应的Intent里面的extra被更新为最新的，就是全部同一为最后一次的。相反，如果requestCode每次不一样，则里面的Inent的数据没被更新。对于FLAG_CANCEL_CURRENT,则只响应最前面的第一条Notifiacation,后面所有的不响应…. 自定义Notification实现自定义Notification的步骤 创建RemoteViews对象 Notification.Builder对象中使用setContent(RemoteViews views)方法 RemoteViewsRemoteViews表示的是一个view结构，它可以在其他进程中显示。由于它在其他进程中显示，为了能够更新它的界面，RemoteViews提供了一组基础的操作用于跨进程更新它的界面 支持类型在RemoteViews并不支持所有的View类型，支持的所有类型如下:Layout: FrameLayout, LinearLayout, RelativeLayout,GridLayout View: AnalogClock, Button, Chronometer, ImageButton, ImageView, ProgressBar, TextView, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper,ViewStub 上面说描述的RemoteViews所支持的所有的View类型，RemoteViews不支持它们的子类以及其他View类型。也就是说RemoteViews中不能使用除了上述列表中以外的View，也无法使用自定义View 常用方法 setTextViewText(int viewId,Charsequence text)设置TextView的文本 setTextViewTextSize(int viewId, int units, float size)设置TextView的字体大小 setTextColor(int viewId, int color)设置TextView的字体颜色 setImageViewResource(int viewId, int srcId)设置ImageView的图片资源 setInt(int viewId, String methodName, int value)反射调用View对象的参数类型为int的方法 setLong(int viewId, String methodName, long value)反射调用View对象的参数类型为long的方法 setBoolean(int viewId, String methodName, boolean value)反射调用View对象的参数类型为boolean的方法 setOnClickPendingIntent(int viewId, PendingIntent pendingIntent)为View添加单击事件，事件类型只能为PendingIntent 内部机制 RemoteViews的构造方法 public RemoteViews(String packageName, int layoutId)，第一个参数是当前应用的包名，第二个参数是待加载的布局文件。 RemoteViews提供了一系列的set方法完成view的设置，这是通过反射完成的调用的。例如方法setInt(int viewId, String methodName, int value)就是反射调用view对象的名称为methodName的方法，传入参数value，同样的还有setBoolean、setLong等。方法setOnClickPendingIntent(int viewId, PendingIntent pi)用来为view添加单击事件，事件类型只能为PendingIntent。 系统对View界面执行一系列的更新操作，即通过set方法提交的，但更新操作不是立即执行(在RemoteViews内部会记录所有的更新操作)，而是到RemoteViews被加载后执行 通知和小部件分别由NotificationManager和AppWidgetManager管理，而它们通过Binder分别和SystemServer进程中的NotificationManagerService和AppWidgetManagerService进行通信。所以，布局文件实际上是两个Service加载的，运行在SystemServer进程中。 RemoteViews实现了Parcelable接口，它会通过Binder传递到SystemServer进程，系统会根据RemoteViews中的包名信息获取到应用中的资源，从而完成布局文件的加载。 系统将view操作封装成Action对象，Action同样实现了Parcelable接口，通过Binder传递到SystemServer进程。远程进程通过RemoteViews的apply方法来进行view的更新操作，RemoteViews的apply方法内部则会去遍历所有的action对象并调用它们的apply方法来进行view的更新操作。这样做的好处是不需要定义大量的Binder接口，其次批量执行RemoteViews中的更新操作提高了程序性能。 RemoteViews的apply和reapply方法的区别：apply方法会加载布局并更新界面，而reapply方法则只会更新界面。 setOnClickPendingIntent、setPendingIntentTemplate和setOnClickFillIntent的区别，setOnClickPendingIntent用于给普通的view添加点击事件，但是不能给集合(ListView和StackView)中的view设置点击事件，因为开销太大了。如果需要给ListView和StackView中的item添加点击事件，需要结合setPendingIntentTemplate和setOnClickFillIntent一起使用。 假如报了android.app.RemoteServiceException: Bad notification posted from package ****: Couldn’t expand RemoteViews for:****问题，那么可能不一定是写错了，而是使用了Install Run功能，关闭此功能或每次修改自定义Notification的xml布局文件都要在运行前删除应用 * TaskStackBuilder(API16)当我们想要跳转的Activity按返回时返回的是应用的主界面或其他界面，而不是桌面时，可以使用此类来构建一个任务栈 步骤 创建TaskStackBuilder对象 通过addNextIntent (Intent nextIntent)添加跳转的intent 重复第二步，直到完成任务栈的创建 通过getPendingIntent()方法获得PendingIntent 设置跳转的PendingIntent 创建TaskStackBuilder对象 TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(this); 当Activity设置了android:parentActivityName属性时，使用addParentStack()方法可以直接创建其指定的所有上级进栈（但不包括自己），使用addNextIntentWithParentStack()包括自己及所有上级进栈 例子 TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(this); Intent intent = new Intent(this,MainActivity.class); taskStackBuilder.addNextIntent(intent); Intent intent2 = new Intent(this,SecondActivity.class); taskStackBuilder.addNextIntent(intent2); Intent intent3 = new Intent(this,ThirdActivity.class); taskStackBuilder.addNextIntent(intent3); int requestCode = (int) SystemClock.uptimeMillis(); remoteViews.setOnClickPendingIntent(R.id.test, taskStackBuilder.getPendingIntent(requestCode, PendingIntent.FLAG_UPDATE_CURRENT)); 常见Notification类型普通Notification略 点击取消显示的Notification builder中调用setAutoCancel(true)(Notification需要设置ContentIntent才有效) 无法滑动删除的Notification builder中调用setOngoing(true) 拥有按钮的Notification builder中使用addAction()添加按钮 折叠式Notification//设置展开后的视图 notification.bigContentView = remoteViews; 横幅式Notification builder对象调用setFullScreenIntent()方法 进度条Notification builder对象调用setProgress()方法 BigTextStyle样式的Notification 创建Notification.BigTextStyle对象 使用setBigContentTitle()设置标题 使用bigText()设置正文 使用setSummaryText()设置末尾行文本 使用setStyle()设置此style对象 BigPictureStyle样式的Notification 创建Notification.BigPictureStyle对象 使用setBigContentTitle()设置标题 使用setSummaryText()设置文本 使用bigPicture()设置大图，但是太大会造成OOM 使用bigLargeIcon()设置图标 使用setStyle()设置此style对象 InboxStyle样式的Notification 创建Notification.InboxStyle对象 使用setBigContentTitle()设置标题 使用addLine()添加行文本，调用n次则生成n行文本 使用setSummaryText()设置末尾行文本 使用setStyle()设置此style对象 MediaStyle样式的Notification builder中使用addAction()添加按钮 使用setMediaSession()设置MediaSession.Token对象 使用setShowActionsInCompactView()方法设置显示在通知右方的图标 最多三个 使用setStyle()设置此style对象 参考资料Android开发艺术探索【Android】状态栏通知Notification、NotificationManager详解Notification中PendingIntent.Flag的应用 Android 通知栏Notification的整合 全面学习 （一个DEMO让你完全了解它）Android Notification常见样式总结","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"BroadcastReceiver的使用","slug":"BroadcastReceiver的使用","date":"2016-08-27T14:00:00.000Z","updated":"2017-11-14T17:28:33.614Z","comments":true,"path":"2016/08/27/BroadcastReceiver的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/08/27/BroadcastReceiver的使用/","excerpt":"广播的分类\n普通广播\n有序广播\n粘性广播\n本地广播\n定向广播\n","text":"广播的分类 普通广播 有序广播 粘性广播 本地广播 定向广播 广播接收者的注册静态注册&lt;receiver android:name=\".MyBroadcastReceiver\"> &lt;intent-filter> &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"/> &lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/> &lt;action android:name=\"android.intent.action.BATTERY_CHANGED\" /> &lt;/intent-filter> &lt;/receiver> 启用和禁止广播接收器//启用广播接收器 private void enableBroadcastReceiver(Class&lt;?> cls) { PackageManager packageManager = getPackageManager( ); packageManager.setComponentEnabledSetting(new ComponentName(this, cls), PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP); } //禁止广播接收器 private void disableBroadcastReceiver(Class&lt;?> cls) { PackageManager packageManager = getPackageManager( ); packageManager.setComponentEnabledSetting(new ComponentName(this, cls), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP); } 动态注册 注册MyBroadcastReceiver receiver = new MyBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(\"android.intent.action.TIME_TICK\"); registerReceiver(receiver, filter); 解除注册unregisterReceiver(receiver); 动态注册的广播接收器必须要组件销毁前进行解除注册 普通广播 普通广播是完全异步的 通过Context的sendBroadcat()函数来发送 消息传递的效率比较高，但是所有的receivers(接收器)的执行顺序不确定 接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播 有序广播 有序广播通过Context的sendOrderedBroadcast()来发送 所有的广播接收器按照优先级依次执行，广播接收器的优先级通过receiver的intent-filter中的android:priority属性来设置，数值越大优先级越高。 当广播接收器接收的广播后，可以使用setResult()函数将结果传给下一个广播接收器接收，然后通过getResult()函数来取得上个广播接收器返回的结果，并可以用abortBroadcast()函数来让系统丢弃广播，使广播不再传送到别的广播接收器 有序广播的优先级 优先按android:priority来比较，数值越大则优先级越高，最大值为2147483647(即int型的最大值，而非官方文档的1000) 在android:priority相同的情况下，动态注册优先级高于静态注册 在注册方式一样的情况下，先注册的优先级高于后注册的 粘性广播 API21上标记为过时 通过Context的sendStickyBroadcast()函数来发送。用此函数发送的广播会一直滞留，当有匹配此广播的广播接收器被注册后，该广播接收器就会收到此条广播。 sendStickyBroadcast只保留最后一条广播，并且一直保留下去，这样即使已经有广播接收器处理了该广播，当再有匹配的广播接收器被注册时，此广播仍会被接收。如果只想处理一遍该广播，可以通过removeStickyBroadcast()函数实现 使用此函数发送广播时，需要获得B权限&lt;users-permission android:name=\"android.permission.BROADCAST_STICKY\"/> 本地广播 在21版的Support4包中新增本地广播，也就是LocalBroadcastManager 只需要调用context的sendBroadcast、registerReceiver、unregisterReceiver的地方替换为LocalBroadcastManager getInstance(Context context)中对应的函数即可 函数 作用 LocalBroadcastManager.getInstance(context).registerReceiver(receiver,intentFilter) 注册receiver LocalBroadcastManager.getInstance(context).unregisterReceiver(receiver) 注销receiver LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(HELLO_ACTON)) 发送异步广播 LocalBroadcastManager.getInstance(context).sendBroadcastSync(new Intent()) 发送同步广播 定向广播 定向广播是普通广播的一个变体 定向广播使用了intent-filter的一个特性，通过在Intent中设置ComponentName来显示指定接收器 public void sendDirectedBroadcast(String packageName,String className,String action) { Intent intent = new Intent(action); intent.setComponent(new ComponentName(packageName,className)); sendBroadcast(intent); } ` 权限设置自定义权限&lt;permission android:name=\"com.android.permission.MYRECEIVER\" android:protectionLevel=\"dangerous\"> &lt;/permission> 申明权限&lt;uses-permission android:name=\"com.android.permission.MYRECEIVER\"/> 发送权限sendBroadcast(intent, &quot;com.android.study.permission.MYRECEIVER&quot;); 静态注册带权限的广播接受者&lt;receiver android:name=\"com.android.receiver.PermissionBroadcastReceiver\" android:permission=\"com.android.permission.MYRECEIVER\"> ... &lt;/receiver> 动态注册带权限的广播接受者MyBroadcastReceiver receiver = new MyBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(\"android.intent.action.TIME_TICK\"); registerReceiver(receiver, filter,\"com.android.permission.MYRECEIVER\",null); 系统广播 BATTERY_CHANGED_ACTION 说明:充电状态，或者电池的电量发生变化。 action:”android.intent.action.BATTERY_CHANGED” BOOT_COMPLETED_ACTION 说明:在系统启动后，这个动作被广播一次（只有一次）。 action:”android.intent.action.BOOT_COMPLETED” CALL_FORWARDING_STATE_CHANGED_ACTION 说明:语音电话的呼叫转移状态已经改变。 action:”android.intent.action.CFF” CONFIGURATION_CHANGED_ACTION 说明:设备的配置信息已经改变 action:”android.intent.action.CONFIGURATION_CHANGED” DATA_ACTIVITY_STATE_CHANGED_ACTION 说明:电话的数据活动(data activity)状态（即收发数据的状态）已经改变。 action:”android.intent.action.DATA_ACTIVITY” DATA_CONNECTION_STATE_CHANGED_ACTION 说明:电话的数据连接状态已经改变。 action:”android.intent.action.DATA_STATE” DATE_CHANGED_ACTION 说明:日期被改变。 action:”android.intent.action.DATE_CHANGED” FOTA_CANCEL_ACTION 说明:取消所有被挂起的 (pending) 更新下载。 action:”android.server.checkin.FOTA_CANCEL” FOTA_INSTALL_ACTION 说明:更新已经被确认，马上就要开始安装。 action:”android.server.checkin.FOTA_INSTALL” FOTA_READY_ACTION说明:更新已经被下载，可以开始安装。action:”android.server.checkin.FOTA_READY” FOTA_RESTART_ACTION说明:恢复已经停止的更新下载。action:”android.server.checkin.FOTA_RESTART” FOTA_UPDATE_ACTION说明:通过 OTA 下载并安装操作系统更新。action:”android.server.checkin.FOTA_UPDATE” MEDIABUTTON_ACTION说明:用户按下了“Media Button”。action:”android.intent.action.MEDIABUTTON” MEDIA_BAD_REMOVAL_ACTION说明:扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)。action:”android.intent.action.MEDIA_BAD_REMOVAL” MEDIA_EJECT_ACTION说明:用户想要移除扩展介质（拔掉扩展卡）。action:”android.intent.action.MEDIA_EJECT” MEDIA_MOUNTED_ACTION说明:扩展介质被插入，而且已经被挂载。action:”android.intent.action.MEDIA_MOUNTED” MEDIA_REMOVED_ACTION说明:扩展介质被移除。action:”android.intent.action.MEDIA_REMOVED” MEDIA_SCANNER_FINISHED_ACTION说明:已经扫描完介质的一个目录。action:”android.intent.action.MEDIA_SCANNER_FINISHED” MEDIA_SCANNER_STARTED_ACTION说明:开始扫描介质的一个目录。action:”android.intent.action.MEDIA_SCANNER_STARTED” MEDIA_SHARED_ACTION说明:扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。action:”android.intent.action.MEDIA_SHARED” MEDIA_UNMOUNTED_ACTION说明:扩展介质存在，但是还没有被挂载 (mount)。action:”android.intent.action.MEDIA_UNMOUNTED” MESSAGE_WAITING_STATE_CHANGED_ACTION说明:电话的消息等待（语音邮件）状态已经改变。action:”android.intent.action.MWI” NETWORK_TICKLE_RECEIVED_ACTION说明:设备收到了新的网络 “tickle” 通知。action:”android.intent.action.NETWORK_TICKLE_RECEIVED” PACKAGE_ADDED_ACTION说明:设备上新安装了一个应用程序包。action:”android.intent.action.PACKAGE_ADDED” PACKAGE_REMOVED_ACTION说明:设备上删除了一个应用程序包。action:”android.intent.action.PACKAGE_REMOVED” PHONE_STATE_CHANGED_ACTION说明:电话状态已经改变。action:”android.intent.action.PHONE_STATE” PROVIDER_CHANGED_ACTION说明:更新将要（真正）被安装。action:”android.intent.action.PROVIDER_CHANGED” PROVISIONING_CHECK_ACTION说明:要求 polling of provisioning service 下载最新的设置。action:”android.intent.action.PROVISIONING_CHECK” SCREEN_OFF_ACTION说明:屏幕被关闭。action:”android.intent.action.SCREEN_OFF” SCREEN_ON_ACTION说明:屏幕已经被打开。action:”android.intent.action.SCREEN_ON” SERVICE_STATE_CHANGED_ACTION说明:电话服务的状态已经改变。action:”android.intent.action.SERVICE_STATE” SIGNAL_STRENGTH_CHANGED_ACTION说明:电话的信号强度已经改变。action:”android.intent.action.SIG_STR” STATISTICS_REPORT_ACTION说明:要求 receivers 报告自己的统计信息。action:”android.intent.action.STATISTICS_REPORT” STATISTICS_STATE_CHANGED_ACTION说明:统计信息服务的状态已经改变。action:”android.intent.action.STATISTICS_STATE_CHANGED” TIMEZONE_CHANGED_ACTION说明:时区已经改变。action:”android.intent.action.TIMEZONE_CHANGED” TIME_CHANGED_ACTION说明:时间已经改变（重新设置）。action:”android.intent.action.TIME_SET” TIME_TICK_ACTION说明:当前时间已经变化（正常的时间流逝）。action:”android.intent.action.TIME_TICK” UMS_CONNECTED_ACTION说明:设备进入 USB 大容量存储模式。action:”android.intent.action.UMS_CONNECTED” UMS_DISCONNECTED_ACTION说明:设备从 USB 大容量存储模式退出。action:”android.intent.action.UMS_DISCONNECTED” WALLPAPER_CHANGED_ACTION说明:系统的墙纸已经改变。action:”android.intent.action.WALLPAPER_CHANGED” XMPP_CONNECTED_ACTION说明:XMPP 连接已经被建立。action:”android.intent.action.XMPP_CONNECTED” XMPP_DISCONNECTED_ACTION说明:XMPP 连接已经被断开。action:”android.intent.action.XMPP_DI说明: 无法收到系统广播 android3.1以后，首次安装未启动或者用户强制force stop后，应用无法监听到系统广播 在Android3.1以后版本添加了标志FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，用于区分发送广播时是否启动激活那些未启动过或者被用户force stop的应用组件。当两个Flag都不设置或都设置的时候，默认操作是FLAG_INCLUDE_STOPPED_PACKAGES。 系统向所有的Intent的广播添加了FLAG_EXCLUDE_STOPPED_PACKAGES标志。它这样做是为了防止广播无意中的或不必要地开启组件的stoppped应用程序的后台服务。这样可以优化系统性能，提高安全性。 用户给自定义的广播Intent添加FLAG_INCLUDE_STOPPED_PACKAGES，用于启动stop状态的应用组件。但是系统自带的广播intent，我们无能为力。 部分广播需要动态注册才有效，如时间变化等 部分广播需要设置addDataScheme，mediaScanner相关的需要设置file，package相关的需要设置package,.sms相关的需要设置sms android官方API说明 参考资料Android开发进阶从小工到专家BroadcastReceiver应用详解BroadcastReceiver中使用自定义PermissionAndroid静态注册无法接受系统广播问题android.intent.action大全Android的BroadcastReciver收不到Broadcast（系统广播）的原因之一Android编程实战","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"ContentProvider的使用","slug":"ContentProvider的使用","date":"2016-08-23T14:00:00.000Z","updated":"2017-11-14T17:35:51.509Z","comments":true,"path":"2016/08/23/ContentProvider的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/08/23/ContentProvider的使用/","excerpt":"概述1.ContentProvider为存储和读取数据提供了统一的接口2.使用ContentProvider，应用程序可以实现数据共享3.android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等)","text":"概述1.ContentProvider为存储和读取数据提供了统一的接口2.使用ContentProvider，应用程序可以实现数据共享3.android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等) 了解URI UriMatcherUriMatcher用于匹配Uri路径 创建URiMatcherUriMatcher sMatcher = new UriMatcher(UriMatcher.NO_MATCH); 设置路径及匹配码addURI(String authority, String path, int code) 自定义ContentProvider类的AUTHORITY字符串 path表示需要匹配的路径 code表示匹配码(必须大于零)，匹配则返回的值用#代表匹配任意数字，用*来匹配任意文本 例子 sMatcher.addURI(&quot;contacts&quot;, &quot;person&quot;,1); 进行匹配返回匹配码match(Uri uri) 例子 int code = sMatcher.match(Uri.parse(\"content://contacts/person/10\")); ContentUrisContentUris类用于获取Uri路径后面的ID部分 withAppendedId(Uri contentUri, long id)用于为路径加上ID部分： Uri uri = Uri.parse(&quot;content://contacts/person&quot;) Uri resultUri = ContentUris.withAppendedId(uri, 10); parseId(Uri contentUri)方法用于从路径中获取ID部分： Uri uri = Uri.parse(&quot;content://contacts/person/10&quot;) long personid = ContentUris.parseId(uri);//获取的结果为:10 使用ContentProvider共享数据继承于ContentProvider实现以下方法 public void onCreate() 该方法在ContentProvider创建后调用，当第一次访问ContentProvider时，该ContentProvider会被创建出来，并立即回调该onCreate()方法 public Cursor query(Uri uri, String[] projection, String selection,String[] selectionArgs, String sortOrder) 该方法用于返回当前Uri所代表的数据。 projection 要查询出来的列名，相当于select语句select关键字后面的部分 selection 查询条件子句，相当于select语句where关键字后面的部分，在条件子句中允许使用占位符“？” selectionArgs 用于为selection子句中的占位符传值 sortOrder 表示排序方式，相当于select语句order by关键字后面的部分 public String getType(Uri uri) 该方法用于返回当前Uri所代表数据的MIME类型。 如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头 如果操作的数据属于集合类型，那么MIME类型字符串应该以vnd.android.cursor.dir/开头 public Uri insert(Uri uri, ContentValues values) 根据当前Uri插入values对应的数据 values代表要插入的数据 public int delete(Uri uri, String selection, String[] selectionArgs) 根据当前Uri删除对应的数据 selection 查询条件子句，相当于where关键字后面的部分，在条件子句中允许使用占位符“？” selectionArgs 用于为selection子句中的占位符传值 public int update(Uri uri, ContentValues values, String selection,String[] selectionArgs) 根据当前Uri修改对应的数据 values 要修改的值，对应与set关键字后面的字段 selection 查询条件子句，相当于where关键字后面的部分，在条件子句中允许使用占位符“？” selectionArgs 用于为selection子句中的占位符传值 当使用查询语句要返回Cursor对象时，可以使用MatrixCursor或继承MatrixCursor实现自己的Cursor来创建返回的Cursor对象 使用ContentResolver操作ContentProvider中的数据使用getContentResolver();获得ContentResolver对象 public Uri insert(Uri uri, ContentValues values) 该方法用于往ContentProvider添加数据。 public int delete(Uri uri, String selection, String[] selectionArgs) 该方法用于从ContentProvider删除数据。 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) 该方法用于更新ContentProvider中的数据。 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) 该方法用于从ContentProvider中获取数据。 监听ContentProvider中数据的变化 设置监听器 getContentResolver().registerContentObserver(uri,true,new ContentObserver(new Handler()) { @Override public void onChange(boolean selfChange) { super.onChange(selfChange); } }); 其中第二个参数为true时，只要uri是其子层也会被通知，如果为false，则只有uri完全匹配才行。 通知数据发生变化在自己ContentProvider类的方法中调用。getContext().getContentResolver().notifyChange(uri,null); 权限设置ContentProvider通过在AndroidManifest中设置读权限（android:readPermission）写权限（android:writePermission）读写权限（android:permission）(但优先级没前面两个高)来控制权限，通过path-permission子标签能进行更详细的控制，grant-uri-permission子标签用于当一个有权限访问的组件调用一个无权限访问的组件访问时ContentProvider可以访问 具体属性请看provider属性详解 AsyncQueryHandler// 定义一个handler，采用的是匿名类的方式，只处理query，因此只重写了onQueryComplete函数： queryHandler = new AsyncQueryHandler(this.getContentResolver()){ // 传入的是一个ContentResolver实例，所以必须在OnCreate后实例化该Handler类 @Override protected void onQueryComplete(int token, Object cookie, Cursor cursor) { // 在这里你可以获得一个cursor和你传入的附加的token和cookie。 // 该方法在当前线程下（如果传入的是默认的Looper话），可以自由设定UI信息 } }; 调用时只需要调用 startQuery(int token, Object cookie, ContentURI uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) 函数即可： 例如： queryHandler.startQuery(token, cookie, uri, projection, selection, selectionArgs, sortBy); 参考资料Android ContentProvider和Uri详解 (绝对全面)一些ContentProvider和 AsyncQueryHandler 联合使用技巧","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"Android Studio的使用","slug":"Android Studio的使用","date":"2016-08-10T14:00:00.000Z","updated":"2017-11-14T17:44:56.236Z","comments":true,"path":"2016/08/10/Android Studio的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/08/10/Android Studio的使用/","excerpt":"","text":"快捷键IDE 功能 按键 帮助 F1 查找文件所在目录位置 Alt+F1 快速打开或隐藏工程面板 Alt+1 打开设置对话框 Ctrl+Alt+S 跳转到导航栏 Alt+Home 光标返回编辑框 Esc 光标返回编辑框,关闭无用的窗口 Shift+Esc 关闭标签页 Shift+Click 把焦点从编辑框移到最近使用的工具窗口 F12 同步 Ctrl+Alt+Y 打开或关闭列选择模式 Alt+Shift+Insert 打开当前项目/模块属性 Ctrl+Alt+Shift+S 查看文件的变更历史 Alt+Shift+C 运行 Ctrl+Shift+F10 debug运行 Ctrl+Shift+F9 资源管理器打开文件夹 Ctrl+Alt+F12 切换器 Ctrl+Tab 版本控制操作弹窗 Alt+` 编辑 功能 按键 复制当前行或选中的内容 Ctrl+C 粘贴当前行或选中的内容 Ctrl+D 剪切当前行或选中的内容 Ctrl+X 删除行 Ctrl+Y 倒退 Ctrl+Z 向前 Ctrl+Shift+Z 自动修正 Alt+Enter 格式化代码 Ctrl+Alt+L 将选中的代码进行自动缩进编排 Ctrl+Alt+I 优化导入的类和包 Ctrl+Alt+O 自动生成代码 Alt+Insert 选最近使用的剪贴板内容并插入 Ctrl+Shift+V 简单粘贴 Ctrl+Alt+Shift+V 选最近使用的剪贴板内容并插入 Ctrl+Shift+Insert 在当前行的上面插入新行，并移动光标到新行 Ctrl+Enter 在当前行的下面插入新行，并移动光标到新行 Shift+Enter 自动代码 Ctrl+J 把选中的代码放在try{}、if{}、else{}里 Ctrl+Alt+T 竖编辑模式 Shift+Alt+Insert 注释 // Ctrl+ / 注释 /…/ Ctrl+Shift+ / 合并成一行 Ctrl+Shift+J 跳转到下/上一个错误语句处 F2/Shift+F2 跳转到上次编辑的地方 Ctrl+Shift+Back 类名自动完成 Ctrl+Alt+Space 内容向上/下移动 Shift+Alt+Up/Down 方法向上/下移动 Ctrl+Shift+Up/Down 大小写切换 Ctrl+Shift+U 代码标签输入完成后，按Tab，生成代码 Tab 按单词删除 Ctrl+Backspace 语句完成 Ctrl+Shift+Enter 用动态模板环绕 Ctrl+Alt+J 展开所有方法 Ctrl+Shift++ 收缩所有方法 Ctrl+Shift+- 展开当前方法 Ctrl+Alt++ 收缩当前方法 Ctrl+Alt+- 最近剪贴板的内容列表 Ctrl+Shift+V 查看当前方法的申明 Alt+Q 查看当前类的申明 连续两次Alt+Q 根据选中内容，选择多行 Alt+J 列选择模式 Alt+Mouse 移除包裹代码 Ctrl+Shift+Delete 文件 功能 按键 显示当前文件的结构 Ctrl+F12 显示类继承结构图 Ctrl+H 显示注释文档 Ctrl+Q 方法参数提示 Ctrl+P 打开当前类的父类或者实现的接口 Ctrl+U 切换代码视图 Alt+Left/Righ 返回上次编辑的位置 Ctrl+Alt+Left/Right 在方法间快速移动定位 Alt+Up/Down 快速打开光标处的类或方法 Ctrl+B 选中代码，连续按会有其他效果 Ctrl+W 取消选择光标所在词 Ctrl+Shift+W 高亮错误或警告快速定位 F2或Shift+F2 在方法间快速移动定位 Alt+Up/Down 代码行级移动 Alt+Shift++Up/Down 复制引用，必须选择类名 Ctrl+Alt+Shift+C 复制路径 Ctrl+Shift+C 定位行 Ctrl+G 方法调用层级弹窗 Ctrl+Alt+H 定义快速查找 Ctrl+Shift+I 查找 功能 按键 在当前窗口查找文本 Ctrl+F 在指定环境下查找文本 Ctrl+Shift+F 向下查找关键字出现位置 F3 向上一个关键字出现位置 Shift+F3 在当前窗口替换文本 Ctrl+R 在指定窗口替换文本 Ctrl+Shift+R 查找类 Ctrl+N 查找文件 Ctrl+Shift+N 查找项目中的方法或变量 Ctrl+Shift+Alt+N 查找变量的来源 Ctrl+B 快速打开光标处的类或方法 Ctrl+Alt+B 跳转到类或方法实现处 Ctrl+Shift+B 最近打开的文件列表 Ctrl+E 快速查找，效果和Ctrl+F相同 Alt+F3 跳转至定义变量的位置 F4 查询当前元素在工程中的引用 Alt+F7 查询当前元素在当前文件中的引用，然后按F3可以选择 Ctrl+F7 选中查询当前元素在工程中的引用 Ctrl+Alt+F7 高亮显示匹配的字符，按Esc高亮消失 Ctrl+Shift+F7 弹出显示查找内容 Ctrl+Shift+O 快速跳转搜索结果 Ctrl+Alt+Up/Down 高级搜索、搜索结构 Ctrl+Shift+S 查找Android Studio的菜单选项 Ctrl+Shift+A 重构 功能 按键 复制 F5 移动 F6 安全删除 Alt+Delete 转到父类 Ctrl+U 重写父类的方法 Ctrl+O 实现方法 Ctrl+I 内联 Ctrl+Alt+N 弹出重构菜单 Ctrl+Alt+Shift+T 重构-重命名 Shift+F6 提取代码组成方法 Ctrl+Alt+M 将变量更改为常量 Ctrl+Alt+C 定义变量引用当前对象或者方法的返回值 Ctrl+Alt+V 将局部变量更改为类的成员变量 Ctrl+Alt+F 将变量更改为方法的参数 Ctrl+Alt+P 调试 功能 按键 跳到下一步 F8 跳出函数、跳到下一个断点 Shift+F8 强制跳出函数 Alt+Shift+F8 进入代码 F7 智能进入代码 Shift+F7 强制进入代码 Alt+Shift+F7 运行至光标处 Alt+F9 强制运行至光标处 Ctrl+Alt+F9 停止运行 Ctrl+F2 计算变量值 Alt+F8 VCS 功能 按键 VCS操作菜单 Alt+ ~ 提交更改 Ctrl+K 更新项目 Ctrl+T 显示变化 Ctrl+Alt+Shift+D 标签 功能 按键 打上或取消标签 F11 带字母或者数字的标签 Ctrl+F11 展示标签 Shift+F11 如果设置数字标签则跳转到指定标志行 Ctrl+数字 其他设置使用Eclipse的快捷键方案设置 File-&gt;Settings 或Ctrl + Alt + S 找到keymap ，右侧找到 keymaps，选择Eclipse 设置界面的字体和大小设置 File-&gt;Settings 或Ctrl + Alt + S 找到Appearance &amp; Behavior -&gt;Appearance ,右侧勾选Override default fonts by(not recommended),再选择字体大小即可 设置编辑器的字体和大小设置 File-&gt;Settings 或Ctrl + Alt + S 找到Editor ——&gt;Colors&amp;Fonts——&gt;Font，右侧点击Save As新建一份自己的设置Editor Font即可 设置行宽设置 File-&gt;Settings 或Ctrl + Alt + S 找到Editor-&gt;Code Style, 右侧找到Right margin (columns)，默认是100 设置代码格式化风格设置 File-&gt;Settings 或Ctrl + Alt + S 找到Editor-&gt;Code Style-&gt;java,右侧找到Wrapping and Brances设置 以下为个人使用的设置(大括号换行且if有括号) 设置LogCat颜色设置 File-&gt;Settings 或Ctrl + Alt + S 找到 Editor -&gt; Colors &amp;Fonts -&gt; Android Logcat 或在上面的搜索框中输入Logcat 点中Verbose , Info, Debug等选项，然后在后面将Use Inberited attributes 去掉勾选 再将 Foreground 前的复选框选上，就可以双击后面的颜色 对应色值（自用） Log级别 色值 VERBOSE BBBBBB DEBUG 0070BB INFO 48BB31 WARN BBBB23 ERROR FF4157 ASSERT FF0006 LogCat换行显示点击右边图标第五个Use Soft Wraps即可 显示行号行号位置右击点选Show Line Numbers 创建自己的模板缩写设置 File-&gt;Settings 或Ctrl + Alt + S 找到 Editor-&gt;Live Templates，右边找到一个绿色加号的图标，点击选择&gt;Live Template，这时有三个输入框，Abbreviation是模板的缩写，Description是描述，Template text输入要生成的模板代码，其中变量使用$变量的名称$ 例如 Intent intent = new Intent($MainActivity$.this,$SecondActivity$.class); startActivity(intent); 插件推荐 ADB IDEA使用快捷键ctrl + Shift + Alt + A ECTranslation Material Theme UI GsonFormat使用快捷键Alt + S 或者Code -&gt; Generate -&gt; GsonFormat Android Material Design Icon GeneratorFile -&gt; New -&gt; Material Design Icon Android Parcelable code generatorCode -&gt; Generate -&gt; parcelable CodeGlance Android Layout Id Converter在layout文件右键点击Convert Android layout xml 使用小技巧 与分支比对（Compare With Branch (Git)）● 描述：假如你的项目是使用git来管理的，你可以将当前文件或者文件夹与其他的分支进行比对。比较有用的是可以让你了解到你与主分支有多少差别。● 调用：Menu → VCS → Git → Compare With Branch 与剪切板比对（Compare With Clipboard）● 描述：将当前选中的部分与剪切板上的内容进行比对。● 调用：右键选中的部分，在右键菜单中选择“Compare With Clipboard” 分析传入数据流（Analyze data flow to here）● 描述：这个操作将会根据当前选中的变量、参数或者字段，分析出其传递到此处的路径。 当你进入某段陌生的代码，试图明白某个参数是怎么传递到此处的时候，这是一个非常有用的操作。● 调用：Menu → Analyze → Analyze Data Flow to Here● 快捷键：无，可以在设置中指定。● 相反的操作：分析传出数据流（Analyze data flow from here），这个将会分析当前选中的变量往下传递的路径，直到结束。 堆栈追踪分析（Analyze Stacktrace）● 描述： 这个操作读取一份堆栈追踪信息，并且使它像logcat中那样可以点击。当你从bug报告中或者终端复制了一份堆栈追踪，使用该操作可以很方便地调试。● 调用：Menu → Analyze → Analyze Stacktrace● 快捷键：无，可以在设置中指定。● 更多：通过使用“ProGuard Unscramble Plugin”插件，也可以分析混淆过的堆栈追踪。 条件断点（Conditional Breakpoints）● 描述：简单说，就是当设定的条件满足时，才会触发断点。你可以基于当前范围输入一个java布尔表达式，并且条件输入框内是支持代码补全的。● 调用：右键需要填写表达式的断点，然后输入布尔表达式。 禁用断点（Disable Breakpoints）● 这个操作将使得断点。当你有一个设置过复杂条件的断点或者是日志断点，当前不需要，但是下次又不用重新创建，该操作是很方便的。● 调用：按住Alt，然后单击断点即可。 计算表达式（Evaluate Expression）● 描述：这个操作可以用来查看变量的内容并且计算几乎任何有效的java表达式。需要注意的是，如果你修改了变量的状态，这个状态在你恢复代码执行后依然会保留。● 快捷键：处在断点状态时，光标放在变量处，按Alt + F8，即可显示计算表达式对话框。 审查变量（Inspect Variable）● 描述：该操作可以在不打开计算表达式对话框就能审查表达式的值。● 快捷键：调试状态下，按住Alt键，然后单击表达式即可。 日志断点（Logging Breakpoints）● 描述：这是一种打印日志而不是暂停的断点，当你想打印一些日志信息但是不想添加log代码后重新部署项目，这是一个非常有用的操作。● 调用：在断点上右键，取消Suspend的勾选，然后勾选上Log evaluated Expression，并在输入框中输入你要打印的日志信息。 标记对象（Mark Object）● 描述：当你在调试的时候，这个操作可以让你给某个特殊的对象添加一个标签，方便你后面很快地辨认。在调试时，当你从一堆相似的对象中查看某个对象是否和之前是一样的，这就是一个非常有用的操作。● 调用：右键你需要标记的对象，选中Mark Object，输入标签；● 快捷键：选中对象时，按F3(OS X)、F11(Windows/Linux)； 显示当前运行点（Show Execution Point）● 描述：该操作会立刻把你的光标移回到当前debug处。通常的情况是： 1. 你在某处触发了断点 2. 然后在文件中随意浏览 3. 直接调用这个快捷键，快速返回之前逐步调试的地方。● 快捷键：（Debug时) Alt + F10； 终止进程（Stop Process）● 描述：该操作会终止当前正在运行的任务。如果任务数量大于一，则显示一个列表供你选择。在终止调试或者中止编译的时候特别有用！● 快捷键：Cmd + F2(OS X)、Ctrl + F2（Windows、Linux）； 临时断点（Temporary Breakpoints）● 描述：通过该操作可以添加一个断点，这个断点会在第一次被命中的时候自动移除。● 快捷键：Alt + 鼠标左键 点击代码左侧（鼠标）、Cmd + Alt + Shift + F8(OS X)、Ctrl + Alt + Shift + F8(Windows/Linux) 调用层级树弹窗（The Call Hierarchy Popup）● 描述：该操作会给你展示 在一个方法的声明和调用之间所有可能的路径。● 快捷键：Ctrl + Alt + H 常用模板缩写key private static final String KEY_$value$ = &quot;$value$&quot;; toast android.widget.Toast.makeText($className$.this, &quot;$text$&quot;, Toast.LENGTH_SHORT).show(); logd android.util.Log.d(TAG, &quot;$METHOD_NAME$: $content$&quot;); loge android.util.Log.e(TAG, &quot;$METHOD_NAME$: $content$&quot;, $exception$); logi android.util.Log.i(TAG, &quot;$METHOD_NAME$: $content$&quot;); logr android.util.Log.d(TAG, &quot;$METHOD_NAME$() returned: &quot; + $result$); logt private static final String TAG = &quot;$className$&quot;; wtf android.util.Log.wtf(TAG, &quot;$METHOD_NAME$: $content$&quot;, $exception$); appNs xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; toolsNs xmlns:tools=&quot;http://schemas.android.com/tools&quot; psf public static final fori for(int $INDEX$ = 0; $INDEX$ &lt; $LIMIT$; $INDEX$++) { $END$ } 参考资料Android Studio快捷键Android Studio 小技巧合集","raw":null,"content":null,"categories":[{"name":"Tool","slug":"Tool","permalink":"https://luoweiguang.github.io/categories/Tool/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://luoweiguang.github.io/tags/Android-Studio/"},{"name":"IDE","slug":"IDE","permalink":"https://luoweiguang.github.io/tags/IDE/"},{"name":"Tool","slug":"Tool","permalink":"https://luoweiguang.github.io/tags/Tool/"}]},{"title":"ViewGrop及其子类属性的总结","slug":"ViewGrop及其子类属性的总结","date":"2016-08-09T14:00:00.000Z","updated":"2017-11-14T17:51:06.508Z","comments":true,"path":"2016/08/09/ViewGrop及其子类属性的总结/","link":"","permalink":"https://luoweiguang.github.io/2016/08/09/ViewGrop及其子类属性的总结/","excerpt":"","text":"ViewGroup android:addStatesFromChildren相关方法:setAddStatesFromChildren(boolean)说明:定义布局是否应用子布局的背景 android:alwaysDrawnWithCache相关方法:setAlwaysDrawnWithCacheEnabled(boolean)说明:定义子布局是否应用绘图的高速缓存 android:animateLayoutChanges相关方法:setLayoutTransition(LayoutTransition)说明:布局改变时是否有动画效果 android:animationCache相关方法:setAnimationCacheEnabled(boolean)说明:定义子布局也有动画效果 android:clipChildren相关方法:setClipChildren(boolean)说明:定义子布局是否一定要在限定的区域内 android:clipToPadding相关方法:setClipToPadding(boolean)说明:定义布局间是否有间距 android:descendantFocusability相关方法:setDescendantFocusability (int)说明:控制子布局焦点获取方式 常用于listView的item中包含多个控件 点击无效 android:layoutAnimation相关方法:setLayoutAnimation (LayoutAnimationController)说明:定义布局显示时候的动画 android:layoutMode(API18)相关方法:setLayoutMode(int)说明:设置布局类型 android:persistentDrawingCache相关方法:setPersistentDrawingCache(int)说明:定义绘图的高速缓存的持久性 android:splitMotionEvents相关方法:setMotionEventSplittingEnabled(boolean)说明:定义布局是否传递touch事件到子布局 android:descendantFocusability 值 说明 beforeDescendants viewgroup会优先其子类控件而获取到焦点 afterDescendants viewgroup只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants viewgroup会覆盖子类控件而直接获得焦点 android:layoutMode 值 说明 clipBounds 使用控件编辑布局(默认) opticalBounds 使用视觉边界布局 AbsListView android:cacheColorHint相关方法:setCacheColorHint(int)说明:列表总是在固定的单色、不透明的背景下绘制 android:choiceMode相关方法:setChoiceMode(int)说明:设置选择模式 android:drawSelectorOnTop相关方法:setDrawSelectorOnTop(boolean)说明:如果为真，选择器将绘制在选中条目的上层。否则绘制在下层。默认为假 android:fastScrollEnabled相关方法:setFastScrollEnabled(boolean)说明:是否允许使用快速滚动滑块 android:listSelector相关方法:setSelector(int)说明:用于在列表中指示当前选中条目的可绘制对象 android:scrollingCache相关方法:setScrollingCacheEnabled(boolean)说明:当为真时，列表滚动使用绘图缓存。该选项使渲染更快，但占用更多的内存。 默认值为真 android:smoothScrollbar相关方法:setSmoothScrollbarEnabled(boolean)说明:为真时，列表会使用更精确的基于条目在屏幕上的可见像素高度的计算方法。 默认该属性为真，如果你的适配器需要绘制可变高的条目，他应该设为假。 当该属性为真时，你在适配器在显示变高条目时，滚动条的把手会在滚动的 过程中改变大小。当设为假时，列表只使用适配器中的条目数和屏幕上的 可见条目来决定滚动条的属性 android:stackFromBottom相关方法:setStackFromBottom(boolean)说明:内容栈从底部开始 android:textFilterEnabled相关方法:setTextFilterEnabled(boolean)说明:设为真时，列表会过滤根据用户的要求，过滤结果集。列表的适配器必须实现了 Filterable 接口，才能使其可用 android:transcriptMode相关方法:setTranscriptMode(int)说明:设置列表的跳转模式。在跳转模式下，当加入新条目时，列表会滚动到底部， 使新条目可见 android:choiceMode属性说明 值 说明 none 无选择模式 singlechoice 最多可以有一项被选中 multipleChoice 可以多项被选中 multipleChoiceModal 排斥点击的多选 android:transcriptMode属性说明 值 说明 disabled 禁用跳转模式 normal 仅当最后的条目在屏幕上可见，并且收到数据集变更消息时列表将自动滚动到底部。 alwaysScroll 总是自动滚动到列表的底部 GridView android:columnWidth相关方法:setColumnWidth(int)说明:每列的宽度 android:gravity相关方法:setGravity(int)说明:设置对齐方式 android:horizontalSpacing相关方法:setHorizontalSpacing(int)说明:两列之间的间距 android:numColumns相关方法:setNumColumns(int)说明:列数 android:stretchMode相关方法:setStretchMode(int)说明:缩放模式 android:verticalSpacing相关方法:setVerticalSpacing(int)说明:两行之间的间距 android:numColumns属性说明 值 说明 auto_fit 列数 android:stretchMode属性说明 值 说明 none 不拉伸 spacingWidth 仅拉伸元素之间的间距 columnWidth 仅拉伸表格元素本身 spacingWidthUniform 表格元素与元素之间的间距一起拉伸 ListView android:divider相关方法:setDivider(Drawable)说明:设置分隔条 android:dividerHeight相关方法:setDividerHeight(int)说明:分隔条的高度 android:entries说明:指定一个数组资源，将根据数组资源生成ListView android:footerDividersEnabled相关方法:setFooterDividersEnabled(boolean)说明:如果有表尾的话,列表表尾是否显示分割线 android:headerDividersEnabled相关方法:setHeaderDividersEnabled(boolean)说明:如果有表头的话,列表表头是否显示分割线 ExpandableListView android:childDivider相关方法:setChildDivider(Drawable)说明:指定各子列表项之间的分隔条 android:childIndicator相关方法:setChildIndicator(Drawable)说明:显示在子列表旁边的Drawable对象 android:childIndicatorEnd相关方法:setChildIndicatorBoundsRelative(int,int)说明:子列表项指示符距离结束的位置 android:childIndicatorLeft相关方法:setChildIndicatorBounds(int,int)说明:子列表项指示符的左边约束位置 android:childIndicatorRight相关方法:setChildIndicatorBounds(int,int)说明:子列表项指示符的右边约束位置 android:childIndicatorStart相关方法:setChildIndicatorBoundsRelative(int,int)说明:子列表项指示符距离开始的位置 android:groupIndicator相关方法:setGroupIndicator(Drawable)说明:显示在组列表旁边的Drawable对象 android:indicatorEnd相关方法:setIndicatorBoundsRelative(int,int)说明:组列表项指示符距离结束的位置 android:indicatorLeft相关方法:setIndicatorBounds(int, int)说明:组列表项指示器的左边约束位置 android:indicatorRight相关方法:setIndicatorBounds(int,int)说明:组列表项指示器的右边约束位置 android:indicatorStart相关方法:setIndicatorBoundsRelative(int,int)说明:组列表项指示符距离开始的位置 AbsSpinner android:entries说明:指定一个数组资源 Gallery android:animationDuration相关方法:setAnimationDuration(int)说明:设置布局变化时动画的时间 android:gravity相关方法:setGravity(int)说明:设置对齐方式 android:spacing相关方法:setSpacing(int)说明:设置图片之间的间距 android:unselectedAlpha相关方法:setUnselectedAlpha(float)说明:设置未选择条目的透明度 Spinner android:dropDownHorizontalOffset 相关方法:setDropDownHorizontalOffset(int)说明:设置列表选择框的水平偏移距 android:dropDownSelector说明:设定spinnerMode=”dropdown”时列表选择器的显示效果 android:dropDownVerticalOffset相关方法:setDropDownVerticalOffset(int)说明:设置列表选择框的垂直偏移距 android:dropDownWidth相关方法:setDropDownWidth(int)说明:设置列表选择框的宽度 android:gravity相关方法:setGravity(int)说明:设置对齐方式 android:popupBackground相关方法:setPopupBackgroundResource(int)说明:设置列表选择框的背景色 android:prompt相关方法:setPrompt(CharSequence)说明:设置列表选择框的提示信息 android:spinnerMode说明:显示模式 android:spinnerMode属性说明 值 说明 dialog Spinner会被作为一个对口窗口来显示 dropdown Spinner会作为一个内嵌的下拉列表来显示 AdapterViewAnimator android:animateFirstView相关方法:setAnimateFirstView(boolean)说明:首次显示时是否对当前视图应用动画 android:inAnimation相关方法:setInAnimation(ObjectAnimator)说明:标识显示视图时使用的动画 android:loopViews说明:定义当动画执行到列表尾部后,是否循环执行到第一个视图 android:outAnimation相关方法:setOutAnimation(ObjectAnimator)说明:设置组件隐藏时使用的动画 AdapterViewFlipper android:autoStart相关方法:setAutoStart(boolean)说明:设置显示该组件是否是自动播放 android:flipInterval相关方法:setFlipInterval(int)说明:设置自动播放的时间间隔 GridLayout android:alignmentMode相关方法:setAlignmentMode(int)说明:对齐类型 android:columnCount相关方法:setColumnCount(int)说明:最大列数 android:columnOrderPreserved相关方法:setColumnOrderPreserved(boolean)说明:当设置为true，使列边界显示的顺序和列索引的顺序相同。默认是true android:orientation相关方法:setOrientation(int)说明:定义方向 android:rowCount相关方法:setRowCount(int)说明:最大行数 android:rowOrderPreserved相关方法:setRowOrderPreserved(boolean)说明:当设置为true，使行边界显示的顺序和行索引的顺序相同。默认是true。 android:useDefaultMargins相关方法:setUseDefaultMargins(boolean)说明:当设置ture，当没有指定视图的布局参数时，告诉GridLayout使用默认的边距。默认值是false。 android:alignmentMode属性说明 值 说明 alignBounds 对齐子视图边界 alignMargins 对齐子视图边距 android:orientation属性说明 值 说明 horizontal定义水平部件 vertical 定义垂直部件 FrameLayout android:foregroundGravity相关方法:setForegroundGravity(int)说明:设置布局前景图的位置 android:measureAllChildren相关方法:setMeasureAllChildren(boolean)说明:是否在测量时测量所有的子元素（即使该子元素为gone） CalendarView android:dateTextAppearance相关方法:setDateTextAppearance(int)说明:设置日期文本样式 android:firstDayOfWeek相关方法:setFirstDayOfWeek(int)说明:当天是本周的第几天 android:focusedMonthDateColor相关方法:setFocusedMonthDateColor(int)说明:设置获得焦点的月份的日期的颜色 android:maxDate相关方法:setMaxDate(long)说明:设置支持的最大日期，以mm/dd/yyyy格式指定最大日期 android:minDate相关方法:setMinDate(long)说明:设置支持的最小日期，以mm/dd/yyyy格式指定最小日期 android:selectedDateVerticalBar相关方法:setSelectedDateVerticalBar(int)说明:设置绘制在选中日期两边的虚线对应的drawable android:selectedWeekBackgroundColor 相关方法:setSelectedWeekBackgroundColor(int)说明:设置被选中周的背景色 android:showWeekNumber相关方法:setShowWeekNumber(boolean)说明:设置是否显示第几周 android:shownWeekCount相关方法:setShownWeekCount(int)说明:设置显示的星期数 android:unfocusedMonthDateColor相关方法:setUnfocusedMonthDateColor(int)说明:设置没有焦点月份日期文字的颜色 android:weekDayTextAppearance相关方法:setWeekDayTextAppearance(int)说明:设置星期几的文字样式 android:weekNumberColor相关方法:setWeekNumberColor(int)说明:设置显示周编号的颜色 android:weekSeparatorLineColor相关方法:setWeekSeparatorLineColor(int)说明:设置周分隔线的颜色 CardView android.support.v7.cardview:cardBackgroundColor 相关方法:setCardBackgroundColor(int)说明:背景颜色 android.support.v7.cardview:cardCornerRadius相关方法:setRadius(float)说明:圆角的半径 android.support.v7.cardview:cardElevation 相关方法:setMaxCardElevation(float)说明:Z轴距离 android.support.v7.cardview:cardMaxElevation说明:最大Z轴距离 android.support.v7.cardview:cardPreventCornerOverlap 相关方法:setPreventCornerOverlap(boolean)说明:防止内容与边角重叠 android.support.v7.cardview:cardUseCompatPadding 相关方法:setUseCompatPadding(boolean)说明:是否使用边距 android.support.v7.cardview:contentPadding 相关方法:setContentPadding(int,int,int,int)说明:边距 android.support.v7.cardview:contentPaddingBottom 相关方法:setContentPadding(int,int,int,int)说明:下边距 android.support.v7.cardview:contentPaddingLeft 相关方法:setContentPadding(int,int,int,int)说明:左边距 android.support.v7.cardview:contentPaddingRight 相关方法:setContentPadding(int,int,int,int)说明:右边距 android.support.v7.cardview:contentPaddingTop相关方法:setContentPadding(int,int,int,int)说明:上边距 CollapsingToolbarLayout android.support.design:collapsedTitleGravity 相关方法:setCollapsedTitleGravity(int)说明:指定折叠状态的标题如何放置 android.support.design:collapsedTitleTextAppearance 相关方法:setCollapsedTitleTextAppearance(int)说明:指定折叠状态标题文字的样貌 android.support.design:contentScrim相关方法:setContentScrimResource(int)说明:指定CollapsingToolbarLayout完全被滚出到屏幕外时的ColorDrawable android.support.design:expandedTitleGravity 相关方法:setExpandedTitleGravity(int)说明:展开状态的标题如何放置 android.support.design:expandedTitleMargin说明:设置边界距离 android.support.design:expandedTitleMarginBottom说明:底部的边界距离 android.support.design:expandedTitleMarginEnd说明:右边的边界距离 android.support.design:expandedTitleMarginStart说明:左边的边界距离 android.support.design:expandedTitleTextAppearance 相关方法:setExpandedTitleTextAppearance(int)说明:指定展开状态标题文字的样貌 android.support.design:statusBarScrim相关方法:setStatusBarScrimResource(int)说明:在折叠的时候状态栏的背景颜色 android.support.design:title相关方法:setTitle(CharSequence)说明:如果标题可用的话显示的标题文字 android.support.design:titleEnabled相关方法:setTitleEnabled(boolean)说明:是否显示标题 android.support.design:toolbarId说明:在折叠的时候 显示的toolbar的id DatePicker android:calendarTextColor说明:日历的列表文字颜色 android:calendarViewShown说明:是否显示日历视图 android:datePickerMode说明:定义部件的外观，有spinner和calendar两种选择 android:dayOfWeekBackground说明:头部的星期的背景颜色 android:dayOfWeekTextAppearance说明:头部的星期的文字外观 android:endYear说明:最后一年 android:firstDayOfWeek相关方法:setFirstDayOfWeek(int)说明:设置日历星期第一天是哪一天 android:headerBackground说明:头部背景 android:headerDayOfMonthTextAppearance说明:头部对应号数的文字外观 android:headerMonthTextAppearance说明:头部对应月份的文字外观 android:headerYearTextAppearance说明:头部对应年份的文字外观 android:maxDate说明:日历视图的最大日期,格式为mm/dd/yyyy android:minDate说明:日历视图的最小日期，格式为mm/dd/yyyy 14.android:spinnersShown说明:是否显示下拉菜单 android:startYear说明:从哪一年开始 android:yearListItemTextAppearance说明:选择年的列表的文字外观 android:yearListSelectorColor说明:选择年的列表中选中的颜色 HorizontalScrollView android:fillViewport相关方法:setFillViewport(boolean)说明:是否可以充满整个父布局 GestureOverlayView android:eventsInterceptionEnabled相关方法:setEventsInterceptionEnabled(boolean)说明:当手势已经被识别出来时，是否拦截该手势动作 android:fadeDuration说明:当用户画完手势效果淡出的时间 android:fadeEnabled相关方法:setFadeEnabled(boolean)说明: 用户画完之后手势是否自动淡出 android:fadeOffset相关方法:setFadeOffset(long)说明:每两次的间隔时间延长 android:gestureColor相关方法:setGestureColor(int)说明:手势的颜色 android:gestureStrokeAngleThreshold相关方法:setGestureStrokeAngleThreshold(float)说明:角度的最小识别值 android:gestureStrokeLengthThreshold相关方法:setGestureStrokeLengthThreshold(float)说明:长度的最小识别值 android:gestureStrokeSquarenessThreshold相关方法:setGestureStrokeSquarenessTreshold(float)说明:方形的最小识别值 android:gestureStrokeType相关方法:setGestureStrokeType(int)说明:笔画的类型 android:gestureStrokeWidth相关方法:setGestureStrokeWidth(float)说明:笔画的粗细 android:orientation相关方法:setOrientation(int)说明:设置它内容的对其方向 android:uncertainGestureColor相关方法:setUncertainGestureColor(int)说明:确定为手势之前,描绘用户笔画的颜色 NavigationView android.support.design:itemBackground 相关方法:setItemBackgroundResource(int)说明:定义全部Item的背景 android.support.design:itemIconTint 相关方法:setItemIconTintList(ColorStateList)说明:定义全部Item的图片着色 android.support.design:itemTextAppearance 相关方法:setItemTextAppearance(int)说明:定义全部Item的文字风格 android.support.design:itemTextColor 相关方法:setItemTextColor(ColorStateList)说明:定义全部Item的文字颜色 ScrollView android:fillViewport相关方法:setFillViewport(boolean)说明:是否可以充满整个父布局 NestedScrollView android:fillViewport相关方法:setFillViewport(boolean)说明:是否可以充满整个父布局 TimePicker android:timePickerMode说明:组件外观,同样可选值为:spinner和clock(默认) 前者是旧版本的TimePicker ViewAnimator android:animateFirstView相关方法:setAnimateFirstView(boolean)说明:定义ViewAnimation首次显示时是否对当前视图应用动画. android:inAnimation相关方法:setInAnimation(Animation)说明:标识显示视图时使用的动画. android:outAnimation相关方法:setOutAnimation(Animation)说明:标识隐藏视图时使用的动画. ViewFlipper android:autoStart相关方法:setAutoStart(boolean)说明:是否自动播放 android:flipInterval相关方法:setFlipInterval(int)说明:设置View播放的时间间隔 LinearLayout android:baselineAligned相关方法:setBaselineAligned(boolean)说明:是否允许用户调整它内容的基线 android:baselineAlignedChildIndex相关方法:setBaselineAlignedChildIndex(int)说明:当一个线性布局与另一个布局是按基线对齐的一部分，它可以指定其内容的基线对齐方式。 android:divider相关方法:setDividerDrawable(Drawable)说明:设置分隔条 android:gravity相关方法:setGravity(int)说明:设置对齐方式 android:measureWithLargestChild 相关方法:setMeasureWithLargestChildEnabled(boolean)说明:该属性为true的时候,所有带权重的子元素都会具有最大子元素的最小尺寸; 默认为false android:orientation相关方法:setOrientation(int)说明:设置它内容的对其方向 android:weightSum相关方法:setWeightSum(float)说明:权重总和 AppBarLayout android.support.design:expanded相关方法:setExpanded(boolean)说明:是否展开 RadioGroup android:checkedButton相关方法:getCheckedRadioButtonId()说明:设为默认的视图id SearchView android:iconifiedByDefault相关方法:setIconifiedByDefault(boolean)说明:搜索图标是否在输入框内 android:imeOptions相关方法:setImeOptions(int)说明:输入法的回车键的功能 android:inputType相关方法:setInputType(int)说明:输入框文本类型 android:maxWidth相关方法:setMaxWidth(int)说明:最大宽度 android:queryHint相关方法:setQueryHint(CharSequence)说明:输入框默认文本 TabWidget android:divider相关方法:setDividerDrawable(Drawable)说明:设置分隔条 android:tabStripEnabled相关方法:setEnabled(boolean)说明:确定是否在选项卡绘制 android:tabStripLeft相关方法:setLeftStripDrawable(Drawable)说明:被用来绘制选项卡下面的分割线左边部分的可视化对象 android:tabStripRight相关方法:setRightStripDrawable(Drawable)说明:被用来绘制选项卡下面的分割线右边部分的可视化对象 TableLayout android:collapseColumns相关方法:setColumnCollapsed(int,boolean)说明:将TableLayout里面指定的列隐藏，若有多列需要隐藏，请用逗号将需要隐藏的列序号隔开 android:shrinkColumns相关方法:setShrinkAllColumns(boolean)说明:设置指定的列为可收缩的列。当可收缩的列太宽(内容过多)不会被挤出屏幕。当需要设置多列为可收缩时，将列序号用逗号隔开 android:stretchColumns相关方法:setStretchAllColumns(boolean)说明:设置指定的列为可伸展的列，以填满剩下的多余空白空间，若有多列需要设置为可伸展，请用逗号将需要伸展的列序号隔开 TextInputLayout android.support.design:errorEnabled相关方法:setErrorEnabled(boolean)说明:是否开启错误提醒功能 android.support.design:hintAnimationEnabled相关方法:setHintAnimationEnabled(boolean)说明:是否开启提示文字动画 android.support.design:hintTextAppearance相关方法:setHintTextAppearance(int)说明:设置提示文字风格 android:hint相关方法:setHint(CharSequence)说明:设置提示文字 RecyclerView android.support.v7.recyclerview:layoutManager相关方法:setLayoutManager(RecyclerView.LayoutManager)说明:设置布局管理器 RelativeLayout android:gravity相关方法:setGravity(int)说明:设置对齐方式 android:ignoreGravity相关方法:setIgnoreGravity(int)说明:忽略对齐方式的影响 Toolbar android:navigationContentDescription相关方法:setNavigationContentDescription(CharSequence)说明:设置侧滑栏提醒的文字 android:navigationIcon相关方法:setNavigationIcon(int)说明:设置侧滑栏的图标 对子布局的属性 android:layout_width说明:布局整体宽度 android:layout_height说明:布局整体高度 android:layout_marginLeft说明:距离父布局左间距 android:layout_marginTop说明:距离父布局上间距 android:layout_marginRight说明:距离父布局右间距 android:layout_marginBottom说明:距离父布局下间距 android:layout_marginStart说明:控件离父布局开始的位置的距离 android:layout_marginEnd说明:控件离父布局结束的位置的距离 android:layout_margin说明:距离父布局四个方向距离 android:layout_gravity说明:在父布局中的位置 LinearLayout layout_weight说明:剩余空间的分配权重 RelativeLayout layout_alignParentBottom说明:当前控件低端与父控件的低端对齐(重合） layout_alignParentLeft说明:当前控件左端与父控件的左端对齐(重合） layout_alignParentRight说明:当前控件右端与父控件的右端对齐(重合） layout_alignParentTop说明:当前控件上端与父控件的上端对齐(重合） layout_centerHorizontal说明:当前控件位于父控件的横向中间位置（水平方向上的中间） layout_centerInParent说明:当前控件位于父控件的纵横向中间位置（垂直方向上的中间） layout_centerVertical说明:当前控件位于父控件的纵向中间位置（平面上的正中间） layout_above说明:使当前控件位于给出id控件的上方 layout_below说明:使当前控件位于给出id控件的下方 layout_toLeftOf说明:使当前控件位于给出id控件的左侧 layout_toRightOf说明:使当前控件位于给出id控件的右侧 layout_alignBottom说明:使当前控件与给出id控件的底部部重合(注意可用和给出id控件来对齐） layout_alignLeft说明:使当前控件与给出id控件的左边重合 layout_alignRight说明:使当前控件与给出id控件的右边重合 layout_alignTop说明:使当前控件与给出id控件的顶部重合 layout_alignBaseline说明:使当前控件的BaseLine与给出id控件t的BaseLine重合，这个主要用于Label或者其他包含文本的widgets。 TableLayout android:layout_colum说明:设置该控件在TableRow中指定的列。 android:layout_span说明:设置该控件所跨越的列数","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础控件","slug":"Android基础控件","permalink":"https://luoweiguang.github.io/tags/Android基础控件/"}]},{"title":"View概述","slug":"View概述","date":"2016-08-08T14:00:00.000Z","updated":"2017-11-14T17:54:36.367Z","comments":true,"path":"2016/08/08/View概述/","link":"","permalink":"https://luoweiguang.github.io/2016/08/08/View概述/","excerpt":"","text":"自定义View常用方法 方法 说明 onFinishInflate() 当View中所有的子控件 均被映射成xml后触发 onMeasure(int, int) 确定所有子元素的大小 onLayout(boolean, int, int, int, int) 当View分配所有的子元素的大小和位置时触发 onSizeChanged(int, int, int, int) 当view的大小发生变化时触发 onDraw(Canvas) view渲染内容的细节 onKeyDown(int, KeyEvent) 有按键按下后触发 onKeyUp(int, KeyEvent) 有按键按下后弹起时触发 onTrackballEvent(MotionEvent) 轨迹球事件 onTouchEvent(MotionEvent) 触屏事件 onFocusChanged(boolean, int, Rect) 当View获取 或失去焦点时触发 onWindowFocusChanged(boolean) 当窗口包含的view获取或失去焦点时触发 onAttachedToWindow() 当view被附着到一个窗口时触发 onDetachedFromWindow() 当view离开附着的窗口时触发 onWindowVisibilityChanged(int) 当窗口中包含的可见的view发生变化时触发 属性 android:accessibilityLiveRegion相关方法:setAccessibilityLiveRegion(int)说明:设置无障碍服务 表明 View 组件改变时用户是否应该被通知. android:accessibilityTraversalAfter相关方法:setAccessibilityTraversalAfter(int)说明:设置访问性遍历中, 先执行的View组件id| android:accessibilityTraversalBefore相关方法:setAccessibilityTraversalBefore(int)说明:设置访问性遍历中, 后执行的View组件的id android:alpha相关方法:setAlpha(float)说明:设置透明度 android:background相关方法:setBackgroundResource(int)说明:设置背景 android:backgroundTint相关方法:setBackgroundTintList(ColorStateList)说明:设置背景着色 android:backgroundTintMode相关方法:setBackgroundTintMode(PorterDuff.Mode)说明:设置背景着色模式 android:clickable相关方法:setClickable(boolean)说明:是否对点击事件做出响应 android:contentDescription相关方法:setContentDescription(CharSequence)说明:设置组件的内容描述信息 android:contextClickable相关方法:setContextClickable(boolean)说明:是否对点击事件做出响应 android:drawingCacheQuality相关方法:setDrawingCacheQuality(int)说明:半透明绘制缓存的质量 android:duplicateParentState说明:设置为true,则该View由它的直接父类获得绘制状态（焦点、按下）而不是它自身 android:elevation相关方法:setElevation(float)说明:设置z轴深度 android:fadeScrollbars相关方法:setScrollbarFadingEnabled(boolean)说明:不使用滚动条时是否淡出显示 android:fadingEdgeLength相关方法:getVerticalFadingEdgeLength()说明:设置渐变边缘的长度 android:filterTouchesWhenObscured相关方法:setFilterTouchesWhenObscured(boolean)说明:当该View的窗口被其他可见的窗口遮挡时是否过滤触摸事件 android:fitsSystemWindows相关方法:setFitsSystemWindows(boolean)说明:是否根据系统窗口例如状态栏调整View布局 android:focusable相关方法:setFocusable(boolean)说明:是否可以获得焦点 android:focusableInTouchMode相关方法:setFocusableInTouchMode(boolean)说明:触摸模式下是否可以得到焦点 android:foreground相关方法:setForeground(Drawable)说明:设置前景 android:foregroundGravity相关方法:setForegroundGravity(int)说明:设置前景位置 android:foregroundTint相关方法:setForegroundTintList(ColorStateList)说明:设置前景着色 android:foregroundTintMode相关方法:setForegroundTintMode(PorterDuff.Mode)说明:设置前景着色模式 android:hapticFeedbackEnabled相关方法:setHapticFeedbackEnabled(boolean)说明:否为特定动作开启触摸反馈功能(如长按) android:id相关方法:setId(int)说明:设置唯一标识 android:importantForAccessibility相关方法:setImportantForAccessibility(int)说明:设置该View组件对无障碍服务的重要性 android:isScrollContainer相关方法:setScrollContainer(boolean)说明:指定该View是否作为一个可滚动的容器，支持可以通过改变大小收缩整个窗口为输入法腾出空间 android:keepScreenOn相关方法:setKeepScreenOn(boolean)说明:是否强制屏幕常亮 android:layerType相关方法:setLayerType(int,Paint)说明:设置指定层的类型 android:layoutDirection相关方法:setLayoutDirection(int)说明:指定布局绘制的方向 android:longClickable相关方法:setLongClickable(boolean)说明:是否响应长点击事件 android:minHeight相关方法:setMinimumHeight(int)说明:设置视图最小高度 android:minWidth相关方法:setMinimumWidth(int)说明:设置视图最小宽度 android:nextFocusDown相关方法:setNextFocusDownId(int)说明:向下移动焦点时，下一个获取焦点的view的id android:nextFocusForward相关方法:setNextFocusForwardId(int)说明:下一个获取焦点的view的id android:nextFocusLeft相关方法:setNextFocusLeftId(int)说明:向左移动焦点时，下一个获取焦点的view的id android:nextFocusRight相关方法:setNextFocusRightId(int)说明:向右移动焦点时，下一个获取焦点的view的id android:nextFocusUp相关方法:setNextFocusUpId(int)说明:向上移动焦点时，下一个获取焦点的view的id android:onClick说明:点击时，要调用的方法的名称 android:padding相关方法:setPaddingRelative(int,int,int,int)说明:设置上下左右的边距 android:paddingBottom相关方法:setPaddingRelative(int,int,int,int)说明:下边距 android:paddingEnd相关方法:setPaddingRelative(int,int,int,int)说明:右边距 android:paddingLeft相关方法:setPadding(int,int,int,int)说明:左边距 android:paddingRight相关方法:setPadding(int,int,int,int)说明:右边距 android:paddingStart相关方法:setPaddingRelative(int,int,int,int)说明:左边距 android:paddingTop相关方法:setPaddingRelative(int,int,int,int)说明:上边距 android:requiresFadingEdge相关方法:setVerticalFadingEdgeEnabled(boolean)说明:定义滚动时边缘是否褪色 android:rotation相关方法:setRotation(float)说明:旋转度数 android:rotationX相关方法:setRotationX(float)说明:水平旋转度数 android:rotationY相关方法:setRotationY(float)说明:竖直旋转度数 android:saveEnabled相关方法:setSaveEnabled(boolean)说明:在配置改变等情况出现时是否保存view的状态数据 android:scaleX相关方法:setScaleX(float)说明:水平方向缩放比例 android:scaleY相关方法:setScaleY(float)说明:竖直方向缩放比例 android:scrollIndicators相关方法:setScrollIndicators(int)说明:定义了哪些滚动指标时视图可以滚动 android:scrollX说明:水平方向的滚动偏移 android:scrollY说明:竖直方向的滚动偏移 android:scrollbarAlwaysDrawHorizontalTrack说明:是否显示水平滚动条轨道 android:scrollbarAlwaysDrawVerticalTrack说明:是否显示垂直滚动条轨道 android:scrollbarDefaultDelayBeforeFade相关方法:setScrollBarDefaultDelayBeforeFade(int)说明:滚动条在多少毫秒后开始淡出 android:scrollbarFadeDuration相关方法:setScrollBarFadeDuration(int)说明:滚动条在淡出过程需要多少毫秒 android:scrollbarSize相关方法:setScrollBarSize(int)说明:垂直滚动条的宽度和水平滚动条的高度 android:scrollbarStyle相关方法:setScrollBarStyle(int)说明:滚动条的风格和位置 android:scrollbarThumbHorizontal说明:水平滚动条的滑块对应的Drawable对象 android:scrollbarThumbVertical说明:垂直滚动条的滑块对应的Drawable对象 android:scrollbarTrackHorizontal说明:水平滚动条的轨道对应的Drawable对象 android:scrollbarTrackVertical说明:垂直滚动条的轨道对应的Drawable对象 android:scrollbars说明:设置可显示的滚动条 android:soundEffectsEnabled相关方法:setSoundEffectsEnabled(boolean)说明:点击或触摸该view时，是否使用音效 android:stateListAnimator说明:设置状态动画 android:tag说明:设置一个字符串类型的tag值 android:textAlignment相关方法:setTextAlignment(int)说明:设置文本的显示对齐方式 android:textDirection相关方法:setTextDirection(int)说明:设置文本的显示方向 android:transformPivotX相关方法:setPivotX(float)说明:设置该组件旋转时旋转中心的X坐标 android:transformPivotY相关方法:setPivotY(float)说明:设置该组件旋转时旋转中心的Y坐标 android:transitionName说明:对于需要共享的元素分配一个通用的名字 android:translationX相关方法:setTranslationX(float)说明:设置该组件在X方向上的位移 android:translationY相关方法:setTranslationY(float)说明:设置该组件在Y方向上的位移 android:translationZ相关方法:setTranslationZ(float)说明:设置该组件在Z方向上的位移 android:visibility相关方法:setVisibility(int)说明:设置该组件是否可见 其中android:isScrollContainer、android:scrollbarAlwaysDrawHorizontalTrack、android:scrollbarAlwaysDrawVerticalTrack似乎无效 android:accessibilityLiveRegion属性说明 值 说明 none 不通知 polite 通知 assertive 中断当前工作并通知 android:drawingCacheQuality属性说明 值 说明 auto 默认值, 让系统框架决定应该被用于绘图缓存的质量等级 low 低质量, 当设置为低质量时, 绘图缓存使用较低的色彩深度, 这样在渲染一些渐变图像时会丢失一些精度, 但是使用较少的内存 high 高质量, 使用更高的色彩深度, 但是消耗更多的内存 android:importantForAccessibility属性说明 值 说明 auto 让系统决定本 View 组件对于无障碍服务的重要性, 不推荐 yes 该 View 组件对于无障碍服务是重要的 no 该 View 组件对于无障碍服务是不重要的 noHideDescendants 该View组件对于无障碍服务是不重要的,但是该属性的作用范围不包括View树中该View下层的组件 android:layerType属性说明 值 说明 none 不指定 software 软件层 hardware 硬件层 android:scrollbars的属性说明 值 说明 none 不显示滚动条 horizontal 显示水平滚动条 vertical 显示垂直滚动条 android:scrollbarStyle的属性说明 值 说明 insideOverlay 默认值，表示在padding区域内并且覆盖在view上 insideInset 表示在padding区域内并且插入在view后面 outsideOverlay 表示在padding区域外并且覆盖在view上 outsideInset 表示在padding区域外并且插入在view后面 android:scrollbars 值 说明 none 不显示滚动条 horizontal 显示水平滚动条 vertical 显示竖直滚动条 参考资料android中View类的详解","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础控件","slug":"Android基础控件","permalink":"https://luoweiguang.github.io/tags/Android基础控件/"}]},{"title":"系统属性","slug":"系统属性","date":"2016-08-04T14:00:00.000Z","updated":"2017-11-14T17:59:52.049Z","comments":true,"path":"2016/08/04/系统属性/","link":"","permalink":"https://luoweiguang.github.io/2016/08/04/系统属性/","excerpt":"","text":"android.os.BuildBuild 说明 字段方法 无线电固件版本（API14已废弃） Build.RADIO 获取无线电固件版本（API14新增） Build.getRadioVersion() cpu指令集(API21废弃) SBuild.CPU_ABI cpu指令集(API21废弃) Build.CPU_ABI2 主板 Build.BOARD 系统启动程序版本号 Build.BOOTLOADER 系统定制商 Build.BRAND 设备参数 Build.DEVICE 显示屏参数 Build.DISPLAY 唯一编号 Build.FINGERPRINT 硬件名称 Build.HARDWARE Host值 Build.HOST 修订版本列表 Build.ID 硬件制造商 Build.MANUFACTURER 版本(最终用户可见的名称) Build.MODEL 手机产品名 Build.PRODUCT 硬件序列号(API9新增) Build.SERIAL 支持的32位指令集(API21新增) Build.SUPPORTED_32_BIT_ABIS 支持的64位指令集(API21新增) Build.SUPPORTED_64_BIT_ABIS 支持的指令集(API21新增) Build.SUPPORTED_ABIS 描述Build的标签 Build.TAGS 编译时间 Build.TIME Builder类型 Build.TYPE 即字符串”unknown” Build.UNKNOWN User名 Build.USER Build.VERSION 说明 字段方法 系统(API23新增) Build.VERSION.BASE_OS 目前的开发代号 Build.VERSION.CODENAME 源码控制版本号 Build.VERSION.INCREMENTAL 预发行的SDK版本(API23新增) Build.VERSION.PREVIEW_SDK_INT 版本字符串 Build.VERSION.RELEASE SDK版本(已废弃) Build.VERSION.SDK SDK版本 Build.VERSION.SDK_INT 安全补丁(API23新增) Build.VERSION.SECURITY_PATCH Build.VERSION_CODES 名称 编号 Android对应的版本 Build.VERSION_CODES.CUR_DEVELOPMENT 10000 - Build.VERSION_CODES.BASE 1 1.0 Build.VERSION_CODES.BASE_1_1 2 1.1 Build.VERSION_CODES.CUPCAKE 3 1.5 Build.VERSION_CODES.DONUT 4 1.6 Build.VERSION_CODES.ECLAIR 5 2.0 Build.VERSION_CODES.ECLAIR_0_1 6 2.0.1 Build.VERSION_CODES.ECLAIR_MR1 7 2.1x Build.VERSION_CODES.FROYO 8 2.2x Build.VERSION_CODES.GINGERBREAD 9 2.3,2.3.1,2.3.2 Build.VERSION_CODES.GINGERBREAD_MR1 10 2.3.3,2.3.4 Build.VERSION_CODES.HONEYCOMB 11 3.0x Build.VERSION_CODES.HONEYCOMB_MR1 12 3.1x Build.VERSION_CODES.HONEYCOMB_MR2 13 3.2 Build.VERSION_CODES.ICE_CREAM_SANDWICH 14 4.0, 4.0.1, 4.0.2 Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 15 4.0.3, 4.0.4 Build.VERSION_CODES.JELLY_BEAN 16 4.1-4.1.1 Build.VERSION_CODES.JELLY_BEAN_MR1 17 4.2, 4.2.2 Build.VERSION_CODES.JELLY_BEAN_MR2 18 4.3 Build.VERSION_CODES.KITKAT 19 4.4 Build.VERSION_CODES.KITKAT_WATCH 20 4.4W Build.VERSION_CODES.LOLLIPOP 21 5.0 Build.VERSION_CODES.LOLLIPOP_MR 22 5.1 Build.VERSION_CODES.M 23 6.0 android.os.SystemProperty 属性 说明 dalvik.vm.heapsize 虚拟内存大小 dalvik.vm.heapgrowthlimit 单个应用程序最大内存限制，超过将被Kill dalvik.vm.heapstartsize 应用程序分配的初始内存 dalvik.vm.stack-trace-file 堆栈记录调试文件 debug.sf.hw 强制使用GPU渲染 keyguard.no_require_sim 无需SIM卡也可操作手机 net.bt.name 蓝牙网络中显示的名称 persist.sys.timezone 强制时区 ro.build.display.id 显示的标识 ro.build.id 修订版本列表 ro.board.platform 主板平台 ro.build.version.incremental 版本增量 ro.build.version.sdk sdk版本 ro.build.version.codename 版本代号 ro.build.version.release 系统版本 ro.build.date 系统编译的时间 ro.build.date.utc 系统编译的时间(数字版) ro.build.user 编译账户 ro.build.host 编译主机系统 ro.build.tags 编译标签 ro.com.android.dataroaming 漫游设置 ro.com.android.dateformat 默认时间格式 ro.com.google.clientidbase 谷歌客户身份 ro.config.alarm_alert 默认闹铃 ro.config.notification_sound 默认提示音 ro.config.ringtone 默认铃声设置 ro.opengles.version 开放式绘图介面参数 ro.product.model 手机代号 ro.product.brand 手机品牌 ro.product.board 采用的处理器 ro.product.cpu.abi cpu的指令集版本 ro.product.cpu.abilist cpu支持的指令集版本列表 ro.product.cpu.abilist32 cpu支持的32位指令集版本列表 ro.product.cpu.abilist64 cpu支持的64位指令集版本列表 ro.product.device 采用的设备 ro.product.manufacturer 手机制造商 ro.product.name 手机正式名称 ro.product.locale 语言 ro.ril.gprsclass GPRS设置 ro.setupwizard.mode 安装向导模式 ro.sf.lcd_density 显示屏分辨率 ro.telephony.default_network 默认的网络类型 ro.wifi.channels 无线局域网络的通信信道,空白表示自动识别 wifi.interface WIFI界面 java中的System.getProperty() 属性 说明 java.version Java 运行时环境版本 java.vendorJava 运行时环境供应商 java.vendor.url Java 供应商的URL java.home Java安装目录 java.vm.specification.version Java虚拟机规范版本 java.vm.specification.vendor Java虚拟机规范供应商 java.vm.specification.name Java虚拟机规范名称 java.vm.version Java虚拟机实现版本 java.vm.vendor Java虚拟机实现供应商 java.vm.name Java虚拟机实现名称 java.specification.version Java运行时环境规范版本 java.specification.vendor Java运行时环境规范供应商 java.specification.name Java运行时环境规范名称 java.class.version Java类格式版本号 java.class.path Java类路径 java.library.path 加载库时搜索的路径列表 java.io.tmpdir 默认的临时文件路径 java.compiler 要使用的 JIT 编译器的名称 java.ext.dirs 一个或多个扩展目录的路径 os.name 操作系统的名称 os.arch 操作系统的架构 os.version 操作系统的版本 file.separator 文件分隔符 path.separator 路径分隔符） line.separator 行分隔符 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 /proc目录 文件名 说明 acpi 高级配置和电源管理接口 asound 声卡相关的信息 buddyinfo 每个内存区中每个order有多少块可用，和内存碎片问题有关 bus 输入设备信息 cgroups cgroups子系统信息 cmdline 内核启动的命令行 cpuinfo 系统cpu的信息 crypto 内核使用的所有已安装的加密密码及细节 devices 当前挂载的所有软硬件设备(字符设备和块设备)，包括主设备号和设备名称 diskstats 用于显示磁盘、分区和统计信息 dma 驱动程序保留的DMA通道和保留它们的驱动程序名称 execdomains 安全相关的信息 fb 帧缓冲设备信息 filesystems 当前注册了的文件系统列表 fs 文件系统信息 interrupts 当前系统的中断信息 iomem 记录物理地址的分配情况 ioports 被占用的输入/输出地址范围列表 irq 中断请求设备信息 kallsyms 内核符号表信息 kcore 内核核心印象 kmsg 输出内核消息日志 kpagecount 这个文件包含一个64位值，该值表示每个page被映射的次数，通过PFN索引 kpageflags 这个文件包含每一个page的64位的标记集，通过PFN索引。 loadavg 监控cpu平均负载 locks 打开文件上的加锁信息 meminfo 显示物理及虚拟内存使用情况 misc 内核函数misc_register登记的设备驱动程序 modules 加载的内核模块列表 mounts 当前系统所安装的文件系统信息（包括手动安装的） mtrr 系统使用的Memory Type Range Registers (MTRRs) net 网卡设备信息 pagetypeinfo 内存分页信息 partitions 分区信息 sched_debug cpu调度信息 schedstat kernel调度器的统计信息 slabinfo Slab池信息 softirqs 软中断情况 stat 系统简要信息 swaps 对换空间的利用情况 sys 报告各种不同的内核参数 tty tty设备信息 uptime 系统启动时间和系统空闲时间 version 系统内核版本 vmallocinfo vmalloc内存分配信息 vmstat 统计虚拟内存信息 zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用 /proc目录中进程N的信息 文件名 说明 /proc/N/cmdline 进程启动命令 /proc/N/cwd 链接到进程当前工作目录 /proc/N/environ 进程环境变量列表 /proc/N/exe 链接到进程的执行命令文件 /proc/N/fd 包含进程相关的所有的文件描述符 /proc/N/limits 当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取 /proc/N/maps 与进程相关的内存映射信息 /proc/N/mem 指代进程持有的内存，不可读 /proc/N/oom_adj oom_adj相当于一个因子，它值越大，在OOM时更容易被系统kill掉 /proc/N/oom_score 由oom_adj计算出的，用于决定在OOM时是否被kill的是 /proc/N/pagemap 这个文件允许一个用户态的进程查看到每个虚拟页映射到的物理页，每一个虚拟页都包含了一个64位的值 /proc/N/root 链接到进程的根目录 /proc/N/stat 进程的状态 /proc/N/statm 进程使用的内存的状态 /proc/N/status 进程状态信息，比stat/statm更具可读性 /proc/N/task 目录文件，包含由当前进程所运行的每一个线程的相关信息，每个线程的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容； android群英传Android应用获取系统属性Android系统/proc目录详解android /proc/meminfo内存信息Java:System.getProperty()方法大全Linux下/proc目录简介 MemTotal: 2052488 kB 所有可用RAM大小MemFree: 1439916 kB LowFree与HighFree的总和，被系统留着未使用的内存Buffers: 5924 kB 用来给文件做缓冲大小Cached: 350720 kB 被高速缓冲存储器（cache memory）用的内存的大小（等于diskcache minus SwapCache）。SwapCached: 0 kB 被高速缓冲存储器（cache memory）用的交换空间的大小。已经被交换出来的内存，仍然被存放在swapfile中，用来在需要的时候很快的被替换而不需要再次打开I/O端口Active: 280524 kB 在活跃使用中的缓冲或高速缓冲存储器页面文件的大小，除非非常必要，否则不会被移作他用。Inactive: 276248 kB 在不经常使用中的缓冲或高速缓冲存储器页面文件的大小，可能被用于其他途径。Active(anon): 200140 kBInactive(anon): 14604 kBActive(file): 80384 kBInactive(file): 261644 kBUnevictable: 0 kBMlocked: 0 kBSwapTotal: 0 kB 交换空间的总大小SwapFree: 0 kB 未被使用交换空间的大小Dirty: 0 kB 等待被写回到磁盘的内存大小Writeback: 0 kB 正在被写回到磁盘的内存大小AnonPages: 199868 kB 未映射页的内存大小Mapped: 123448 kB 设备和文件等映射的大小Shmem: 14636 kBSlab: 33084 kB 内核数据结构缓存的大小，可以减少申请和释放内存带来的消耗。SReclaimable: 11608 kB 可收回Slab的大小。SUnreclaim: 21476 kB 不可收回Slab的大小（SUnreclaim+SReclaimable＝Slab）。KernelStack: 4280 kBPageTables: 9732 kB 管理内存分页页面的索引表的大小。NFS_Unstable: 0 kB 不稳定页表的大小。Bounce: 0 kBWritebackTmp: 0 kBCommitLimit: 1026244 kBCommitted_AS: 13825784 kBVmallocTotal: 34359738367 kBVmallocUsed: 47400 kBVmallocChunk: 34359624708 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 16320 kBDirectMap2M: 2080768 kB","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"资源详解","slug":"资源详解","date":"2016-08-01T14:00:00.000Z","updated":"2017-11-14T18:07:17.007Z","comments":true,"path":"2016/08/01/资源详解/","link":"","permalink":"https://luoweiguang.github.io/2016/08/01/资源详解/","excerpt":"","text":"Android 中的长度单位 ：像素，物理上的绝对单位\">：像素，物理上的绝对单位\">dp或dip：Density Independent Pixels（密度无关像素）的缩写。以160dpi为基准，1dp=1px sp: 等同于dp，但还会根据用户的字体大小偏好来缩放。使用12sp及以上，不要使用奇数和小数。否者放大缩小会导致精度缺失 in：表示英寸，是屏幕的物理尺寸。每英寸等于 2.54 厘米。 pt：表示点，是屏幕的物理尺寸。大小为 1 英寸的 1/72。 mm：表示毫米，是屏幕的物理尺寸。 其他值像素密度 名称 像素密度范围 比值 mdpi 120dp~160dp 2 hdpi 160dp~240dp 3 xhdpi 240dp~320dp 4 xxhdpi 320dp~480dp 6 xxxhdpi 480dp~640dp 8 PPI(DPI) PPI和DPI虽然是两种概念，但在android中把它们已经混用了，所以指同一概念 安卓对界面元素进行缩放的比例依据的是系统定义的dpi值，而不是实际计算出来的dpi。 屏幕尺寸 名称 范围 small 小于3.55英寸 normal 小于5英寸 large 小于7.5英寸 xlarge 剩余 设置设备支持请看supports-screens res/ 目录内支持的资源目录 目录 资源类型 animator/ 用于定义属性动画的 XML 文件。 anim/ 定义渐变动画的 XML文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。） color/ 用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源 drawable/ 位图文件（.png、.9.png、.jpg、.gif）或编译为Drawable 资源子类型的 XML 文件,详见Android的Drawable mipmap/ 适用于不同启动器图标密度的 Drawable 文件。 layout/ 用于定义用户界面布局的 XML 文件。 请参阅布局资源。 menu/ 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。 raw/ 要以原始形式保存的任意文件。要使用原始InputStream 打开这些资源，请使用资源 ID（即 R.raw.filename）调用 Resources.openRawResource()。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager读取这些文件。 values/ 包含字符串、整型数和颜色等简单值的 XML 文件。其他 res/ 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而目录中的 values/ 文件可描述多个资源。对于此目录中的文件， 元素的每个子元素均定义一个资源由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（类型化数组）。colors.xml：颜色值。dimens.xml：尺寸值。strings.xml：字符串值。styles.xml：样式。详见Android中的值文件 xml/ 可以在运行时通过调用Resources.getXML()读取的任意 XML 文件。各种 XML 配置文件（如可搜索配置）都必须保存在此处。 限定符按照优先级排序: MCC和MNC 语言和地区(Language and region) 布局方向(Layout Direction) 最小宽度(smallestWidth) 可用宽度(Available width) 可用高度(Available height) 屏幕尺寸(Screen size) 屏幕纵横比(Screen aspect) 圆形屏幕(Round screen) 屏幕方向(Screen orientation) UI模式(UI mode) 夜间模式(Night mode) 屏幕像素密度(Screen pixel density) 触屏类型(Touchscreen type) 键盘可用性(Keyboard availability) 主要文本输入法(Primary text input method) 导航键的有效性(Primary non-touch navigation method) 主要的非触屏导航方法(Primary non-touch navigation method) 平台版本（API 级别）Platform Version (API level)() MCC和MNC限定符值MCC460-MCN01 MCC460-MCN02 MCC460-MCN03 说明 移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon 公司，mcc208-mnc00 是指法国的 Orange 公司。 如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。 也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。 另请参阅配置字段 mcc 和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。 语言和地区(Language and region)限定符值en zh-rch zh-rtw 说明 语言通过由两个字母组成的 ISO 639-1 语言代码定义，（可选）后跟两个字母组成的 ISO 3166-1-alpha-2 区域码（前带小写字母“r”）。 这些代码不区分大小写；r 前缀用于区分区域码。 不能单独指定区域。 如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 有关针对其他语言本地化应用的完整指南，请参阅本地化。 另请参阅 locale 配置字段，该字段表示当前的区域设置。 具体值 名称 值 中文（中国） zh-rCN 中文（台湾） zh-rTW 中文（香港） zh-rHK 英语（美国） en-rUS 英语（英国） en-rGB 英文（澳大利亚） en-rAU 英文（加拿大） en-rCA 英文（爱尔兰） en-rIE 英文（印度） en-rIN 英文（新西兰） en-rNZ 英文（新加坡） en-rSG 英文（南非） en-rZA 阿拉伯文（埃及） ar-rEG 阿拉伯文（以色列） ar-rIL 保加利亚文 bg-rBG 加泰罗尼亚文 ca-rES 捷克文 cs-rCZ 丹麦文 da-rDK 德文（奥地利） de-rAT 德文（瑞士） de-rCH 德文（德国） de-rDE 德文（列支敦士登） de-rLI 希腊文 el-rGR 西班牙文（西班牙） es-rES 西班牙文（美国） es-rUS 芬兰文（芬兰） fi-rFI 法文（比利时） fr-rBE 法文（加拿大） fr-rCA 法文（瑞士） fr-rCH 法文（法国） fr-rFR 希伯来文 iw-rIL 印地文 hi-rIN 克罗里亚文 hr-rHR 匈牙利文 hu-rHU 印度尼西亚文 in-rID 意大利文（瑞士） it-rCH 意大利文（意大利） it-rIT 日文 ja-rJP 韩文 ko-rKR 立陶宛文 lt-rLT 拉脱维亚文 lv-rLV 挪威博克马尔文 nb-rNO 荷兰文(比利时) nl-BE 荷兰文（荷兰） nl-rNL 波兰文 pl-rPL 葡萄牙文（巴西） pt-rBR 葡萄牙文（葡萄牙） pt-rPT 罗马尼亚文 ro-rRO 俄文 ru-rRU 斯洛伐克文 sk-rSK 斯洛文尼亚文 sl-rSI 塞尔维亚文 sr-rRS 瑞典文 sv-rSE 泰文 th-rTH 塔加洛语 tl-rPH 土耳其文 vr-rTR 乌克兰文 uk-rUA 越南文 vi-rVN 布局方向(Layout Direction)限定符值ldrtl ldltr 说明 应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr 是指“布局方向从左到右”，这是默认的隐式值。 它适用于布局、图片或值等任何资源。 例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下： res/ layout/ main.xml (默认布局) layout-ar/ main.xml (特定布局，如阿拉伯语) layout-ldrtl/ main.xml (任何“从右至左”的语言，除阿拉伯语，因为语言限定具有更高的优先级。) 注：要为应用启用从右到左的布局功能，必须将 supportsRtl 设置为 “true”，并将 targetSdkVersion 设置为 17 或更高。 此项为API 级别 17 中新增配置。 最小宽度(smallestWidth)限定符值w&lt;N&gt;dp 示例： sw320dp sw600dp sw720dp 说明 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 &lt;N&gt;dp。 例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；设备的 smallestWidth 不会随屏幕方向的变化而改变。 设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。 应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。 此项为 API 级别 13 中新增配置。 另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。 如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多个屏幕开发者指南。 可用宽度(Available width)限定符值w&lt;N&gt;dp 示例： w720dp w1024dp 等等 说明 指定资源应该使用的最小可用屏幕宽度，以 dp 为单位，由 &lt;N&gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。 应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。 此项为 API 级别 13 中新增配置。 另请参阅 screenWidthDp 配置字段，该字段存放当前屏幕宽度。 如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多个屏幕开发者指南。 可用高度(Available height)限定符值h&lt;N&gt;dp 示例： h720dp h1024dp 等等 说明 指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 &lt;N&gt; 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。 应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。 此项为 API 级别 13 中新增配置。 另请参阅 screenHeightDp 配置字段，该字段存放当前屏幕宽度。 如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多个屏幕开发者指南。 屏幕尺寸(Screen size)限定符值small normal large xlarge 说明 注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。 注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 屏幕纵横比(Screen aspect)限定符值long notlong 说明 long：宽屏，如 WQVGA、WVGA、FWVGAnotlong：非宽屏，如 QVGA、HVGA 和 VGA 它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。 另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。 圆形屏幕(Round screen)限定符值round notround 说明 round：圆形的屏幕，如圆型穿戴设备notround：矩形屏幕，如手机或平板电脑此项为 API 级别 23 中新增配置 另请参见isScreenRound()配置方法，从而指示屏幕是否是圆的。 屏幕方向(Screen orientation)限定符值port land 说明 port：设备处于纵向（垂直）land：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 另请参阅 orientation 配置字段，该字段指示当前的设备方向。 UI模式(UI mode)限定符值car desk television appliance watch 说明 car：设备正在车载手机座上显示desk：设备正在桌面手机座上显示television：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互appliance：设备用作不带显示屏的装置watch：设备配有显示屏，戴在手腕上此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。 如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。 如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 UiModeManager 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 夜间模式(Night mode)限定符值night notnight 说明 night：夜间notnight：白天此项为 API 级别 8 中新增配置。 如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 屏幕像素密度(Screen pixel density)限定符值ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi nodpi tvdpi 说明 ldpi：低密度屏幕；约为 120dpi。mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。hdpi：高密度屏幕；约为 240dpi。xhdpi：超高密度屏幕；约为 320dpi。API 级别 8 中新增配置xxhdpi：超超高密度屏幕；约为 480dpi。API 级别 16 中新增配置xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多个屏幕”中的注释）；约为 640dpi。 API 级别 18 中新增配置nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， &gt; 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。API 级别 13 中引入了此限定符。六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。 如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。 注：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。 如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多个屏幕。 触屏类型(Touchscreen type)限定符值notouch finger 说明 notouch：设备没有触摸屏。finger：设备有一个专供用户通过手指直接与其交互的触摸屏。另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。 键盘可用性(Keyboard availability)限定符值keysexposed keyshidden keyssoft 说明 keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。keyssoft：设备已经启用软键盘（无论是否可见）。如果提供了 keysexposed 资源，但未提供 keyssoft 资源，那么只要系统已经启用软键盘，就会使用 keysexposed 资源，而不考虑键盘是否可见。 如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 另请参阅配置字段 hardKeyboardHidden 和 keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。 主要文本输入法(Primary text input method)限定符值nokeys qwerty 12key 说明 nokeys：设备没有用于文本输入的硬按键。qwerty：设备具有标准硬键盘（无论是否对用户可见）。12key：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。 导航键的有效性(Navigation key availability)限定符值navexposed navhidden 说明 navexposed：导航键可供用户使用。navhidden：导航键不可用（例如，位于密封盖子后面）。如果用户显示导航键，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 另请参阅 navigationHidden配置字段，该字段指示导航键是否处于隐藏状态。 主要的非触屏导航方法(Primary non-touch navigation method)限定符值nonav dpad trackball wheel 说明 nonav：除了使用触摸屏以外，设备没有其他导航设施。dpad：设备具有用于导航的方向键。trackball：设备具有用于导航的轨迹球。wheel：设备具有用于导航的方向盘（不常见）。另请参阅 navigation 配置字段，该字段指示可用的导航方法类型。 平台版本（API 级别）(Platform Version (API level))限定符值示例： v3 v4 v7 等等 说明 设备支持的 API 级别。例如，v1 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 Android API 级别文档。 限定符命名规则 可以为单组资源指定多个限定符，并使用短划线分隔 这些限定符必须遵循顺序命名 不能嵌套备用资源目录 值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。 对于每种限定符类型，仅支持一个值。 利用资源提供最佳设备兼容性 提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有 Drawable 资源，则 API 级别 4 设备无法访问 Drawable 资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使 Drawable 资源位于 drawable/ 或 drawable-night/ 中。 寻找最匹配资源 注意事项 屏幕像素密度是唯一一个未因冲突而被淘汰的限定符。 如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像 尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中 根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 限定符的优先顺序比与设备完全匹配的限定符数量更加重要","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"ProgressBar及其子类的使用","slug":"ProgressBar及其子类的使用","date":"2016-07-30T14:00:00.000Z","updated":"2017-11-14T18:08:20.859Z","comments":true,"path":"2016/07/30/ProgressBar及其子类的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/07/30/ProgressBar及其子类的使用/","excerpt":"","text":"ProgressBar及其子类的类图 ProgressBarProgressBar常用属性 XML属性 相关方法 说明 android:indeterminate setIndeterminate() 该属性设置为true，表示不精确显示进度 android:indeterminateBehavior - 当进度达到最大时，不确定模式的表现 android:indeterminateDrawable setIndeterminateDrawable() 设置当选择不精确显示进度时，所绘制的drawable对象 android:indeterminateOnly setIndeterminate() 设置只采用不精确显示进度模式 android:max setMax() 设置进度可以达到的最大值 android:progress setProgress() 设置该进度已完成的进度值 android:progressDrawable setProgressDrawable() 设置该进度条轨道对应的drawable对象 android:secondaryProgress setSecondaryProgress() 设置二级进度已完成的进度值 android:progressTint setProgressTintList() 设置进度条颜色 android:progressBackgroundTint setProgressBackgroundTintList() 设置背景的颜色 android:secondaryProgressTint setSecondaryProgressTintList() 设置二级进度条颜色 android:indeterminateTint setIndeterminateTintList() 设置不精确显示时的颜色 android:progressTintMode setProgressTintMode() 设置进度条颜色模式 android:progressBackgroundTintMode setProgressBackgroundTintMode() 设置背景的颜色模式 android:secondaryProgressTintMode setSecondaryProgressTintMode() 设置二级进度条颜色模式 android:indeterminateTintMode setIndeterminateTintMode() 设置不精确显示时的颜色模式 ProgressBar注意事项 android:indeterminateBehavior必须为repeat或者cycle，repeat表示进度从0重新开始；cycle表示进度保持当前值，并且回到0 使用android:style设置样式 Widget.ProgressBar.Horizontal 水平进度条 Widget.ProgressBar.Small 小环形进度条 Widget.ProgressBar.Large 大环进度条 Widget.ProgressBar.Inverse 普通大小的环形进度条 Widget.ProgressBar.Small.Inverse 小环形进度条 Widget.ProgressBar.Large.Inverse 大环形进度条 使用?android:attr设置样式 style=”?android:attr/progressBarStyle” style=”?android:attr/progressBarStyleHorizontal” style=”?android:attr/progressBarStyleInverse” style=”?android:attr/progressBarStyleLarge” style=”?android:attr/progressBarStyleLargeInverse” style=”?android:attr/progressBarStyleSmall” style=”?android:attr/progressBarStyleSmallInverse” style=”?android:attr/progressBarStyleSmallTitle” 别忘了加?，?表示引用主题资源 要使android:indeterminateTint生效，需时控件是不精确显示状态，且需要设置android:indeterminateTintMode才能生效 ContentLoadingProgressBarContentLoadingProgressBar常用属性 与ProgressBar相同 ContentLoadingProgressBar常见方法 ·onAttachedToWindow()使图像显示 onDetachedFromWindow()使图像隐藏，但图像仍占据空间，当使用android:indeterminateDrawable设置图片时，效果是暂停 show()使图像显示 hide()使图像隐藏，图像不再占据空间 ContentLoadingProgressBar注意事项 与ProgressBar相同 使用onDetachedFromWindow()时应使用onAttachedToWindow()显示 使用hide()时应使用show()显示 RatingBarRatingBar常用属性 XML属性 相关方法 说明 android:numStars setNumStars() 显示的星型数量，必须是一个整形值 android:rating setRating() 默认的评分，必须是浮点类型 android:stepSize setStepSize() 评分的步长 android:isIndicator setIsIndicator() 是否是一个指示器，即用户是否可更改 android:progressTint setProgressTintList() 设置进度条颜色 android:progressBackgroundTint setProgressBackgroundTintList() 设置背景的颜色 android:secondaryProgressTint setSecondaryProgressTintList() 设置二级进度条颜色 RatingBar注意事项 android:isIndicator为true表示不可更改 三种系统样式 style=&quot;?android:attr/ratingBarStyleIndicator&quot; 普通 style=&quot;?android:attr/ratingBarStyle&quot; 大 style=&quot;?android:attr/ratingBarStyleSmall&quot; 小 设置监听``` javaXXX.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener(){ /* @param ratingBar 当前控件 @param rating 当前评分 @param fromUser 是否是用户操作*/@Overridepublic void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser){ }}); - 如何自定义图片 ``` xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@android:id/background&quot; android:drawable=&quot;@drawable/unselect&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@android:id/secondaryProgress&quot; android:drawable=&quot;@drawable/unselect&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@android:id/secondaryProgress&quot; android:drawable=&quot;@drawable/selected&quot;&gt; &lt;/item&gt; &lt;/layer-list&gt; SeekBarSeekBar常用属性 XML属性 相关方法 说明 android:max setMax() 设置进度可以达到的最大值 android:progress setProgress() 设置该进度已完成的进度值 android:secondaryProgress setSecondaryProgress() 设置二级进度已完成的进度值 android:progressDrawable setProgressDrawable() 设置该进度条轨道对应的drawable对象 android:progressTint setProgressTintList() 设置进度条颜色 android:thumb setThumb() 设置滑块图片 android:thumbTint setThumbTintList() 设置滑块颜色 android:thumbOffset setThumbOffset() 设置滑块的偏移量 android:indeterminate setIndeterminate() 该属性设置为true，表示不精确显示进度 android:indeterminateTint setIndeterminateTintList() 设置不精确显示时的颜色 SeekBar注意事项 设置监听 XXX.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { /** *滑动时触发 * @param seekBar 当前控件 * @param progress 当前进度值 * @param fromUser 是否用户操作 */ @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { } /** * 开始滑动时触发 * @param seekBar 当前控件 */ @Override public void onStartTrackingTouch(SeekBar seekBar) { } /** * 滑动结束时触发 * @param seekBar 当前控件 */ @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); 参考资料Android RatingBar自定义替换系统图片","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础控件","slug":"Android基础控件","permalink":"https://luoweiguang.github.io/tags/Android基础控件/"}]},{"title":"Intent详解","slug":"Intent详解","date":"2016-07-29T14:00:00.000Z","updated":"2017-11-14T18:18:13.157Z","comments":true,"path":"2016/07/29/Intent详解/","link":"","permalink":"https://luoweiguang.github.io/2016/07/29/Intent详解/","excerpt":"Intent简介\nIntent为组件的启动提供了一致的编程模型. 无论想要启动的组件是Activity, Service, 还是BroadcastReceiver, 都可以使用Intent封装启动的意图.\n\n如果应用程序只是想启动具有某种特征的组件，并不想和某个具体的组件耦合，则可以通过在intent-filter中配置相应的属性进行处理\n\n","text":"Intent简介 Intent为组件的启动提供了一致的编程模型. 无论想要启动的组件是Activity, Service, 还是BroadcastReceiver, 都可以使用Intent封装启动的意图. 如果应用程序只是想启动具有某种特征的组件，并不想和某个具体的组件耦合，则可以通过在intent-filter中配置相应的属性进行处理 Intent的七大属性 ComponentName Action Category Data Type Extra Flag ComponentName ComponentName(组件名称)用于标识唯一的应用程序组件，即指明了期望的Intent组件，这种对象的名称是由目标组件的类名与目标组件的包名组合而成的。在Intent传递过程中，组件名称是一个可选项，当指定它时，便是显式的Intent消息，我们称为“显示意图”，当不指定它时，Android系统则会根据其他信息及IntentFilter的过滤条件选择相应的组件，我们称之为 “隐式意图”。 ComponetName对象的三种构造方法。 ComponentName(String pkg, String cls) ComponentName(Context pkg, String cls) ComponentName(Context pkg, Class&lt;?&gt; cls) 构造方法其实实质是设置包名与类名，其中包名指的是后面类名所在的那个包，而不是当前应用的包名。如果调用的其他应用的组件，而那个组件必须在清单文件中设置android:exported=true，表示允许其他应用打开，否则会报“ java.lang.SecurityException: Permission Denial: starting Intent…” Intent intent = new Intent(); ComponentName componentName = new ComponentName(\"luoweiguang.github.io.intentdemo2\",\"luoweiguang.github.io.intentdemo2.MainActivity\"); intent.setComponent(componentName); startActivity(intent); 对于包含了过滤器的组件，意味着该组件可以提供给外部的其他应用来使用，它的exported属性默认为true，相反，如果一个组件不包含任何过滤器，那么意味着该组件只能通过指定明确的类名来调用，也就是说该组件只能在应用程序的内部使用，在这种情况下，exported属性的默认值是false。 Action Intent通过定义Action属性（其实就是一段自定义的字符串），这样就可以把Intent与具体的某个Activity分离，实现了解耦。否则，每次跳转，都要写成类似newIntent(MainActivity.this,NextActivity.class)这样的形式，也就是说必须将要跳转的目标Activity的名字写出来，这样的编码其实是“硬编码”，并没有实现松耦合。调用Intent对象的setAction()方法实现页面跳转虽然略微复杂（需要在AndroidManifest.xml文件中配置），但是实现了解耦。 Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件，一个 Intent Filter 可以包含多个 Action。 一条intent-filter元素至少应该包含一个action，否则任何Intent请求都不能和该intent-filter匹配 action区分大小写 CategoryIntent中如果定义了category，那么不管有几个category，它都必须是Intent-filter中已定义的。 隐式调用一个组件时，必须设置一个 android:name=”android.intent.category.DEFAULT”否则会报“android.content.ActivityNotFoundException: No Activity found to handle Intent”错误 Intent隐形调用不能只设置Category，必须设置Action Data与Type&lt;data android:mimeType=&quot;String&quot; android:scheme=&quot;String&quot; android:ssp=&quot;String&quot; android:host=&quot;String&quot; android:port=&quot;int&quot; android:path=&quot;String&quot; android:pathPattern=&quot;String&quot; android:pathPrefix=&quot;String&quot; android:sspPattern=&quot;String&quot; android:sspPrefix=&quot;String&quot;/&gt; data标签由minmeType和URI两部分组成 Type属性用于指定该Data所指定Uri对应的MIME类型，这种类型可以是任何自定义的MIME类型，只要符合abc/xyz格式的字符串即可 如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能用setData再调用setType，因为这两个方法彼此会清除对方的值 当清单文件中设置了data时，intent必须要定义可匹配的data才行，清单文件中可定义多条data，当只要匹配其中一条即可 Extra以Key-value对的形式发送给处理这个Intent对象的组件的附加信息。能够添加类型包括基本数据类型（含基本数据类型的数组）、String(包含数组)、Parcelable（包含数组）、Serializable、Bundle、CharSequence、Intent Intent putExtra(String name, String[] value) Intent putExtra(String name, Parcelable value) Intent putExtra(String name, long value) Intent putExtra(String name, boolean value) Intent putExtra(String name, double value) Intent putExtra(String name, Parcelable[] value) Intent putExtra(String name, char value) Intent putExtra(String name, int[] value) Intent putExtra(String name, int value) Intent putExtra(String name, double[] value) Intent putExtra(String name, short value) Intent putExtra(String name, long[] value) Intent putExtra(String name, boolean[] value) Intent putExtra(String name, short[] value) Intent putExtra(String name, String value) Intent putExtra(String name, Serializable value) Intent putExtra(String name, float[] value) Intent putExtra(String name, Bundle value) Intent putExtra(String name, byte[] value) Intent putExtra(String name, CharSequence value) Intent putExtra(String name, char[] value) Intent putExtra(String name, byte value) Intent putExtras(Intent src) Intent putExtras(Bundle extras) Flagflag属性是一个int值, 用于通知android系统如何启动目标activity, 或者启动目标activity之后应该采取怎样的后续操作. 所有的flag都在Intent类中定义，具体见Intent中关于Activity的Flag 注意事项当我们使用隐式调用时，应该判断以下是否有能匹配的，可以使用以下方法 PackageManager的resolveActivity Intent的resolveActivity PackageManager的queryIntentActivities 参考资料关于ComponentName的使用Android开发教程：理解Intent和Intent FilterAndroid开发艺术探索","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"ImageView及其子类的使用","slug":"ImageView及其子类的使用","date":"2016-07-28T14:00:00.000Z","updated":"2017-11-14T18:22:13.534Z","comments":true,"path":"2016/07/28/ImageView及其子类的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/07/28/ImageView及其子类的使用/","excerpt":"","text":"ImageView及其子类的类图 ImageViewImageView常用属性 XML属性 相关方法 说明 android:adjustViewBounds setAdjustViewBounds() 是否保持宽高比 android:cropToPadding setCropToPadding() android:scaleType=&quot;center&quot;时是否占时padding属性无效 android:maxHeight setMaxHeight() 设置最大高度 android:maxWidth setMaxWidth() 设置最大宽度 android:scaleType setScaleType() 设置图片的填充方式 android:src setImageResource() 设置显示的Drawable对象 android:tint setColorFilter() 将图片渲染成指定的颜色 ImageView注意事项 要使android:maxHeight和android:maxWidth属性生效，需设置android:adjustViewBounds=&quot;true&quot; android:src能使用Drawable也能使用color，但使用color需要指定具体的大小 要使android:src指定的点九图生效，需设置android:scaleType=&quot;fitXY&quot; scaleType分类 属性值 说明 matrix 用矩阵来绘图,通过setImageMatrix方法赋值 fitXY 拉伸图片（不按比例）以填充View的宽高 fitStart 按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的左边 fitCenter 按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的中间 fitEnd 按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的右边 center 按原图大小显示图片，但图片宽高大于View的宽高时，截取图片中间部分显示 centerCrop 按比例扩大图片的size居中显示，使得图片长(宽)等于或大于View的长(宽) centerInside 图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长/宽等于或小于View的长/宽 FloatingActionButtonFloatingActionButton常用属性 XML属性 相关方法 说明 app:backgroundTint setBackgroundTintList 设置FAB的背景颜色。 app:rippleColor setRippleColor 设置FAB点击时的背景颜色。 app:borderWidth - 该属性尤为重要 app:elevation setElevation() 默认状态下FAB的阴影大小。 app:pressedTranslationZ - 点击时候FAB的阴影大小。 app:fabSize - 设置FAB的大小，该属性有两个值，分别为normal和mini，对应的FAB大小分别为56dp和40dp。 src setImageResource 设置FAB的图标，Google建议符合Design设计的该图标大小为24dp。 app:layout_anchor - 设置FAB的锚点，即以哪个控件为参照点设置位置。 app:layout_anchorGravity - 设置FAB相对锚点的位置，值有 bottom、center、right、left、top等。 app:layout_behavior 设置behavior FloatingActionButton注意事项 app:borderWidth如果不设置0dp，那么在4.1的sdk上FAB会显示为正方形，而且在5.0以后的sdk没有阴影效果。所以设置为borderWidth=”0dp” 设置app:layout_behavior来协调控件动作 ImageButtonImageButton常用属性 与ImageView相同 ImageButton注意事项 与ImageView相同 ZoomButtonZoomButton常用属性 与ImageView相同 ZoomButton注意事项 通过setZoomSpeed()设置速度 QuickContactBadgeQuickContactBadge常用属性 与ImageView相同 QuickContactBadge注意事项 assignContactFromPhone()关联到指定电话号码对应的联系人 assignContactFromEmail()关联到指定邮件对应的联系人 assignContactUri()关联到指定Uri对应的联系人 参考资料android CoordinatorLayout使用Android RecyclerView 使用完全解析 体验艺术般的控件codepath教程：浮动操作按钮详解","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础控件","slug":"Android基础控件","permalink":"https://luoweiguang.github.io/tags/Android基础控件/"}]},{"title":"TextView及其子类的使用","slug":"TextView及其子类的使用","date":"2016-07-26T14:00:00.000Z","updated":"2017-11-15T05:17:23.539Z","comments":true,"path":"2016/07/26/TextView及其子类的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/07/26/TextView及其子类的使用/","excerpt":"","text":"TextView及其子类的类图 TextViewTextView常用属性 XML属性 相关方法 说明 android:autoLink setAutoLinkMask(int) 是否将符合指定格式的文本转换为可单击的超链接形式 android:drawableBottom setCompoundDrawablesWithIntrinsicBounds() 在文本的底部绘制指定图像 android:drawableLeft setCompoundDrawablesWithIntrinsicBounds() 在文本的左侧绘制指定图像 android:drawableRight setCompoundDrawablesWithIntrinsicBounds() 在文本的右侧绘制指定图像 android:drawableTop setCompoundDrawablesWithIntrinsicBounds() 在文本的顶部绘制指定图像 android:ellipsize setEllipsize() 设置当显示的文本超过TextView的长度时如何处理 android:gravity setGravity() 设置文本位置 android:lines setLines() 设置文本的行数 android:marqueeRepeatLimit setMarqueeRepeatLimit() 设置marquee动画重复的次数 android:maxLines setMaxLines() 设置该最大行数 android:singleLine setTransformationMethod() 设置该文本是否为单行模式 android:textColor setTextColor() 设置文本颜色 android:textSize setTextSize() 设置文本字体大小 android:textStyle setTypeface() 设置文本框内字体风格，如粗体，斜体 TextView注意事项 用Html类的fromHtml()方法格式化要放到TextView里的文字。（比如实现下划线） 用Spannable或实现它的类，如·SpannableString。 文本末尾显示省略号：android:ellipsize=&quot;end&quot; 实现跑马灯效果android:singleLine=\"true\" android:focusableInTouchMode=\"true\" android:focusable=\"true\" android:marqueeRepeatLimit=\"marquee_forever\" 让跑马灯再次获得焦点android:clickable=&quot;true&quot; ButtonButton常用属性 XML属性 相关方法 说明 android:clickable setClickable() 控件能否点击 android:enabled setEnabled() 控件能否活动 android:textAllCaps setAllCaps() 文本是否大写 Button注意事项 Clickable为false无效 setOnClickListener事件会把setClickable设为true，所以要在setOnClickListener后调用才有效 默认高度问题 Button默认设置了最小高度，所以，在使用自定义backgroud属性时，当paddingTop和paddingBottom设置的值小于这个默认最小高度时，paddingTop和paddingBottom的设置是无效的，此时，解决办法如下，设置minHeight为0：android:minHeight=&quot;0dp&quot; 系统自带阴影问题 在5.0及更高版本系统中，Button等部分控件会自带边界阴影效果，可通过如下属性设置取消默认样式：style=&quot;?android:attr/borderlessButtonStyle&quot; Android Studio下Button的android:textAllCaps默认为true，所以显示的字母为大写，设置为false即可 CheckBoxCheckBox常用属性 XML属性 相关方法 说明 android:checked setChecked() 设置是否选中状态 android:button setButtonDrawable() 设置选中框图片 CheckBox注意事项 去除选中框 android:button=&quot;@null&quot; RadioButtonRadioButton常用属性 XML属性 相关方法 说明 android:checked setChecked() 设置是否选中状态 android:button setButtonDrawable() 设置选中框图片 RadioButton注意事项 去除选中框 android:button=&quot;@null&quot; 不是单选效果 造成原因是未给RadioButton设置id属性 SwitchSwitch常用属性 XML属性 相关方法 说明 android:checked setChecked() 设置是否选中状态 android:thumb setThumbResource() 设置滑块图片 android:track setTrackResource() 设置背景图片 android:textOff setTextOff() 当状态关闭时的文本 android:textOn setTextOn() 当状态打开时的文本 android:switchMinWidth setSwitchMinWidth() 设置最小宽度 ToggleButtonToggleButton常用属性 XML属性 相关方法 说明 android:checked setChecked() 设置是否选中状态 android:textOff setTextOff() 当状态关闭时的文本 android:textOn setTextOn() 当状态打开时的文本 CheckedTextViewCheckedTextView常用属性 XML属性 相关方法 说明 android:checked setChecked() 设置是否选中状态 android:checkMark setCheckMarkDrawable() 设置勾选图片 CheckedTextView注意事项 设置系统的勾选图片为android:checkMark=&quot;?android:attr/listChoiceIndicatorMultiple&quot;不设置将不会显示勾选图片 ChronometerChronometer常用属性 XML属性 相关方法 说明 android:format setFormat() 设置格式化字符串 Chronometer常见方法 getBase() 返回先前由setBase(long)设置的基准时间。 setBase (long base) 设置基准时间 start() 开始计时，只是视图上的改变，不会影响基准时间 stop() 停止计时，只是视图上的不变，不会调整基准时间 Chronometer注意事项 Chronometer的时间为当前时间减去基准时间 设置setBase(SystemClock.elapsedRealtime()开始重新计时 EditTextEditText常用属性 XML属性 相关方法 说明 android:cursorVisible setCursorVisible() 设置光标是否可见 android:digits setKeyListener() 限制使用什么字符 android:drawableBottom setCompoundDrawablesWithIntrinsicBounds() 在文本的底部绘制指定图像 android:drawableLeft setCompoundDrawablesWithIntrinsicBounds() 在文本的左侧绘制指定图像 android:drawableRight setCompoundDrawablesWithIntrinsicBounds() 在文本的右侧绘制指定图像 android:drawableTop setCompoundDrawablesWithIntrinsicBounds() 在文本的顶部绘制指定图像 android:ellipsize setEllipsize() 设置当显示的文本超过TextView的长度时如何处理 android:enabled setEnabled() 设置是否可编辑 android:hint setHint() 文本为空时的提示文本 android:imeOptions setImeOptions() 设置软键盘回车键特殊功能 android:inputType setRawInputType() 设置文本框类型 android:lines setLines() 设置文本的行数 android:selectAllOnFocus setSelectAllOnFocus 当获得焦点时自动选择全部文本 android:singleLine setTransformationMethod() 设置该文本是否为单行模式 android:textCursorDrawable 修改光标图片 EditText注意事项 当设置了某些文本框类型后会导致设置singleLine无效 修改光标位置 setSelection() android:textCursorDrawable使用color无效 AutoCompleteTextViewAutoCompleteTextView常用属性 XML属性 相关方法 说明 android:completionHint setCompletionHint() 设置下拉菜单的提示标题 android:completionThreshold setThreshold() 用户输入多少个字符时会提示 android:dropDownHeight setDropDownHeight 设置下拉菜单高度 android:dropDownWidth setDropDownWidth 设置下拉菜单宽度 MultiAutoCompleteTextViewMultiAutoCompleteTextView常用属性 XML属性 相关方法 说明 android:completionHint setCompletionHint() 设置下拉菜单的提示标题 android:completionThreshold setThreshold() 用户输入多少个字符时会提示 android:dropDownHeight setDropDownHeight 设置下拉菜单高度 android:dropDownWidth setDropDownWidth 设置下拉菜单宽度 MultiAutoCompleteTextView注意事项 使用setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());指定分隔符号，不指定分隔符号将不会有提示 TextClockTextClock常用属性 XML属性 相关方法 说明 android:format12Hour setFormat12Hour() 设置12时制格式 android:format24Hour setFormat24Hour() 设置24时制格式 TextClock注意事项 yy用两位数表示年份，yyyy用四位数表示年份 MMM用英语月份的缩写表示，MMMM用英语月份的完整形式 EE为星期的缩写形式，EEEE为星期的完整形式 dd表示此月的第几天 aa表示上午还是下午 H表示24小时制的小时，h表示12时制的小时 MM或mm表示分钟 ss表示秒","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础控件","slug":"Android基础控件","permalink":"https://luoweiguang.github.io/tags/Android基础控件/"}]},{"title":"ADB命令总结","slug":"ADB命令总结","date":"2016-07-24T14:00:00.000Z","updated":"2017-11-15T06:34:51.455Z","comments":true,"path":"2016/07/24/ADB命令总结/","link":"","permalink":"https://luoweiguang.github.io/2016/07/24/ADB命令总结/","excerpt":"adb与shell命令来源/frameworks/base/cmds\n/system/core/toolbox\n","text":"adb与shell命令来源/frameworks/base/cmds /system/core/toolbox adb简介adb 其实就是 Android Debug Bridge, Android 调试桥的缩写，adb 是一个 C/S 架构的命令行工具，主要由 3 部分组成： 运行在 PC 端的 Client : 可以通过它对 Android 应用进行安装、卸载及调试 运行在 PC 端的 Service : 其管理客户端到 Android 设备上 adb 后台进程的连接adb 服务启动后，Windows 可以在任务管理器中找到 adb.exe 这个进程 运行在 Android 设备上的 adb 后台进程 adb命令管理多台设备adb [-e | -d | -s &lt;设备序列号&gt;] &lt;子命令&gt; -d 发送命令给usb连接的设备-e 发送命令到模拟器设备-s &lt;设备序列号&gt; 发送命令到指定设备 adb 常用命令 devices , 获取设备列表及设备状态H:\\androidDemo\\Test>adb devices List of devices attached 192.168.56.101:5555 device adb get-state , 获取设备的状态 H:\\androidDemo\\Test&gt;adb get-state device 设备的状态有 3 钟，device , offline , unknown device：设备正常连接 offline：连接出现异常，设备无响应 unknown：没有连接设备 adb kill-server , 结束 adb 服务 adb start-server , 启动 adb 服务 adb logcat , 打印 Android 的系统日志 adb bugreport 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误 输出比较多，建议重定向到一个文件中 H:\\androidDemo\\Test&gt;adb bugreport &gt; E:\\\\a.txt adb install [-l -r -t -s -d]&lt; file &gt; , 安装应用 参数 说明 -l 表示应用为受限应用 -r: 替换已经存在的应用 -t 运行安装测试包 -s 安装到SD卡中 -d 允许安装到sd卡中 安装部分软件需要对应的CPU版本才行，不然会报错误。 adb uninstall [-k]&lt; package &gt; , 卸载应用 -k:保持data和cache下的文件 adb pull &lt;remote&gt; &lt;local&gt; , 将 Android 设备上的文件或者文件夹复制到本地 注意权限，复制系统权限的目录下的文件，需要 root ，并且一般的 Android 机 root 之后并不能使用命令去复制，而需要在手机上使用类似于 RE 的文件浏览器，先对系统的文件系统进行挂载为可读写后，才能在手机上复制移动系统文件，这里推荐使用小米手机的开发版本，IUNI 也是不错滴 adb push &lt;local&gt; &lt;remote&gt; , 推送本地文件至Android设备 sdcard 后面的斜杠不能少 adb root , adb remount, 只针对类似小米开发版的手机有用，可以直接已这两个命令获取 root 权限，并挂载系统文件系统为可读写状态 adb reboot , 重启 Android 设备 bootloader , 重启设备，进入 fastboot 模式，同 adb reboot-bootloader 命令recovery , 重启设备，进入 recovery 模式，经常刷机的同学比较熟悉这个模式 adb forward , 将 宿主机上的某个端口重定向到设备的某个端口 adb forward tcp:1314 tcp :8888执行该命令后所有发往宿主机 1314 端口的消息、数据都会转发到 Android 设备的 8888 端口上，因此可以通过远程的方式控制 Android 设备。 adb connect 远程连接 Android 设备 手机、PC处于相同的网络下，手机 root ，安装应用 adbWireless ，启动应用后点击界面中间的按钮：接着运行 adb connect 192.168.1.102 , 即可通过无线的方式连接手机，缺点是速度比较慢 adb get-serialno 获取SN号 adb get-devpath 获取device-path adb backup 参数 说明 无 将应用的数据文件写入到指定的文件，在不指定-f输出目录的情况下，保持在当前目录的”backup.ab” [-f &lt; file &gt;] 指定备份目录 ``[-apk \\ -noapk]`` 是否备份apk文件，默认是noapk ``[-obb \\ -noobb]`` 是否备份obb数据包，默认是noobb ``[-shared \\ -noshared]`` 是否备份SD卡共享内容，默认是noshared [-all] 备份所有已安装的应用 ``[-system \\ -nosystem]`` 是否备份系统应用，-all默认是包括系统应用 &lt; packages... &gt; 备份指定的应用列表 adb restore 将备份文件恢复到手机中 adb shell 常用命令文件操作命令 cd 进入目录 cat [-beflnstuv] [-B bsize] [file...] 查看文件内容 参数 描述 -b 显示行号，但会忽略空行 -e 每一行后面加一个$符号 -n 显示行号 -s 显示行号，连续空行标记为一行 例如： H:\\androidDemo\\Test&gt;adb shell cat -e -B 1 /data/misc/wifi/*.conf df 列出分区列表 du [-H] [-L] [-P] [-a] [-d depth] [-s] [-cghikmnrx] [file...] 查询文件或目录的磁盘使用空间 ls [-a] [-i] [-l] [-n] [-s] 列出目录内容 -a：列出所有文件，包括隐藏文件 -i：输出文件的i节点的索引信息 -l :列出文件的详细信息 -n：用数字的GUID代替名称 -s：输出该文件的大小 grep [file...] 指定文件中搜索特定的内容，并将含有这些内容的行标准输出(windows 请使用findstr替代grep) mkdir -p，-parents 创建目录 参数 说明 -p，–parents 递归创建目录 touch touch [-alm] [-t YYYYMMDD [.HHMMSS]] &lt; file &gt; 创建文件 rm [-f\\|-i][-dPRrvWx]file 删除文件 参数 说明 -f 强制删除文件，系统不提示 -i 交互式删除，删除前提示 -d 改变硬连接数据删成0，删除该文件 -r 强制删除文件夹包括里面的文件 mv [-fiv]source target 移动文件（相当于剪切） 参数 说明 -f 强制移动，若文件已经存在目标则直接覆盖 -i 若目标文件已经存在，会询问是否覆盖 rmdir [-p] directory 删除目录 参数 说明 -p 递归删除目录，只能删除空目录 dd[operand...] dd if =source of=targe 复制文件 其他文件命令 chomd [OPTION] &lt;MODE&gt; &lt;FILE&gt; 文件权限修改|参数|说明||–|–||-R|递归改变文件和目录||-h|不遵循符号连接| md5 file... 查询文件的MD5值 mount [-r] [-w] [-o options] [-t type] device directory 挂载设备信息 umount &lt;path&gt; 卸载分区挂载 cmp[-b][-l][-n count] file1 file2 要指出两个文件是否存在差异 其他命令 wm size 获取屏幕分辨率 dmesg 输出内核信息 wipe wipe system | data | all 擦除分区，恢复出厂设置 adb shell svc wifi [enable|disable]|参数|说明||–|–||enable|打开wifi||disable|关闭wifi| screenrecord &lt;文件保存路径&gt; 屏幕录像(只支持android4.4以上的设备,)使用ctrl+c停止录像 screencap -p 文件保存路径 屏幕截图 ping [option] ipv4 因特网包探测器，用于测试网络连接量的程序 pm Package Manager , 可以用获取到一些安装在 Android 设备上得应用信息,直接运行 adb shell pm 可以获取到该命令的帮助信息 pm list packages [参数] [过滤器] 列出安装在设备上的应用 不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）adb shell pm list package 参数 描述 -s 列出系统应用 -3 列出第三方应用 -f 列出应用包名及对应的apk名及存放位置 -i 列出应用包名及其安装来源 -d 列出禁用的应用的包名 -e 列出可用的应用的包名 命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用参数组合使用，例如，查找三方应用中知乎的包名、apk存放位置、安装来源：[xuxu:~]$ adb shell pm list package -f -3 -i zhihupackage:/data/app/com.zhihu.android-1.apk=com.zhihu.android installer=com.xiaomi.market pm path 列出对应包名的 .apk 位置 [xuxu:~]$ adb shell pm path com.tencent.mobileqqpackage:/data/app/com.tencent.mobileqq-1.apk pm list instrumentation , 列出含有单元测试 case 的应用，后面可跟参数 -f （与 pm list package 中一样），以及 [TARGET-PACKAGE] pm dump , 后跟包名，列出指定应用的 dump 信息，里面有各种信息 adb shell pm dump com.tencent.mobileqq pm install [-lrtsfd] [-i PACKAGE] [PATH] , 安装应用 目标 apk 存放于 PC 端，请用 adb install 安装目标 apk 存放于 Android 设备上，请用 pm install 安装 参数 说明 -l 锁定应用程序 -r 重新安装应用，且保留应用数据 -t 允许测试apk被安装 -i &lt;INSTALLER_PACKAGE_NAME&gt; 指定安装包的包名 -s 安装到sd卡 -f 安装到系统内置存储中（默认安装位置） -d 允许降级安装（同一应用低级换高级） -g 授予应用程序清单中列出的所有权限（只有6.0系统可用） pm uninstall [options] &lt;包名&gt; , 卸载应用，同 adb uninstall 参数 说明 -k 卸载应用且保留数据与缓存（如果不加-k则全部删除） pm clear , 清除应用数据 pm set-install-location , pm get-install-location , 设置应用安装位置，获取应用安装位置 [0/auto]：默认为自动[1/internal]：默认为安装在手机内部[2/external]：默认安装在外部存储 pm list permission-groups 察看已知的权限组 pm list permissions [参数] [权限组]察看所有已知的权限 参数 说明 -g 按组进行列出权限 -f 打印所有信息 -s 简短的摘要 -d 只有危险的权限列表 -u 只有权限的用户将看到列表，用户自定义权限 pm grant &lt;包名&gt; &lt;权限名&gt; 授予应用权限许可。必需android6.0（API级别23）以上的设备 pm revoke &lt;包名&gt; &lt;权限名&gt; 撤销应用权限。必需android6.0（API级别23）以上的设备 pm list features 列出所有硬件相关信息 pm list libraries ：当前设备支持的libs pm list users ：系统上所有的users am am start [参数] &lt;INTENT&gt; , 启动一个 Activity，已启动系统相机应用为例 参数 说明 -D 开启调试模式 -W 等待启动完成 --start-profile &lt;file&gt; 开始分析器和发送结果（文件） –sampling INTERVAL 使用样本分析 间隔：微秒,样品（使用—start-profiler）之间 -P &lt;FILE&gt; 应用空闲下来后，停止profile -R COUNT 重复活动推出&lt;统计&gt;次。每个重复之前，活动将会结束 -S 组织目标应用开始前的活动 –opengl-trace 启用跟踪OpenGL函数 [—user &lt;USER_ID&gt; current] 指定哪些用户运行，如果不指定则使用当前用户 am instrument , 启动一个 instrumentation , 单元测试或者 Robotium 会用到 am monitor , 监控 crash 与 ANR [xuxu:~]$ adb shell am monitorMonitoring activity manager… available commands:(q)uit: finish monitoring** Activity starting: com.android.camera am force-stop , 后跟包名，结束应用 adb shell am kill [参数] &lt;process&gt;,停止后台单个进程 adb shell am kill-all,停止后台所进程 adb shell am startservice [参数] &lt;INTENT&gt; , 启动一个服务 adb shell am stopservice [参数] &lt;INTENT&gt;,停止一个服务 adb shell am broadcast [参数] &lt;INTENT&gt; , 发送一个广播 Intent 说明 Am参数 component 组件名称 格式为：包名/类名 -n action 指定Intent的执行动作，比如调用拨打电话组件 -a data_url 表示与动作要操纵的数据 -d category categary是一个字符串，提供了额外的信息，有关于能够处理这个Intent对象的组件种类 -c extra 传递给Intent的额外数据，以Bundle的形式定义，就是一些键值对 -e mime_type MIME类型 -t flags 各种类型的flag，很多是用来指定Android系统如何启动activity，还有启动了activity后如何对待他 -f package 包名 -p input input text, 发送文本内容，不能发送中文 adb shell input text asd input keyevent, 发送按键事件 adb shell input keyevent 3 常用的键1 –&gt; “KEYCODE_MENU”3 –&gt; “KEYCODE_HOME”4 –&gt; “KEYCODE_BACK” input tap, 对屏幕发送一个触摸事件 前一个为宽，后一个为高 adb shell input tap 1000 800 input swipe, 滑动事件 adb shell input swipe 1000 800 100 800 如果版本不低于 4.4 , 可以模拟长按事件 adb shell input tap 1000 800 1000 800 2000 dumpsys Dumpsys用户系统诊断，它运行在设备上，并提供系统服务状态信息 adb shell dumpsys [system serbices] 包信息查询 adb shell dumpsys package [-h] [-f] [—checkin] [cmd]… 参数 说明 -h 打印帮助信息 -f 打印intent filter的信息 –checkin 打印出已经登记的库、系统功能、安装包 cmd 子命令（可以在-h帮助文档中查看有哪些子命令） cmd子命令 说明 prov[iders] 获取content providers p[ackages] 获取安装包基本信息 s[hared-user] 获取共享用户ID的应用 m[essages] 打印运行时收集的信息 v[erifiers] 打印包校验信息 version 打印数据库版本信息 write 写当前位置 &lt;package.name&gt; 输出给定包的信息 installs 安装会话的详细信息 l[ibraries] 列出已知的共享库 f[ibraries] 列出手机的功能 k[eysets] 列出各个包的Signing KeySets r[esolvers] 获取intent filter perm[issions] 获取权限 pref[erred] 打印包首选项 preferred-xml [—full] 打印包首选项，xml格式打印 activity信息查询 adb shell dumpsys activity [-a] [-c]… 参数 说明 -a 包括所有可用的服务器状态 -c 包括客户端状态 -p 限制输出为给定的包，例如： adb shell dumpsys activity -p com.android.browser -h 打印帮助信息 cmd 子命令 cmd子命令 说明 a[ctivities] activity堆栈状态 r[recents] 最近activity的状态 b[rodacasts] [package_name] [histpry [-s]] 广播状态 i[ntents] [package_name] 挂起的intent状态 p[rocesses] [package_name] 进程状态 o[om] oom管理 perm[issions] url权限授权状态 prov[iders] [comp_spec…] content provider状态 provider [comp_spec] provider客户端状态 s[ervices] [comp_spec…] 服务状态 as[sociations] 跟踪应用程序的关联 service [comp_spec] 服务客户端状态 package [package_name] 给的包的所有状态 all 转储所有的activityes top 转储栈顶的activity write 写入所有挂起状态存储 track-associations 允许会话跟踪 untrack-associations 禁用和明确会话跟踪，命令参数可能也是一个comp_spec 转储的activity 网络信息查询 子命令 说明 命令格式 connectivity 网络连接 adb shell dumpsys connectivity netpolicy 网络策略 adb shell dumpsys netpolicy netstats 网络状态 adb shell dumpsys netstats network_management 网络管理 adb shell dumpsys network_management 其他常用服务信息查询 adb shell dumpsys | findstr DUMP列出所有服务 adb shell dumpsys window w | findstr \\/ | findstr name=获取当前应用的component 子命令 说明 命令格式 meminfo 内存 adb shell dumpsys meminfo cpuinfo CPU adb shell dumpsys cpuinfo gfxinfo 帧率 adb shell dumpsys gfxinfo display 显示 adb shell dumpsys display power 电源 adb shell dumpsys power batterystats 电池状态 adb shell dumpsys batterystats battery 电池 adb shell dumpsys battery alarm 闹钟 adb shell dumpsys alarm location 位置 adb shell dumpsys location telephony.registry 电话信息 adb shell dumpsys telephony.registry wifi wifi信息 adb shell dumpsys wifi notification 通知信息 adb shell dumpsys notification 参考资料Android群英传Android常用adb命令总结Jian_Android命令篇","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"https://luoweiguang.github.io/tags/ADB/"}]},{"title":"Android中的值文件","slug":"Android中的值文件","date":"2016-07-21T14:00:00.000Z","updated":"2017-11-15T05:54:11.144Z","comments":true,"path":"2016/07/21/Android中的值文件/","link":"","permalink":"https://luoweiguang.github.io/2016/07/21/Android中的值文件/","excerpt":"值文件标签汇总\nstring\nstring-array\nbool\ninteger\ninteger-array\ndimen\ndeclare-styleable\neat-comment\nattr\ncolor\nstyle\nitem\nplurals\narray\nfraction\ndrawable\n","text":"值文件标签汇总 string string-array bool integer integer-array dimen declare-styleable eat-comment attr color style item plurals array fraction drawable string字符串是最常见的资源文件,例如: &lt;string name=\"hello\">Hello World&lt;/string> 如果该字符串资源不必本地化，这设置起translatable=&quot;false&quot;,例如: &lt;string name=\"hello\" translatable=\"false\">Hello World&lt;/string> string的特殊字符问题 字符之间的空格用 Space 键是能显示出效果的的，但是字符后面如果需要添加空格，直接 Space 键是不管用的，此时 空格应该用 &#160;来表示 &quot; (&amp;#34; 或 &amp;quot;) &#39; (&amp;#39; 或 &amp;apos;) &amp; (&amp;#38; 或 &amp;amp;) lt(&lt;) (&amp;#60; 或 &amp;lt;) gt(&gt;) (&amp;#62; 或 &amp;gt;) 输入&quot;应该是\\&quot;或者\\&amp;quot;输入&#39;应该是\\&#39;或者\\&amp;apos; 实际值 转译字符 “ \\” ‘ \\’ @ \\@ 字符串资源的引用 xml中引用自定义字符串资源 @string/... java中引用自定义字符串资源R.string.*** xml中引用框架层的字符串资源@android:string/... java中引用框架层的字符串资源android.R.string.*** String通配符格式为%n$s表示字符串，其中n表示第n个要替换的数%n$d表示整数，%n$f表示浮点数 例如： string定义 &lt;string name=\"wildcard_character\" >%1$s今年%2$d岁的概率为%3$f&lt;/string> 代码中设置 String values = getResources().getString(R.string.wildcard_character,\"小明\", 22,99.99); tvStringActivityWildcardCharacter.setText(values); 显示效果 小明今年23岁的概率为99.990000 使用html标签例如实现下划线可以用html的&lt;u&gt;&lt;/u&gt;标签 xml中设置&lt;string name=\"underline\">这是&lt;u>下划线&lt;/u>&lt;/string> 代码中设置tvStringActivityUnderline.setText(Html.fromHtml(\"代码设置\" + \"&lt;u>\"+ \"下划线\" + \"&lt;/u>\")); string-array xml中设置 &lt;string-array name=\"string_array\"> &lt;item >\"妙蛙种子\"&lt;/item> &lt;item >\"小火龙\"&lt;/item> &lt;item >\"杰尼龟\"&lt;/item> &lt;/string-array> 代码中使用 Resources res = getResources(); String[] array = res.getStringArray(R.array.string_array); integer-array &lt;integer-array name=\"integer_array\"> &lt;item>10&lt;/item> &lt;item>20&lt;/item> &lt;item>30&lt;/item> &lt;/integer-array> 代码中使用: Resources res = getResources(); int[] array = res.getIntArray(R.array.integer_array); dimen&lt;dimen name=\"demen1\">18.2dp&lt;/dimen> 获取值的三种方法,以下三种返回的都是转换为px单位的数字 返回”四舍五入”的int值 getResources().getDimensionPixelSize(R.dimen.demen1); 返回舍去小数点后的int值. getResources().getDimensionPixelOffset(R.dimen.demen1); 返回浮点数 getResources().getDimension(R.dimen.demen1); declare-styleable,eat-comment,attr&lt;eat-comment/&gt;去除标签 &lt;declare-styleable name=&quot;declare_styleable&quot;&gt;&lt;/declare-styleable&gt;表示一个属性组 &lt;attr/&gt;表示具体属性，其中format表示属性类型属性类型包括: 值 说明 boolean 布尔类型 color 颜色 dimension 尺寸 enum 枚举 flag 与 float 浮点型 fraction 百分比 integer 整形 reference 引用 string 字符串 其中属性可以通过|表示多条属性。 例子 &lt;!-- =============================================================== --> &lt;!-- 去除掉注释 --> &lt;!-- =============================================================== --> &lt;eat-comment/> &lt;declare-styleable name=\"declare_styleable\"> &lt;!-- 名称 --> &lt;attr name=\"name\" format=\"reference|string\"/> &lt;!-- 性别 --> &lt;attr name=\"sex\"> &lt;!-- 男性 --> &lt;enum name=\"male\" value=\"1\"/> &lt;!-- 女性 --> &lt;enum name=\"female\" value=\"0\"/> &lt;/attr> &lt;!-- 国家 --> &lt;attr name=\"country\"> &lt;!-- 中国 --> &lt;flag name=\"China\" value=\"1\"/> &lt;!-- 美国 --> &lt;flag name=\"America\" value=\"2\"/> &lt;!-- 日本 --> &lt;flag name=\"Japan\" value=\"3\"/> &lt;/attr> &lt;attr name=\"grow_up\" format=\"boolean\"/> &lt;attr name=\"color\" format=\"color\"/> &lt;attr name=\"salary\" format=\"float\"/> &lt;attr name=\"age\" format=\"integer\"/> &lt;attr name=\"fraction\" format=\"fraction\"/> &lt;attr name=\"dimension\" format=\"dimension\"/> &lt;/declare-styleable> 代码中使用 TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.declare_styleable); String name = typedArray.getString(R.styleable.declare_styleable_name); int age = typedArray.getInt(R.styleable.declare_styleable_age,18); int country = typedArray.getInt(R.styleable.declare_styleable_country,0); int sex = typedArray.getInt(R.styleable.declare_styleable_sex,0); boolean grow_up = typedArray.getBoolean(R.styleable.declare_styleable_grow_up,false); int clothescolor = typedArray.getColor(R.styleable.declare_styleable_clothescolor,0xFFFFFFFF); float dimension = typedArray.getDimension(R.styleable.declare_styleable_dimension,50); float salary = typedArray.getFloat(R.styleable.declare_styleable_salary,8888.88f); float fraction = typedArray.getFraction(R.styleable.declare_styleable_fraction,5,10,0.25f); color,bool,integer,drawable,fraction&lt;color name=\"myBackground\">#262626&lt;/color> &lt;bool name=\"bool\">true&lt;/bool> &lt;integer name=\"integer\">18&lt;/integer> &lt;drawable name=\"myDrawable\">@drawable/pikaqiu&lt;/drawable> &lt;drawable name=\"myColor\">#ff0000&lt;/drawable> &lt;fraction name=\"myFraction\">15%&lt;/fraction> stylestyle能够继承于已有的style，有两种继承方法 name设置name属性的名称为:继承的style名称+.+style名称 &lt;style name=\"AppTheme.MyStyle\"> &lt;item name=\"android:background\">@color/myBackground&lt;/item> &lt;/style> parent使用parent属性指定 &lt;style name=\"MyStyle\" parent=\"AppTheme\"> &lt;item name=\"android:background\">@color/myBackground&lt;/item> &lt;/style> itemtype包括anim,animator,array,bool,color,declare-styleable,dimen,drawable,fraction,id,integer,interpolator,menu,mipmap,raw,layout,public,plurals,string,style,transition,xml 例子: &lt;item name=\"myItemString\" type=\"string\" format=\"reference|string\">自定义&lt;/item> &lt;item name=\"myItemId\" type=\"id\" format=\"reference|string\"/> 使用: &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/myItemString\" android:id=\"@id/myItemId\"/> array相当于string-array和integer-array结合 &lt;array name=\"myArray\" > &lt;item>1&lt;/item> &lt;item>2&lt;/item> &lt;item>3&lt;/item> &lt;item>4&lt;/item> &lt;/array> pluralsplurals标签的作用是根据不同的数量返回不同的字符串结果 其中quantity定义数量，有以下几种zero，one，two，few，many，other等 例子： &lt;plurals name=\"numberOfEggs\"> &lt;item quantity=\"one\">There is 1 egg&lt;/item> &lt;item quantity=\"other\">There are %d eggs&lt;/item> &lt;/plurals> 代码中使用 String str = getResources().getQuantityString(R.plurals.numberOfEggs, 21,2); `getQuantityString(@PluralsRes int id, int quantity, Object... formatArgs)有三个参数，第一个为引用plurals，第二个为数量，即根据此参数返回不同的字符串，第三个参数即String的通配符替换，替换字符串中%d，%s,%f等 参考资料深入Android应用开发：核心技术解析与最佳实践android string.xml 转译、特殊字符问题","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"Android的Drawable","slug":"Android的Drawable","date":"2016-07-19T14:00:00.000Z","updated":"2017-11-15T05:24:45.045Z","comments":true,"path":"2016/07/19/Android的Drawable/","link":"","permalink":"https://luoweiguang.github.io/2016/07/19/Android的Drawable/","excerpt":"Drawable汇总\nanimated-rotate\nanimated-selector\nanimated-vector\nanimation-list\nbitmap\nclip\ncolor\ninset\nlayer-list\nlevel-list\nnine-patch\nripple\nrotate\nscale\nselector\nshape\ntransition\nvector\n","text":"Drawable汇总 animated-rotate animated-selector animated-vector animation-list bitmap clip color inset layer-list level-list nine-patch ripple rotate scale selector shape transition vector animated-rotaterotate标签只是将原有的drawable转个角度变成另一个drawable，它是静态的。而animated-rotate则会让drawable不停地做旋转动画。 android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:pivotX 旋转中心的X坐标 android:pivotY 旋转中心的Y坐标 android:visible 设置初始的可见性状态，默认为false animated-selector item android:id 设置状态id 其他请查看selector的状态属性 transition android:fromId 设置起始状态id android:toId 设置结束状态id animated-vector android:drawable 执行动画的vector图片 target android:animation 执行的动画 android:name 执行动画的部件，即vector中group的android:name属性 开始动画 ((Animatable) drawable).start(); animation-list 通过animation-list可以将一系列drawable构建成帧动画，就是将一个个drawable，一帧一帧的播放 android:oneshot属性设置是否循环播放，设为true时，只播放一轮就结束，设为false时，则会轮询播放。 android:duration属性设置该帧持续的时间，以毫秒数为单位。 animation-list对应的Drawable类为AnimationDrawable，要让动画运行起来，需要主动调用AnimationDrawable的start()方法。另外，如果在Activity的onCreate()方法里直接调用start()方法会没有效果，因为view还没有初始化完成是播放不了动画的。 bitmap 图片是最常用的drawable资源，格式包括：png(推荐)、jpg(可接受)、gif(不建议)。用图片资源需要根据不同屏幕密度提供多张不同尺寸的图片，它们的关系如下表： 密度分类 密度值范围 代表分辨率 图标尺寸 图片比例 mdpi 120~160dpi 320x480px 48x48px 1 hdpi 160~240dpi 480x800px 72x72px 1.5 xhdpi 240~320dpi 720x1280px 96x96px 2 xxhdpi 320~480dpi 1080x1920px 144x144px 3 xxxhdpi 480~640dpi 1440x2560px 192x192px 4 本来还有一个ldpi的，但现在这种小屏幕的设备基本灭绝了，所以不需要再考虑适配。如上表所示，一套图片一般需要提供5张不同比例的图片。还好有切图工具，可以让切图变得简单，这里推荐两款：Cutterman和Cut&amp;Slice me，都是Photoshop下的插件，输出支持android、ios和web三种平台。使用切图工具虽然方便了，但还是无法避免一套图片需要提供多张不同尺寸的图片，这会加大安装包的大小。另外，需要对图片做改动时，比如换个颜色，必须更换所有尺寸图片。所以，建议尽量减少引入图片，而通过使用shape、layer-list等自己画，易于修改和维护，也减少了安装包大小，适配性也更好。 android:src 图片资源id android:alpha 设置图片的透明度，取值范围为0.0~1.0之间，0.0为全透明，1.0为全不透明，API Level最低要求是11，即Android 3.0 android:autoMirrored 图片是否需要镜像反转，当布局方向是RTL，即从右到左布局时才有用，API Level 19(Android 4.4)才添加的属性 android:antialias 是否开启抗锯齿.开启后会让图片变得平滑，同时也会在一定程度上降低图片的清晰度，但是这个降低的幅度较低以至于可以忽略，因此抗锯齿选项应该开启。 android:dither 是否开启抖动效果，当图片的像素配置和手机屏幕的像素配置不一致时，开启这个选项可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，一般情况下应该开启 android:filter 是否开启过滤效果，对图片尺寸被拉伸或者压缩时，开启过滤效果可以保持较好的显示效果 android:gravity 设置图片的对齐方式|可选项|含义||–|–||top|图片放于容器顶部，不改变图片大小||bottom|图片放于容器底部，不改变图片大小||left|图片放于容器左边，不改变图片大小||right|图片放于容器右边，不改变图片大小||center|图片放于容器中心位置，包括水平和垂直方向，不改变图片大小||fill|拉伸整张图片以填满容器的整个高度和宽度，默认值||center_vertical|图片放于容器垂直方向的中心位置，不改变图片大小||center_horizontal|图片放于容器水平方向的中心位置，不改变图片大小||fill_vertical|在垂直方向上拉伸图片以填满容器的整个高度||fill_horizontal|在水平方向上拉伸图片以填满容器的整个宽度||clip_vertical|附加选项，裁剪基于垂直方向的gravity设置，设置top时会裁剪底部，设置bottom时会裁剪顶部，其他情况会同时裁剪顶部和底部||clip_horizontal |附加选项，裁剪基于水平方向的gravity设置，设置left时会裁剪右侧，设置right时会裁剪左侧，其他情况会同时裁剪左右两侧| android:mipMap 一种图片相关的处理技术，也叫纹理映射，默认值为false，但API Level最低要求是17，即Android 4.2 android:tileMode 设置图片平铺的方式，取值为下面四种之一： 取值 说明 disable 不做任何平铺，默认设置 repeat 图片重复铺满 mirror 使用交替镜像的方式重复图片的绘制 clamp 复制图片边缘的颜色来填充容器剩下的空白部分，比如引入的图片如果是白色的边缘，那么图片所在的容器里除了图片，剩下的空间都会被填充成白色 android:tileModeX 和tileMode一样设置图片的平铺方式，只是这个属性只设置水平方向的平铺方式，这是API Level 21(Android 5.0)才添加的属性 android:tileModeY 和tileMode一样设置图片的平铺方式，只是这个属性只设置垂直方向的平铺方式，这是API Level 21(Android 5.0)才添加的属性 android:tintMode 着色模式，也是API Level 21(Android 5.0)才添加的属性 clip 使用clip标签可以对drawable进行裁剪，在做进度条时很有用。通过设置level值控制裁剪多少，level取值范围为0~10000，默认为0，表示完全裁剪，图片将不可见；10000则完全不裁剪，可见完整图片。 android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:clipOrientation 设置裁剪的方向|值|说明||–|–||horizontal|在水平方向上进行裁剪，条状的进度条就是水平方向的裁剪在垂直方向上进行裁剪||vertical|在垂直方向上进行裁剪| android:gravity 设置裁剪的位置，可取值如下，多个取值用 | 分隔： 值 说明 top 图片放于容器顶部，不改变图片大小。当裁剪方向为vertical时，会裁掉图片底部 bottom 图片放于容器底部，不改变图片大小。当裁剪方向为vertical时，会裁掉图片顶部 left 图片放于容器左边，不改变图片大小，默认值。当裁剪方向为horizontal，会裁掉图片右边部分 right 图片放于容器右边，不改变图片大小。当裁剪方向为horizontal，会裁掉图片左边部分 center 图片放于容器中心位置，包括水平和垂直方向，不改变图片大小。当裁剪方向为horizontal时，会裁掉图片左右部分；当裁剪方向为vertical时，会裁掉图片上下部分 fill 拉伸整张图片以填满容器的整个高度和宽度。这时候图片不会被裁剪，除非level设为了0，此时图片不可见 center_vertical 图片放于容器垂直方向的中心位置，不改变图片大小。裁剪和center时一样 center_horizontal 图片放于容器水平方向的中心位置，不改变图片大小。裁剪和center时一样 fill_vertical 在垂直方向上拉伸图片以填满容器的整个高度。当裁剪方向为vertical时，图片不会被裁剪，除非level设为了0，此时图片不可见 fill_horizontal 在水平方向上拉伸图片以填满容器的整个宽度。当裁剪方向为horizontal时，图片不会被裁剪，除非level设为了0，此时图片不可见 clip_vertical 附加选项，裁剪基于垂直方向的gravity设置，设置top时会裁剪底部，设置bottom时会裁剪顶部，其他情况会同时裁剪顶部和底部 clip_horizontal 附加选项，裁剪基于水平方向的gravity设置，设置left时会裁剪右侧，设置right时会裁剪左侧，其他情况会同时裁剪左右两侧 设置level呢？android没有提供直接在xml里设置level的属性，这需要通过代码去设置。举例用法如下： ImageView img = (ImageView) findViewById(R.id.img); img.getDrawable().setLevel(5000); //level范围值0~10000 color color标签是drawable里最简单的标签了，只有一个属性：android:color，指定颜色值。这个标签一般很少用，因为基本都可以通过其他更方便的方式定义颜色。 inset 使用inset标签可以对drawable设置边距，其用法和View的padding类似，只不过padding是设置内容与边界的距离，而inset则可以设置背景drawable与View边界的距离。 android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:visible 设置初始的可见性状态，默认为false android:insetLeft 左边距 android:insetRight 右边距 android:insetTop 顶部边距 android:insetBottom 底部边距 android:inset 设置统一边距，会覆盖上面四个属性，但API Level要求为21，即Android 5.0 layer-list layer-list可以将多个drawable按照顺序层叠在一起显示 layer-list可以作为根节点，也可以作为selector中item的子节点。layer-list可以添加多个item子节点，每个item子节点对应一个drawable资源，按照item从上到下的顺序叠加在一起，再通过设置每个item的偏移量就可以看到阴影等效果了。layer-list的item可以通过下面四个属性设置偏移量 android:top 顶部的偏移量 android:bottom 底部的偏移量 android:left 左边的偏移量 android:right 右边的偏移量 level-list 当需要在一个View中显示不同图片的时候，比如手机剩余电量不同时显示的图片不同，level-list就可以派上用场了。level-list可以管理一组drawable，每个drawable设置一组level范围，最终会根据level值选取对应的drawable绘制出来。level-list通过添加item子标签来添加相应的drawable，其下的item只有三个属性： android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:minLevel 该item的最小level值 android:maxLevel 该item的最大level值 item的匹配规则是从上到下的，当设置的level值与前面的item的level范围匹配，则采用。一般item的添加按maxLevel从小到大排序下来，此时minLevel可以不用指定也能匹配到。 设置切换 ImageView img = (ImageView) findViewById(R.id.img); img.getDrawable().setLevel(5000); //level范围值0~10000 nine-patch 使用nine-patch标签可以对点九图片做一些设置处理 android:src 必填项，必须指定点九类型的图片 android:dither 设置是否抖动，图片与屏幕的像素配置不同时会用到，比如图片是ARGB 8888的，而屏幕是RGB565 android:tint 给图片着色，比如图片本来是黑色的，着色后可以变成白色 android:tintMode 着色模式，API Level 21(Android 5.0)才添加的属性 android:alpha 设置图片的透明度，取值范围为0.0~1.0之间，0.0为全透明，1.0为全不透明，API Level最低要求是11 android:autoMirrored 设置图片是否需要镜像反转，当布局方向是RTL，即从右到左布局时才有用，API Level 19(Android 4.4)才添加的属性 ripple 波纹效果 android:color 更改默认的触摸反馈颜色 rotate 使用rotate标签可以对一个drawable进行旋转操作 android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:fromDegrees 起始的角度度数 android:toDegrees 结束的角度度数，正数表示顺时针，负数表示逆时针 android:pivotX 旋转中心的X坐标，浮点数或是百分比。浮点数表示相对于drawable的左边缘距离单位为px，如5; 百分比表示相对于drawable的左边缘距离按百分比计算，如5%; 另一种百分比表示相对于父容器的左边缘，如5%p; 一般设置为50%表示在drawable中心 android:pivotY 旋转中心的Y坐标 android:visible 设置初始的可见性状态，默认为false 要让它可以旋转，还需要设置level值。level取值范围为0~10000，应用到rotate，则与fromDegrees~toDegrees相对应，如上面例子的角度范围为0~180，那么，level取值0时，则旋转为0度；level为10000时，则旋转180度；level为5000时，则旋转90度。因为level默认值为0，所以图片没有转变。那么，我们想转180度，其实可以将fromDegrees设为180，而不设置toDegrees，这样，不用再在代码里设置level图片就可以旋转180了。 scale 使用scale标签可以对drawable进行缩放操作，和clip一样是通过设置level来控制缩放的比例。 android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:scaleHeight 设置可缩放的高度，用百分比表示，格式为XX%，0%表示不做任何缩放，50%表示只能缩放一半 android:scaleWidth 设置可缩放的宽度，用百分比表示，格式为XX%，0%表示不做任何缩放，50%表示只能缩放一半 android:scaleGravity 设置drawable缩放后的位置，取值和bitmap标签的一样，就不一一列举说明了，不过默认值是left android:useIntrinsicSizeAsMinimum 设置drawable原有尺寸作为最小尺寸，设为true时，缩放基本无效，API Level最低要求为11 设置属性 ImageView img = (ImageView) findViewById(R.id.img); img.getDrawable().setLevel(5000); //level范围值0~10000 selector selector标签，可以添加一个或多个item子标签，而相应的状态是在item标签中定义的。定义的xml文件可以作为两种资源使用：drawable和color。作为drawable资源使用时，一般和shape一样放于drawable目录下，item必须指定android:drawable属性；作为color资源使用时，则放于color目录下，item必须指定android:color属性 android:state_enabled: 设置触摸或点击事件是否可用状态，一般只在false时设置该属性，表示不可用状态 android:state_pressed: 设置是否按压状态，一般在true时设置该属性，表示已按压状态，默认为false android:state_selected: 设置是否选中状态，true表示已选中，false表示未选中 android:state_checked: 设置是否勾选状态，主要用于CheckBox和RadioButton，true表示已被勾选，false表示未被勾选 android:state_checkable: 设置勾选是否可用状态，类似state_enabled，只是state_enabled会影响触摸或点击事件，而state_checkable影响勾选事件 android:state_focused: 设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点 android:state_window_focused: 设置当前窗口是否获得焦点状态，true表示获得焦点，false表示未获得焦点，例如拉下通知栏或弹出对话框时，当前界面就会失去焦点；另外，ListView的ListItem获得焦点时也会触发true状态，可以理解为当前窗口就是ListItem本身 android:state_activated: 设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件 android:state_hovered: 设置是否鼠标在上面滑动的状态，true表示鼠标在上面滑动，默认为false，API Level 14及以上才支持 android:enterFadeDuration 状态改变时，新状态展示时的淡入时间，以毫秒为单位，API Level 11及以上才支持 android:exitFadeDuration 状态改变时，旧状态消失时的淡出时间，以毫秒为单位，API Level 11及以上才支持 item是从上往下匹配的，如果匹配到一个item那它就将采用这个item，而不是采用最佳匹配的规则；所以设置默认的状态，一定要写在最后，如果写在前面，则后面所有的item都不会起作用了 关于ListView的ListItem样式，有两种设置方式，一种是在ListView标签里设置android:listSelector属性，另一种是在ListItem的布局layout里设置android:background。但是，这两种设置的结果却有着不同。同时，使用ListView时也有些其他需要注意的地方，总结如下： android:listSelector设置的ListItem默认背景是透明的，不管你在selector里怎么设置都无法改变它的背景。所以，如果想改ListItem的默认背景，只能通过第二种方式，在ListItem的布局layout里设置android:background。当触摸点击ListItem时，第一种设置方式下，state_pressed、state_focused和state_window_focused设为true时都会触发，而第二种设置方式下，只有state_pressed会触发。当ListItem里有Button或CheckBox之类的控件时，会抢占ListItem本身的焦点，导致ListItem本身的触摸点击事件会无效。那么，要解决此问题，有三种解决方案：将Button或CheckBox换成TextView或ImageView之类的控件设置Button或CheckBox之类的控件设置focusable属性为false设置ListItem的根布局属性android:descendantFocusability=”blocksDescendants”第三种是最方便，也是推荐的方式，它会将ListItem根布局下的所有子控件都设置为不能获取焦点。android:descendantFocusability属性的值有三种，其中，ViewGroup是指设置该属性的View，本例中就是ListItem的根布局： beforeDescendants：ViewGroup会优先其子类控件而获取到焦点afterDescendants：ViewGroup只有当其子类控件不需要获取焦点时才获取焦点blocksDescendants：ViewGroup会覆盖子类控件而直接获得焦点 shape shape可以自定义形状，可以定义下面四种类型的形状，通过android:shape属性指定： rectangle: 矩形，默认的形状，可以画出直角矩形、圆角矩形、弧形等 oval: 椭圆形，用得比较多的是画正圆 line: 线形，可以画实线和虚线 ring: 环形，可以画环形进度条 rectangle rectangle是默认的形状，也是用得最多的形状，一些文字背景、按钮背景、控件或布局背景等 solid: 设置形状填充的颜色，只有android:color一个属性 android:color 填充的颜色 padding: 设置内容与形状边界的内间距，可分别设置左右上下的距离 android:left 左内间距 android:right 右内间距 android:top 上内间距 android:bottom 下内间距 gradient: 设置形状的渐变颜色，可以是线性渐变、辐射渐变、扫描性渐变 android:type 渐变的类型 linear 线性渐变，默认的渐变类型 radial 放射渐变，设置该项时，android:gradientRadius也必须设置 sweep 扫描性渐变 android:startColor 渐变开始的颜色 android:endColor 渐变结束的颜色 android:centerColor 渐变中间的颜色 android:angle 渐变的角度，线性渐变时才有效，必须是45的倍数，0表示从左到右，90表示从下到上 android:centerX 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:centerY 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:gradientRadius 渐变的半径，只有渐变类型为radial时才使用 android:useLevel 如果为true，则可在LevelListDrawable中使用 corners: 设置圆角，只适用于rectangle类型，可分别设置四个角不同半径的圆角，当设置的圆角半径很大时，比如200dp，就可变成弧形边了 android:radius 圆角半径，会被下面每个特定的圆角属性重写 android:topLeftRadius 左上角的半径 android:topRightRadius 右上角的半径 android:bottomLeftRadius 左下角的半径 android:bottomRightRadius 右下角的半径 stroke: 设置描边，可描成实线或虚线。 android:color 描边的颜色 android:width 描边的宽度 android:dashWidth 设置虚线时的横线长度 android:dashGap 设置虚线时的横线之间的距离 oval oval用来画椭圆，而在实际应用中，更多是画正圆，比如消息提示，圆形按钮等 size: 设置形状默认的大小，可设置宽度和高度 android:width 宽度 android:height 高度 line line主要用于画分割线，是通过stroke和size特性组合来实现的 只能画水平线，画不了竖线； 线的高度是通过stroke的android:width属性设置的； size的android:height属性定义的是整个形状区域的高度； size的height必须大于stroke的width，否则，线无法显示； 线在整个形状区域中是居中显示的； 线左右两边会留有空白间距，线越粗，空白越大； 引用虚线的view需要添加属性android:layerType，值设为”software”，否则显示不了虚线。 ring shape根元素有些属性只适用于ring类型 android:innerRadius 内环的半径 android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，默认为3，表示内环半径为环的宽度除以3，该值会被android:innerRadius覆盖 android:thickness 环的厚度 android:thicknessRatio 浮点型，以环的宽度比率来表示环的厚度，默认为9，表示环的厚度为环的宽度除以9，该值会被android:thickness覆盖 android:useLevel 一般为false，否则可能环形无法显示，只有作为LevelListDrawable使用时才设为true transition transition其实是继承自layer-list的，只是，transition只能管理两层drawable，另外提供了两层drawable之间切换的方法，切换时还会有淡入淡出的动画效果 transition标签生成的Drawable对应的类为TransitionDrawable，要切换时，需要主动调用TransitionDrawable的startTransition()方法，参数为动画的毫秒数，也可以调用reverseTransition()方法逆向切换。 ((TransitionDrawable)drawable).startTransition(500); //正向切换，即从第一个drawable切换到第二个 ((TransitionDrawable)drawable).reverseTransition(500); //逆向切换，即从第二个drawable切换回第一个 vector vector android:name 定义该drawable的名字 android:width 定义该 drawable 的内部(intrinsic)宽度,支持所有 Android 系统支持的尺寸，通常使用 dp android:height 定义该 drawable 的内部(intrinsic)高度,支持所有 Android 系统支持的尺寸，通常使用 dp android:viewportWidth 定义矢量图视图的宽度，视图就是矢量图 path 路径数据所绘制的虚拟画布 android:viewportHeight 定义矢量图视图的高度，视图就是矢量图 path 路径数据所绘制的虚拟画布 android:tint 定义该 drawable 的 tint 颜色。默认是没有 tint 颜色的 android:tintMode 定义 tint 颜色的 Porter-Duff blending 模式，默认值为 src_in android:autoMirrored 设置当系统为 RTL (right-to-left) 布局的时候，是否自动镜像该图片。比如 阿拉伯语。 android:alpha 该图片的透明度属性 group android:name 定义 group 的名字 android:rotation 定义该 group 的路径旋转多少度 android:pivotX 定义缩放和旋转该 group 时候的 X 参考点。该值相对于 - vector 的 viewport 值来指定的。 android:pivotY 定义缩放和旋转该 group 时候的 Y 参考点。该值相对于 - vector 的 viewport 值来指定的。 android:scaleX 定义 X 轴的缩放倍数 android:scaleY 定义 Y 轴的缩放倍数 android:translateX 定义移动 X 轴的位移。相对于 vector 的 viewport 值来指定的。 android:translateY 定义移动 Y 轴的位移。相对于 vector 的 viewport 值来指定的。 path android:name 定义该 path 的名字，这样在其他地方可以通过名字来引用这个路径 android:pathData 和 SVG 中 d 元素一样的路径信息。 android:fillColor 定义填充路径的颜色，如果没有定义则不填充路径 android:strokeColor 定义如何绘制路径边框，如果没有定义则不显示边框 android:strokeWidth 定义路径边框的粗细尺寸 android:strokeAlpha 定义路径边框的透明度 android:fillAlpha 定义填充路径颜色的透明度 android:trimPathStart 从路径起始位置截断路径的比率，取值范围从 0 到1 android:trimPathEnd 从路径结束位置截断路径的比率，取值范围从 0 到1 android:trimPathOffset 设置路径截取的范围 android:strokeLineCap 设置路径线帽的形状，取值为 butt, round, square. android:strokeLineJoin 设置路径交界处的连接方式，取值为 miter,round,bevel. android:strokeMiterLimit 设置斜角的上限注：当strokeLineJoin设置为 “miter” 的时候， 绘制两条线段以锐角相交的时候，所得的斜面可能相当长。当斜面太长，就会变得不协调。strokeMiterLimit 属性为斜面的长度设置一个上限。这个属性表示斜面长度和线条长度的比值。默认是 10，意味着一个斜面的长度不应该超过线条宽度的 10 倍。如果斜面达到这个长度，它就变成斜角了。当 strokeLineJoin 为 “round” 或 “bevel” 的时候，这个属性无效。 参考资料Android样式的开发VectorDrawable 详解Android开发艺术探索Android群英传","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"AndroidManifest.xml文件详解","slug":"AndroidManifest.xml文件详解","date":"2016-07-16T14:00:00.000Z","updated":"2017-11-15T06:23:06.938Z","comments":true,"path":"2016/07/16/AndroidManifest.xml文件详解/","link":"","permalink":"https://luoweiguang.github.io/2016/07/16/AndroidManifest.xml文件详解/","excerpt":"","text":"AndroidManifest.xml结构&lt;?xmlversion=\"1.0\"encoding=\"utf-8\"?> &lt;manifest> &lt;application> &lt;activity> &lt;intent-filter> &lt;action/> &lt;category/> &lt;data/> &lt;/intent-filter> &lt;meta-data/> &lt;/activity> &lt;activity-alias> &lt;intent-filter> &lt;action/> &lt;category/> &lt;data/> &lt;/intent-filter> &lt;meta-data/> &lt;/activity-alias> &lt;service> &lt;intent-filter> &lt;action/> &lt;category/> &lt;data/> &lt;/intent-filter> &lt;meta-data/> &lt;/service> &lt;receiver> &lt;intent-filter> &lt;action/> &lt;category/> &lt;data/> &lt;/intent-filter> &lt;meta-data/> &lt;/receiver> &lt;provider> &lt;grant-uri-permission/> &lt;path-permission/> &lt;meta-data/> &lt;/provider> &lt;meta-data/> &lt;uses-library/> &lt;/application> &lt;compatible-screens/> &lt;instrumentation/> &lt;library/> &lt;original-package/> &lt;package-verifier/> &lt;permission/> &lt;permission-tree/> &lt;permission-group/> &lt;protected-broadcast/> &lt;resource-overlay/> &lt;supports-screens/> &lt;supports-gl-texture/> &lt;uses-sdk/> &lt;uses-configuration/> &lt;uses-feature/> &lt;uses-permission/> &lt;uses-permission-sdk-23/> &lt;upgrade-key-set/> &lt;/manifest> manifest&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"\" android:sharedUserId=\"string\" android:sharedUserLabel=\"string resource\" android:versionCode=\"integer\" android:versionName=\"string\" android:installLocation=[\"auto\" | \"internalOnly\" | \"preferExternal\"] android:revisionCode=\"integer\"> &lt;/manifest> 这个元素是AndroidManifest.xml文件的根元素。它必须包含一个元素，并且必须要指定xmlns:android和package属性 xmlns:android 定义android命名空间，一般为http://schemas.android.com/apk/res/android，这样使得Android中各种标准属性能在文件中使用，提供了大部分元素中的数据。 package 这个属性给应用程序定义了一个完整的Java样式的包名。这个名称应该是唯一的。名称中可以包含大写或小写字母、数字以及下划线（‘_’）。但是包名的每段都只能用字母开始。 应该使用所拥有的互联网域名作为基本的包名，以避免与其他开发者的冲突。例如，由Google发布的应用程序的包名都用com.google开始。在发布应用程序时永远不要使用com.example命名空间。 包名用于唯一的标识应用程序。它还是应用程序进程的默认名称（看元素的process属性）和Activity的默认亲缘任务（请看&lt;activity&gt;元素的taskAffinity属性）。 警告：应用程序一旦发布，就不能够改变它的包名称了。包名定义了应用程序的标识，因此如果改变它，那么它就会被认为是不同的应用程序，并且之前版本的用户就不能够把应用升级到新版本。 sharedUserId 这个属性定义了一个Linux用户ID的名称，这个名称能够跟其他应用程序共享。默认情况下，Android会给它的每个应用程序都分配一个唯一的用户ID。但是，如果有两个或更多的应用程序把这个属性都设置了相同的值，那么它们将共享这个相同的ID—具有相同的数字签名。拥有相同用户ID的应用程序能够访问彼此的数据，并且如果期望，它们也可运行在相同的进程中。 详见：【AndroidManifest.xml详解】Manifest属性之sharedUserId、sharedUserLabel sharedUserLabel 这个属性给共享的用户ID定义了一个用户可读的标签。这个标签必须用字符串资源来设置，不能使用原生的字符串。 只有在sharedUserId属性被设置，这个属性才有意义。 versionCode 这个属性定义一个内部版本号，它仅用于判断一个版本是否比另一个版本新，数字越大表明版本越新。这个版本号不显示给用户，显示给用户的版本号要用versionName属性设置。 它的属性值必须是一个整数，如100。你可以按照自己的想法来定义它，只要保持后续版本号的数字更大。例如，它可以是一个版本号；也可以把x.y格式中的版本数字转换成一个由x和y分别编码的16位整数，x在低8位，y在高8位；也可以在每次发布版本时简单的增加数字的大小。 versionName 这个属性用于设置一个显示给永的版本号。属性值可以是原生的字符串，也可以引用一个字符串资源。这个字符串除了显示给用户之外，没有其他用途。而versionCode属性却拥有内部使用的版本号。 installLocation 这个属性用于设置应用程序默认的安装位置。 用下表中的关键词来设置属性值。 值 说明 internalOnly 应用程序必须只被安装在内部设备存储器上。如果设置这个值，应用程序永远不会被安装在外部存储器上。如果内部存储空间不足，那么系统不会安装这个应用程序。如果没有定义android:installLocation属性，就会使用这个值作为默认值。 auto 应用程序可以安装在外部存储器上，但是，默认情况下，系统会把应用程序安装在内部存储器上。如果内部存储空间不足，那么系统会把应用程序安装在外部存储器上。一旦安装，用户能够通过系统设置在内外存储器之间来移动应用程序。 preferExternal 应用程序偏好安装在外部存储器上（SD卡）。系统并不保证恪守这一个规则。如果外部存储器不可用或空间不足，或者应用程序使用了forward-locking机制（这种机制不支持外部存储），那么应用程序就可以安装在内部存储器上。一旦安装，用户能够通过系统设置在内外存储器之间移动应用程序。 警告：如果应用程序使用的Google Play的复制保护功能，那么它就不能被安装在设备的SD卡上。但是，如果使用Google Play的应用程序许可，那么它就能够被安装在内部或外部存储器上，包括SD卡。 注意：默认情况下，应用程序会被安装在内部存储器上，除非把这个属性值定义为auto或preferExternal，应用程序才能够被安装在外部存储器上。当应用程序被安装在外部存储器上的时候： .apk文件被保存在外部存储器上，但是任何应用程序数据（如数据库）依然被保存在内部设备存储器上； 用一个key把存储器中保存的.apk文件加密，只允许应用程序在安装它的设备上运行。用户不能把安装在SD卡上应用程序转移到另一个设备的SD卡上，虽然在一个设备上能够使用多个SD卡。 在用户要求的时候，应用程序能够被转移到内部存储器上。 用户也可以要求把应用程序从内部存储器移动到外部存储器上。但是，如果这个属性被设置为internalOnly，那么系统不允许用户把应用程序转移到外部存储器上。 这个属性在API Level 8中被引入。 revisionCode android:revisionCode表示该软件的修改版本号，对用户是可见的，它必须是一个int型的整数，它的大小代表该软件版本升级过多少次，因此每次发布新版本该值都会+1，如Android:versionCode = ”5″ ,代表此软件已经发布过5次了。 Application&lt;application android:allowClearUserData=[\"true\" | \"false\"] android:allowTaskReparenting=[\"true\" | \"false\"] android:banner=\"drawable resource\" android:backupAgent=\"string\" android:debuggable=[\"true\" | \"false\"] android:description=\"string resource\" android:enabled=[\"true\" | \"false\"] android:hasCode=[\"true\" | \"false\"] android:hardwareAccelerated=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:isGame=[\"true\" | \"false\"] android:killAfterRestore=[\"true\" | \"false\"] android:largeHeap=[\"true\" | \"false\"] android:label=\"string resource\" android:logo=\"drawable resource\" android:manageSpaceActivity=\"string\" android:name=\"string\" android:permission=\"string\" android:persistent=[\"true\" | \"false\"] android:process=\"string\" android:restoreAnyVersion=[\"true\" | \"false\"] android:requiredAccountType=\"string\" android:restrictedAccountType=\"string\" android:supportsRtl=[\"true\" | \"false\"] android:taskAffinity=\"string\" android:testOnly=[\"true\" | \"false\"] android:theme=\"resource or theme\" android:uiOptions=[\"none\" | \"splitActionBarWhenNarrow\"] android:usesCleartextTraffic=[\"true\" | \"false\"] android:vmSafeMode=[\"true\" | \"false\"]> &lt;/application> 这个元素用于应用程序的声明。它包含了每个应用程序组件所声明的子元素，并且还有能够影响所有组件的属性。其中的很多属性（如icon、label、permission、process、taskAffinity和allowTaskReparenting）会给组件元素中对应的属性设置默认值。其他的给是应用程序整体设置的值（如debuggable、enabled、description、allowClearUserData），并且这些属性值不能被组件的属性所覆盖。 android:allowTaskReparenting 当一个与当前任务有亲缘关系的任务被带到前台时，用这个属性来指定应用程序中定义的Activity能否从他们当前的任务中转移到这个有亲缘关系的任务中。如果设置为true，则能够转移，如果设置为false，则应用程序中的Activity必须保留在它们所在的任务中。默认值是false。&lt;activity&gt;元素有它们自己的allowTaskReparenting属性，它能够覆盖&lt;application&gt;元素中的设置。 android:allowBackup 当 allowBackup 标志为 true 时，用户即可通过 adb backup 和 adb restore 来进行对应用数据的备份和恢复,此属性的默认值是true。 android:backupAgent 这个属性用于定义应用程序备份代理的实现类的名称，这个类是BackupAgent类的一个子类。它的属性值应该是完整的Java类的名称（如，com.example.project.MyBackupAgent）。但是，也可以使用用”.”符号开头的简称（如，.MyBackupAgent），系统会把&lt;manifest&gt;元素中指定的包名追加到”.”符号的前面。 android:debuggable 这个属性用于指定应用程序是否能够被调试，即使是以用户模式运行在设备上的时候。如果设置为true，则能够被调试，否则不能调试，默认值是false。 android:description 这个属性用于定义应用程序相关的用户可读文本，它要比应用程序标签更长、更详细。它的的值必须被设置成一个字符串资源的引用。跟label属性不一样，label属性可以使用原生的字符串。这个属性没有默认值。 android:enabled 这个属性用于指定Android系统能否实例化应用程序组件。如果设置为true，这个可以实例化其组件，否则不能够实例化。如果这个属性被设置为true，那么就会使用每个组件自己enabled属性的设置来判断其是否能够被实例化。如果这个属性被设置为false，它会覆盖其所有组件自己指定的值，应用程序中的所有组件都会被禁用。 默认值是true。 android:hasCode 这个属性用于设置应用程序是否包含了代码，如果设置为true，则包含代码，否则不包含任何代码。在这个属性被设置为false的时候，系统在加载组件的时候不会试图加载任何应用程序的代码。默认值是true。 如果应用程序没有使用任何应用内置组件类以外的组件，那么这个应用程序就不会有任何自己的代码，像使用AliasActivity类的Activity，是很少发生的。 android:hardwareAccelerated 这个属性用于设置能够给应用程序中的所有Activity和View对象启用硬件加速渲染。如果设置为true，则应该启用，如果设置为false，则不会启用。默认值是false。 从Android3.0开始，应用程序可以使用硬件加速的OpenGL渲染器，来改善很多共同的2D图形操作的性能。当硬件加速渲染被启动的时候，在Canvas、Paint、Xfermode、ColorFilter、Shader和Camera中的大多数操作都会被加速。这样会使动画、滚动更加平滑，并且会改善整体的响应效果，即使应用程序没有明确的使用框架的OpenGL类库。 要注意的是，不是所有的OpenGL 2D操作都会被加速。如果启用了硬件加速渲染器，就要对应用程序进行测试，以确保使用渲染器时不发生错误。 android:icon 这个属性用于设置应用程序的整个图标，以及每个应用组件的默认图标。对于&lt;activity&gt;、&lt;activity-alias&gt;、&lt;service&gt;、&lt;service&gt;、&lt;receiver&gt;和&lt;provider&gt;元素，请看它们各自的icon属性。 设置这个属性时，必须要引用一个包含图片的可绘制资源（例如，“@drawable/icon”）。没有默认的图标。 android:isGame 该应用程序是否是一个游戏，默认为false android:killAfterRestore 这个属性用于指定在全系统的恢复操作期间，应用的设置被恢复以后，对应的问题程序是否应该被终止。单包恢复操作不会导致应用程序被关掉。全系统的复原操作通常只会发生一次，就是在电话被首次建立的时候。第三方应用程序通常不需要使用这个属性。 默认值是true，这意味着在全系统复原期间，应用程序完成数据处理之后，会被终止。 android:label 这个属性用于设置应用程序整体的用户可读的标签，并也是每个应用程序组件的默认标签。对于&lt;activity&gt;、&lt;activity-alias&gt;、&lt;service&gt;、&lt;receiver&gt;和元素，请看它们各自的label属性。 设置这个属性值时，应该引用一个字符串资源。以便它能够跟用户界面中的其他字符串一样能够被本地化。但是为了应用程序开发的便利，也能够用原生的字符串来设置。 android:logo 这个属性用于给整个应用程序设置一个Logo，而且它也是所有Activity的默认Logo。 设置这个属性时，必须要引用一个包含图片的可绘制资源（如：“@drawable/logo”）。没有默认的Logo。 android:manageSpaceActivity 这个属性定义了一个完整的Activity子类的名字，系统能够把这个名字加载到由用户管理被应用程序所占用的设备上的内存。这个Activity也应该用&lt;activity&gt;元素来声明。 android:name 这整个属性用完整的Java类名，给应用程序定义了一个Application子类的实现。当应用程序进程被启动时，这个类在其他任何应用程序组件被实例化之前实例化。 这个子类实现是可选的，大多数应用程序不需要一个子类的实现。如果没有实现自己的子类，Android系统会使用基本的Application类的一个实例。 android:permission 这个属性定义了一个权限，为了跟应用程序进行交互，客户端必须要有这个权限。这个属性是为给所有的应用程序组件设置权限提供了便利的方法。它能够被独立组件所设置的permission属性所覆盖。 android:persistent 这个属性用户设置应用程序是否应该时刻保持运行状态，如果设置为true，那么就保持，否则不保持。默认值是false。普通的应用程序不应该设置这个属性，持久运行模式仅用于某些系统级的应用程序。 android:process 这个属性用于定义一个进程名称，应用程序的所有组件都应该运行在这个进程中。每个组件都能够用它自己process属性的设置来覆盖这个元素中的设置。 默认情况下，当应用程序的第一个组件需要运行时，Android系统就会给这个应用程序创建一个进程。然后，应用中的所有组件都运行在这个进程中。默认的进程名是跟元素中设置的包名进行匹配的。 通过设置这个属性，能够跟另外一个应用程序共享一个进程名，能够把这两个应用程序中的组件都安排到同一个进程中运行—但是仅限于这两个应用程序共享一个用户ID，并且带有相同的数字证书。 如果这个进程名称用“：”开头，那么在需要的时候，就会给应用程序创建一个新的、私有的进程。如果进程名用小写字符开头，就会用这个名字创建一个全局的进程，这个全局的进程能够被其他应用程序共享，从而减少资源的使用。 android:restoreAnyVersion 设置这个属性表示应用程序准备尝试恢复任何备份的数据集，即使备份比设备上当前安装的应用程序的版本要新。这个属性设置为true，即使是在版本不匹配而产生数据兼容性提示的时候，也会允许备份管理来恢复备份的数据，所以要谨慎使用。 这个属性的默认值是false。 android:taskAffinity 这个属性给应用的所有的Activity设置了一个亲缘关系名，除了那些用它们自己的taskAffinity属性设置不同亲缘关系的组件。 默认情况下，应用程序中的所有Activity都会共享相同的亲缘关系，亲缘关系的名称跟由&lt;manifest&gt;元素设置的包名相同。 android:theme 这个属性给应用程序中所有的Activity设置默认的主题，属性值要引用一个样式资源。每个独立的Activity的主题会被它们自己的theme属性所覆盖。 android:uiOptions 这个属性设置了Activity的UI的额外选项。它必须是下表中的一个值： 值 说明 none 默认设置，没有额外的UI选项。 splitActionBarWhenNarrow 在水平空间受到限制的时候，会在屏幕的底部添加一个用于显示ActionBar中操作项的栏，例如：在纵向的手持设备上。而不是在屏幕顶部的操作栏中显示少量的操作项。它会把操作栏分成上下两部分，顶部用于导航选择，底部用于操作项目。这样就会确保可用的合理空间不仅只是针对操作项目，而且还会在顶部给导航和标题留有空间。菜单项目不能被分开到两个栏中，它们要显示在一起。 intent-filter&lt;intent-filter android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:priority=&quot;integer&quot;&gt; . . . &lt;/intent-filter&gt; 这个元素用于指定Activity、Service或Broadcast Receiver能够响应的Intent对象的类型。Intent过滤器声明了它的父组件的能力—Activity或Service所能做的事情和Broadcast Receiver所能够处理的广播类型。它会打开组件来接收它所声明类型的Intent对象，过滤掉那些对组件没有意义的Intent对象请求。 过滤器的大多数内容是通过&lt;action&gt;、&lt;category&gt;和&lt;data&gt;子元素来描述的。 android:icon 当组件要把过滤器所具有的能力展示给用户时，会使用这个属性所设置的图标来表示它的父组件（Activity、Service或Broadcast Receiver）。 这个属性必须要引用一个包含图片定义的可绘制资源。默认值是由父组件的icon属性设置的。如果父组件没有指定一个图标，那么默认值就会使用&lt;application&gt;元素所设置的icon。 android:label 这个属性用于给其父组件设置一个用户可读的标签。这个标签不是有其父组件设置的那个，在组件要把过滤器所具有的能力展示给用户的时候，要使用这个属性值。 这个属性值应该引用一个字符串资源，以便它能够像用户界面中的其他字符串一样，能够被本地化。但是，为了开发应用程序的便利，也可以使用原生的字符串。 这个属性的默认值是有它的父组件提供的。如果父组件没有指定一个标签，那么默认值就会使用由元素的所设置的标签。 android:priority 这个属性用于给过滤器设置一个优先级。其父组件能够通过优先级来依次处理过滤器所描述类型的Intent对象。这个属性对Activity和Broadcast Receiver对象有意义： 它提供了Activity能够如何响应跟过滤器匹配的Intent对象请求的信息（相对与其他的也能响应这个Intent请求的Activity）。当一个Intent对象请求能够被多个带有不同优先级的Activity处理时，Android系统只考虑把高优先级的Intent过滤器作为潜在的Intent对象请求目标。 它控制了Broadcast Receiver执行接收广播消息的顺序。高优先级的过滤器会优先调用。（这个顺序只应用与同步消息，对于异步消息会忽略优先级的设置。） 只有真正想要给接收广播消息的过滤器施加一个特定顺序，或者要强制Android来应用另外一个Activity，才会使用这个属性。 这个属性值必须是一个整数，如：100，数字越大，优先级越高。 meta-data&lt;meta-data android:name=\"string\" android:resource=\"resource specification\" android:value=\"string\"/> 这个元素用name-value对的格式给其父组件提供任意可选的数据。一个组件元素能够包含任意多个&lt;meta-data&gt;子元素，所有这些元素中定义的值会被收集到一个Bundle对象中，并且提供给组件的PackageItemInfo.metaData属性字段。 通常值是通过其value属性来指定的。但是，也可以使用resource属性来代替，把一个资源ID跟值进行关联。 例如，下面的代码就是把存储在@string/kangaroo资源中的值跟”zoo”名称进行关联： android:name=&quot;zoo&quot; android:value=&quot;@string/kangaroo&quot; /&gt;另一个方面，使用resource属性会给zoo分配一个数字资源ID，而不是保存在资源中的值。例如： 要避免使用多个独立的实体来提供相关的数据。相反如果有复杂的数据要跟组件关联，那么把数据作为资源来保存，并使用resource属性，把相关的资源ID通知给组件。 android:name 针对项目的一个唯一名称。使用Java样式的命名规则，可以确保名称的唯一性，例如： com.example.project.activity.fred。 android:resource 这个属性定义了一个要引用的资源。资源的ID会跟这个项目进行关联。通过Bundle.getInt()方法能够从meta-data的Bundle对象中获取这个ID。 android:value 这个属性会给这个项目分配一个值。下表列出了可能分配的数据的数据类型，以及获取这些数据的方法： 类型 Bundle对象方法 字符串。对于一个Unicode字符，要使用双斜线（\\）来进行转义，如\\n和\\uxxxx getString() 整数值，如100 getInt() 布尔值，true或false getBoolean() 颜色值，如#rgb、#argb、#rrggbb、#aarrggbb getString() 浮点值，如1.23 getFloat() uses-library 这个元素用于指定该应用程序必须链接的共享类库。这个元素告诉系统该应用程序包的类装载器中所包含的类库代码。 Android的所有包（如andorid.app，android.content，android.view和android.widget等）都在应用程序自动链接的默认类库中。但是，有些包是在于独立的类库中，它们不能被自动的链接到应用程序包中，要查看这些包的文档，以确定要把哪些类库包含到包的代码中。 这个元素也会影响该应用程序在特殊设备上的安装，以及应用程序在Google Play上的可用性。 安装（Installation） 如果在该应用的清单中出现这个元素，并且它的android:required属性被设置为true，那么除非该类库在用户的设备上存在，否则PackageManager框架不会让用户安装这个应用程序。 Google Play Google Play会基于要安装在用户设备上的类库来过滤应用程序。有关过滤的更多信息，请看Filters on Google Play（http://developer.android.com/guide/appendix/market-filters.html） android:name 这个属性用于指定类库的名称。这个名称是在对应的类库文档中提供的。例如：android.test.runner库就是包含Android测试类的一个程序包。 android:required 这个属性用于指定应用程序是否需要有android:name属性所指定的类库： true：没有这个库应用程序无法工作。如果用户设备设备上没有这个类库，系统不允许该应用程序安装在这个设备上。 false：如果该类库存在，则应用程序能够使用这个类库，但是如果有必要，也可以设计成没有该类库，应用程序也能够工作。系统会允许应用程序安装，即使该类库不存在。如果使用false，就要在运行时对类库的有效性进行必要的检查。 对于类库的检查，可以使用反射机制来判断一个具体的类是否有效。 默认值是true。 这个属性在API Level 7中被引入。 activity&lt;activity android:allowTaskReparenting=[\"true\" | \"false\"] android:alwaysRetainTaskState=[\"true\" | \"false\"] android:clearTaskOnLaunch=[\"true\" | \"false\"] android:configChanges=[\"mcc\", \"mnc\", \"locale\",\"touchscreen\", \"keyboard\", \"keyboardHidden\",\"navigation\", \"screenLayout\", \"fontScale\", \"uiMode\",\"orientation\", \"screenSize\",\"smallestScreenSize\"] android:enabled=[\"true\" | \"false\"] android:excludeFromRecents=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:finishOnTaskLaunch=[\"true\" | \"false\"] android:hardwareAccelerated=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:launchMode=[\"multiple\" | \"singleTop\" |\"singleTask\" | \"singleInstance\"] android:multiprocess=[\"true\" | \"false\"] android:name=\"string\" android:noHistory=[\"true\" | \"false\"] android:permission=\"string\" android:process=\"string\" android:screenOrientation=[\"unspecified\" | \"user\" | \"behind\" |\"landscape\" | \"portrait\" |\"reverseLandscape\" | \"reversePortrait\" |\"sensorLandscape\" | \"sensorPortrait\" |\"sensor\" | \"fullSensor\" | \"nosensor\"] android:stateNotNeeded=[\"true\" | \"false\"] android:taskAffinity=\"string\" android:theme=\"resource or theme\" android:uiOptions=[\"none\" | \"splitActionBarWhenNarrow\"] android:windowSoftInputMode=[\"stateUnspecified\",\"stateUnchanged\", \"stateHidden\",\"stateAlwaysHidden\", \"stateVisible\",\"stateAlwaysVisible\", \"adjustUnspecified\",\"adjustResize\", \"adjustPan\"] > . . . &lt;/activity> 这个元素声明了一个Activity（或Activity的子类），Activity实现了应用程序的可视化用户界面部分。应用程序中所有的Activity都必须在清单文件中用&lt;activity&gt;元素来声明，没有在清单文件中声明的Activity，系统不会看到，也不会运行它。 android:allowTaskReparenting 这个属性用于设定Activity能够从启动它的任务中转移到另一个与启动它的任务有亲缘关系的任务中，转移时机是在这个有亲缘关系的任务被带到前台的时候。如果设置了true，则能够转移，如果设置了false，则这个Activity必须要保留在启动它的那个任务中。 如果这个属性没有设置，那么其对应的&lt;application&gt;元素的allowTaskReparenting属性值就会应用到这个Activity上。它的默认值是false。 通常，当Activity被启动时，它会跟启动它的任务关联，并它的整个生命周期都会保持在那个任务中。但是当Activity的当前任务不在显示时，可以使用这个属性来强制Activity转移到与当前任务有亲缘关系的任务中。这种情况的典型应用是把应用程序的Activity转移到与这个应用程序相关联的主任务中。 例如，如果一个电子邮件消息中包含了一个网页的链接，点击这个链接会启动一个显示这个网页的Activity。但是，由e-mail任务部分启动的这个Activity是由浏览器应用程序定义的。如果把它放到浏览器的任务中，那么在浏览器下次启动到前台时，这个网页会被显示，并且在e-mail任务再次显示时，这个Activity有会消失。 Activity的亲缘关系是由taskAffinity属性定义的。通过读取任务的根Activity的亲缘关系来判断任务的亲缘关系。因此，通过定义，任务中的根Activity与任务有着相同的亲缘关系。因此带有singleTask或singleInstance启动模式的Activity只能是任务的根节点，Activity的任务归属受限于standard和singleTop模式。 android:alwaysRetainTaskState 这个属性用于设置Activity所属的任务状态是否始终由系统来维护。如果设置为true，则由系统来维护状态，设置为false，那么在某些情况下，系统会允许重设任务的初始状态。默认值是false。这个属性只对任务根节点的Activity有意义，其他所有的Activity都会被忽略。 通常，在某些情况中，当用户从主屏中重新启动一个任务时，系统会先清除任务（从堆栈中删除根节点Activity之上的所有Activity）。 但是，当这个属性被设置为true时，用户会始终返回到这个任务的最后状态，而不管中间经历了哪些操作。这样做是有好处的，例如，Web浏览器的应用就会保留很多用户不想丢失的状态，如多个被打开的标签页。 android:clearTaskOnLaunch 这个属性用于设定在从主屏中重启任务时，处理根节点的Activity以外，任务中的其他所有的Activity是否要被删除。如果设置为true，那么任务根节点的Activity之上的所有Activity都要被清除，如果设置了false，就不会被清除。默认设置时false。这个属性只对启动新任务（或根Activity）的那些Activity有意义，任务中其他所有的Activity都会被忽略。 当这个属性值被设置为true，用户再次启动任务时，任务根节点的Activity就会被显示，而不管在任务的最后做了什么，也不管任务使用Back按钮，还是使用Home离开的。当这个属性被设置为false时，在某些情况中这个任务的Activity可以被清除，但不总是这样的。 例如，假设某人从主屏中启动了Activity P，并且又从P中启动了Activity Q。接下来用户按下了Home按钮，然后由返回到Activity P。通常用户会看到Activity Q，因为这是在P的任务中所做的最后的事情。但是，如果P把这个属性设置为true，那么在用户按下Home按钮，任务被挂起时，Activity P之上的所有Activity（本例中是Activity Q）都会被删除。因此当用户再次返回到本任务时，用户只能看到Activity P。 如果这个属性和allowTaskReparenting属性都被设置为true，那些被设置了亲缘关系的Activity会被转移到它们共享的亲缘任务中，然后把剩下的Activity都给删除。 android:configChanges这个属性列出了那些需要Activity进行自我处理的配置变化。当在运行时配置变化发生的时候，默认情况下，这个Activity会被关掉并重启，但是用这个属性声明一个配置，就会阻止Activity被重启。相反，这个Activity会保持运行，并且它的onConfigurationChanged()方法会被调用。 注意：应该避免使用这个属性，并且只把它作为最后的手段来使用。有关如何正确处理配置改变期间的重启，请阅读“处理运行是变化”(http://blog.csdn.net/fireofstar/article/details/7456363) 下表中列出了这个属性的有效值，要设置多个值的时候，用“|”符号连接，例如：“locale|navigation|orientation” 值 说明 mcc IMSI移动国家编码改变时要进行自我处理—系统发现了一个新的SIM卡，并且更新了MCC。 mnc IMSI移动网络编码改变时要进行自我处理—系统发现了一个新的SIM卡，并且更新了MNC locale 语言环境发生变化时要进行自我处理—用户选择了一种用于显示文本的新语言。 touchscreen 触屏发生变化时要进行自我处理。（这种情况通常不会发生） keyboard 键盘类型发生变化时，要进行自我处理。例如用户插入了一个外部键盘 keyboardHidden 键盘的可用性发生变化时，要进行自我处理。例如用户启用了硬件键盘。 navigation 导航类型（轨迹球/方向板）发生变化时，要进行自我处理。这种情况通常不会发生。 screenLayout 屏幕布局发生变化时，要进行自我处理。这可能是由被激活的不同的显示方式所导致的变化。 fontScale 字体的缩放因子发生变化时，要进行自我处理。如用户选择了一个新的全局字体尺寸。 uiMode 用户界面发生变化时，要进行自我处理。在把设备放入桌面/轿车内或夜间模式变化时，会导致这种情况发生。它在API级别8中被引入。 orientation 屏幕的方向发生变化时，要进行自我处理。用户旋转设备时会发生这种变化。注意：如果应用程序的目标API级别是13或更高的版本，那么还应该声明screenSize配置，因为设备在横向和纵向之间切换时，对应的尺寸也会发生变化。 screenSize 当前有效的屏幕尺寸发生变化时，要进行自我处理。这种变化意味着当前可用的相对长、宽比的尺寸发生了变化，因此当用户在横向和纵向之间切换时，就会产生屏幕可用尺寸的变化。但是，如果应用程序是在API级别12或更低的版本上编译的，那么Activity就要始终自己来处理这种变化（这个配置的变化不会重启Activity，即使是运行在Android3.2或更高版本的设备上）。这个设置在API级别13中被引入。 smallestScreenSize 物理尺寸发生变化时，要进行自我处理。这种变化不关注屏幕方向的变化，只在实际的物理屏幕尺寸发生变化时才会发生，如切换到另一个显示器上的时候。这个变化对应smallestWidth属性的配置来进行改变。如果应用程序是在API级别12或更低的版本上编译的，那么Activity就要始终自己来处理这种变化（这个配置的变化不会重启Activity，即使是运行在Android3.2或更高版本的设备上）。这个设置在API级别13中被引入。 所有这些配置的改变都会影响到应用中所能看到的资源值。因此，当onConfigurationChanged()方法被调用时，通常需要重新获取所有的资源（包括布局资源、可绘制资源等等），以便能够正确的处理这些改变。 android:enabled 这个属性用于设置Activity是否能够被系统实例化。如果设置为true，则可以被实例化，如果设置为false，则不能被实例化。默认值是true。 &lt;application&gt;元素有它自己的enabled属性，它的这个属性设置会用于应用程序中的所有组件，包括Activity。&lt;application&gt;和&lt;activity&gt;元素的这个属性必须要设置为true（默认情况下都是true），以便系统能够实例化Activity。否则Activity不能被实例化。 android:excledeFromRecents 这属性用于设置由该Activity所启动的任务是否应该被排除在最近使用的应用程序列表之外。也就是说，当这个Activity是一个新任务的根节点时，这个属性决定了这个任务适应要显示在用户最近使用的应用程序列表中。如果设置为true，则这个任务会被排除在列表之外，如何设置为false，则应该包含在最近使用的应用列表中。默认值是false。 android:exported 这个属性用于设置该Activity能否由另一个应用程序的组件来启动，如果设置为true，则可以启动，否则不能启动。如果设置为false，那么该Activity只能被同一个应用程序中的组件或带有相同用户ID的应用程序来启动。 它的默认值要依赖与该Activity是否包含了Intent过滤器。如果没有任何过滤器，则意味着该Activity只能通过明确的类名来调用，这样就暗示者该Activity只能在应用程序内部使用（因为其他用户不会知道它的类名），因此在这种情况下，默认值是false。在另一方面，至少存在一个过滤器，则暗示着该Activity可被外部使用，因此默认值是true。 这个属性不是限制Activity暴露给其他应用程序的唯一方法。还可以使用权限来限制外部实体对该Activity的调用。 android:finishOnTaskLaunch 这个属性用于设置既存的Activity实例，在用户再次启动（在主屏上选择这个任务）它所属的任务时，是否应该被关闭。设置为true，则要关闭，否则不关闭，默认值是false。 如果这个属性和allowTaskReparenting属性都被设置为true，那么这个属性要优于其他属性，Activity的亲缘关系会被忽略。该Activity不会被转移父任务，而是被销毁。 android:hardwareAccelerated 这个属性用于设置该Activity是否应该启用硬件加速渲染。如果设置为true，则启用硬件加速，否则不启用。默认设置是false。 从Android3.0开始，硬件加速的OpenGL渲染器对应用程序可用，以便改善许多共同的2D图形操作的性能。当硬件加速渲染器被启用时，在Canva、Paint、Xfermode、ColorFilter、Shader和Camera中大多数操作都会被加速。这样会使动画、滚动更平滑，并改善整体的响应效果，即使应用程序没有明确要使用框架的OpenGL类库。因为启用硬件加速会增加系统的资源需求，所以应用程序会占用更多的内存。 要注意的是，不是所有的OpenGL 2D操作都会被加速。如果启用了硬件加速渲染，就要对应用程序进行充分测试，以确保所使用的渲染没有错误。 android:icon 这属性定义了代表Activity的一个图标。当Activity被要求显示到屏幕上时，这个图标会被显示给用户。例如，这个图标会显示在Launcher的窗口中，用于启动任务。这个图标经常会和label属性组合使用。 这个属性必须被设置为一个包含图片定义的可绘制资源。如果没有设置，就会使用给应用程序设置的图标来代替。 Activity的图标（或者是&lt;application&gt;元素设置的图标）也是所有的Activity的Intent过滤器的默认图标。 android:label 这个属性给Activity设置了一个可读的标签。当Activity要展现给用户的时候，这个标签会显示在屏幕上，它经常会跟Activity的图标一起来显示。 如果这个属性没有被设置，就会使用给应用程序设置的标签来代替。 Activity的标签（或者是&lt;application&gt;元素设置的标签）也是所有Activity的Intent过滤器的默认标签。 这个属性应该用一个字符串资源来设置。以便它能够在用户界面中用其他的语言来本地化。但是为了开发应用程序的便利，也可以用原始的字符串来设置。 android:launchMode详见Activity的启动模式 android:multiprocess 这个属性用于设置Activity的实例能否被加载到与启动它的那个组件所在的进程中，如果设置为true，则可以，否则不可以。默认值是false。 通常，一个新的Activity实例会被加载到定义它的应用程序的进程中，以便应用程序的所有Activity都运行在同一个进程中。但是，如果这个属性被设置为true，那么这个Activity的实例就可以运行在多个进程中，允许系统在使用它们的进程中来创建实例（权限许可的情况下），这几乎是从来都不需要的事情。 android:name 这个属性用于设置Activity的实现类（Activity的子类）的名字。这个属性值应该是完整的Java类名，如：com.example.project.ExtracurricularActivity。但是，可以用简写的方式，名字第一个字符用“.”符号，如：.ExtracurricularActivity。它对应的包名是在&lt;manifest&gt;元素中指定的。 一旦发布了应用程序，就不应该改变这个名称了（除非设置了android:exported=”false”）。 这个属性没有默认值，名称必须被指定。 android:noHistory 这个属性用于设置在用户离开该Activity，并且它在屏幕上不再可见的时候，它是否应该从Activity的堆栈被删除。如果设置了true，则要删除，否则不删除。默认值是false。 如果设置为true，则意味着Activity不会保留历史轨迹。也就是说，它不会保留在任务的Activity堆栈中，因此用户不能够在返回到这个Activity。 这个属性在API Level 3中被引入。 android:permission 这个属性用于设定启动Activity的客户端或者是响应一个Intent对象的请求所必须要有的权限。如果startActivity()方法或startActivityForResult()方法的调用者没有被授予指定的权限，那么它的Intent对象就不会发送给对应的Activity。 如果这个属性没有设置，那么&lt;application&gt;元素中的permission属性的设置就应用到Activity元素上。如果&lt;application&gt;元素也没有设置，那么这个Activity就不会受到权限的保护。 android:process 这个属性用于设置Activity应该运行的那个进程的名字。通常，应用程序的所有组件都运行在为这个程序所创建的一个默认的进程中。它跟应用程序的包有相同的名字。&lt;application&gt;元素的process属性能够给所有的组件设置一个不同的默认值。但是每个组件都能够覆盖这个默认设置，允许把应用程序分离到多个进程中。 如果这个属性名的值是用“:”开始，那么在需要的时候，就会创建一个应用程序私有的新的进程，这个Activity就会运行在这个进程中。如果进程名使用小写字母开头，那么在权限许可的情况下，该Activity会运行在用它命名的全局进程中。这样就运行不同应用程序的组件能够共享一个进程，从而减少资源的使用。 android:screenOrientation 这个属性用于设置Activity在设备上显示的方向。 属性值可以是下表中列出的一个值： 值 描述 unspecified 默认值，由系统来选择方向。它的使用策略，以及由于选择时特定的上下文环境，可能会因为设备的差异而不同。 user 使用用户当前首选的方向。 behind 使用Activity堆栈中与该Activity之下的那个Activity的相同的方向。 landscape 横向显示（宽度比高度要大） portrait 纵向显示（高度比宽度要大） reverseLandscape 与正常的横向方向相反显示，在API Level 9中被引入。 reversePortrait 与正常的纵向方向相反显示，在API Level 9中被引入。 sensorLandscape 横向显示，但是基于设备传感器，既可以是按正常方向显示，也可以反向显示，在API Level 9中被引入。 sensorPortrait 纵向显示，但是基于设备传感器，既可以是按正常方向显示，也可以反向显示，在API Level 9中被引入。 sensor 显示的方向是由设备的方向传感器来决定的。显示方向依赖与用户怎样持有设备；当用户旋转设备时，显示的方向会改变。但是，默认情况下，有些设备不会在所有的四个方向上都旋转，因此要允许在所有的四个方向上都能旋转，就要使用fullSensor属性值。 fullSensor 显示的方向（4个方向）是由设备的方向传感器来决定的，除了它允许屏幕有4个显示方向之外，其他与设置为“sensor”时情况类似，不管什么样的设备，通常都会这么做。例如，某些设备通常不使用纵向倒转或横向反转，但是使用这个设置，还是会发生这样的反转。这个值在API Level 9中引入。 nosensor 屏幕的显示方向不会参照物理方向传感器。传感器会被忽略，所以显示不会因用户移动设备而旋转。除了这个差别之外，系统会使用与“unspecified”设置相同的策略来旋转屏幕的方向。 注意：在给这个属性设置的值是“landscape”或portrait的时候，要考虑硬件对Activity运行的方向要求。正因如此，这些声明的值能够被诸如Google Play这样的服务所过滤，以便应用程序只能适用于那些支持Activity所要求的方向的设备。例如，如果声明了“landscape”、“reverseLandscape”、或“sensorLandscape”，那么应用程序就只能适用于那些支持横向显示的设备。但是，还应该使用元素来明确的声明应用程序所有的屏幕方向是纵向的还是横行的。例如：。这个设置由Google Play提供的纯粹的过滤行为，并且在设备仅支持某个特定的方向时，平台本身并不控制应用程序是否能够被按照。 android:stateNotNeeded 这个属性用于设置在没有保存Activity状态的情况下，它能否被销毁且成功的重启。如果设置为true，则不引用Activity之前的状态就能够被重启，如果设置为false，重启Activity时，则需要它之前的状态。默认值是false。 通常，Activity在最终被关掉之前，会调用onSaveInstanceState()方法来保存资源。这个方法会用一个Bundle对象来保存Activity的当前状态，然后在这个Activity被重启时，再把这个Bundle对象传递给onCreate()方法。如果这个属性设置为true，onSaveInstanceState()方法就可以不被调用，并且调用onCreate()方法时，会用null来代替Bundle对象，就像Activity被第一次重启一样。 设置为true，会确保Activity在缺省状态下能够被重启。例如，在主屏显示的Activity如果使用这个设置，即使由于某些原因导致Activity崩溃，也会确保它不会被删除。 android:taskAffinity 这个属性用于跟Activity有亲缘关系的任务。带有相同亲缘关系的Activity，在概念上是属于相同任务的（从用户的角度看，它们是属于同一应用程序的）。任务的亲缘关系是通过它的根节点的Activity的亲缘关系来判定的。 亲缘关系决定了两件事情：1.Activity能否重新设定父任务（看allowTaskReparenting属性）；2.这个任务能够包含用FLAG_ACTIVITY_NEW_TASK标记启动的Activity。 默认情况下，在一个应用程序中的所有Activity都有相同的亲缘关系。能够通过设置这个属性把Activity分到不同的组中。甚至能够把定义在不同应用程序中的Activity放到同一个任务中。要指定一个跟任何任务没有亲缘关系的Activity，就要把这个属性设置为空字符串。 如果这个属性没有设置，那么这个Activity会继承应用程序的亲缘关系（看&lt;application&gt;元素的taskAffinity属性）。应用程序默认的亲缘关系名称是由元素的package属性设定包名。 android:theme 这个属性用于设定Activity整体主题，它会应用一个样式资源。系统会使用这个主题来自动的设置Activity的内容。 如果这个属性没有设置，Activity会继承应用程序的主题（元素的theme属性）做它的整体样式。如果这个属性也没有设置，那么默认使用系统的主题。 android:uiOptions 这个属性用于设置Activity的UI的额外选项，它必须是下表中的一个值。 值 说明 none 默认设置，没有额外的UI选项。 splitActionBarWhenNarrow 在水平空间受到限制的时候，会在屏幕的底部添加一个用于显示ActionBar中操作项的栏，例如：在纵向的手持设备上。而不是在屏幕顶部的操作栏中显示少量的操作项。它会把操作栏分成上下两部分，顶部用于导航选择，底部用于操作项目。这样就会确保可用的合理空间不仅只是针对操作项目，而且还会在顶部给导航和标题留有空间。菜单项目不能被分开到两个栏中，它们要显示在一起。 android:windowSoftInputMode 这个属性用于设定Activity的主窗口与软件键盘的窗口如何交互。设置这个属性会影响以下两件事情： 软键盘的状态—在Activity获取输入焦点时，软键盘是隐藏还是显示。 调整Activity的主窗口—是调整Activity主窗口的大小，以便给软键盘腾出显示空间；还是在Activity窗口中的输入焦点被软键盘覆盖时，让Activity窗口中的内容平移，以便输入焦点能够显示给用户。 这个属性必须用下表中的一个值来设定，或者是一个state…的值和一个adjust…的值的组合。如： &lt;activityandroid:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; . . . &gt; 这个属性设置的值会覆盖主题中设置的值。 值 说明 stateUnspecified 它不指定软键盘的状态（显示或隐藏）。系统会选择合适的状态，或者依赖主题中的设置。它是软键盘行为的默认设置。 stateUnchanged 当Activity显示在前台时，软键盘会保持它最后的状态（显示或隐藏） stateHidden 当用户选择这个Activity时，软键盘会隐藏。也就是说，当用户确认向前浏览到这个Activity的时候，而不是因为离开另一个Activity而返回这个Activity的时候。 stateAlwaysHidden 当Activity的主窗口有输入焦点时，软键盘会始终隐藏 stateVisible 在适当的时候（通常是用户浏览到这个Activity的主窗口），软键盘是可见的。 stateAlwaysVisible 当用户选择了这个Activity时，软键盘变的可见，也就是说，当用户确认向前浏览到这个Activity的时候，而不是因为离开另一个Activity而返回这个Activity的时候。 adjustUnspecified 这个值并不指定Activity的主窗口会软键盘的显示而进行大小的调整，也不会指定Activity的主窗口是否会平移，以便把因软键盘所遮挡的输入焦点显示给用户。系统会依赖内容窗口中的内容是否能够滚动，来自动的选择这两种模式。如果Activity窗口中有一个能够滚动的布局，那么这个窗口就会被调整大小，并假设通过滚动能够在一个较小的区域内来浏览窗口中所有的内容。 adjustResize 为适应软键盘的显示，Activity的主窗口始终要调整大小。 adjustPan Activity的主窗口不会因软键盘的显示而调整大小，相反，窗口中的内容会被自动的平移，以便输入焦点不会被软键盘所遮挡，并且用户能够看到他们所输入的内容。通常很少使用这种模式，因为用户可能需要关闭软键盘，以便能够跟软键盘所遮挡进行交互。 service&lt;service android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permission=\"string\" android:process=\"string\"> . . . &lt;/service> 这个元素用于声明一个服务（Service类的子类）作为应用程序的组件之一。跟Activity不一样，服务没有可见的用户界面。它们被用于实现长时的后台操作，或提供能够被其他应用程序调用的通信API。 所有的服务都必须用清单文件中的&lt;service&gt;元素来代表。任何没有在清单中声明的服务都不能被系统看到，也不会被运行。 android:enabled 这个属性用于指示该服务是否能够被实例化。如果设置为true，则能够被实例化，否则不能被实例化。默认值是true。 &lt;application&gt;元素有它自己的enabled属性，它的这个属性适用于应用中所有的组件，包括service组件。对于被启用的服务，&lt;application&gt;和&lt;service&gt;元素的enabled属性都必须是true（默认值都是true）。如果有一个元素的enabled属性被设置为false，该服务就会被禁用，而不能被实例化。 android:exported 这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。如果设置为true，则能够被调用或交互，否则不能。设置为false时，只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。 它的默认值依赖与该服务所包含的过滤器。没有过滤器则意味着该服务只能通过指定明确的类名来调用，这样就是说该服务只能在应用程序的内部使用（因为其他外部使用者不会知道该服务的类名），因此这种情况下，这个属性的默认值是false。另一方面，如果至少包含了一个过滤器，则意味着该服务可以给外部的其他应用提供服务，因此默认值是true。 这个属性不是限制把服务暴露给其他应用程序的唯一方法。还可以使用权限来限制能够跟该服务交互的外部实体。 android:icon 这个属性定义了一个代表服务的图标，它必须要引用一个包含图片定义的可绘制资源。如果这个属性没有设置，则会使用&lt;application&gt;元素的icon属性所设定的图标来代替。 无论是&lt;application&gt;元素设置的图标，还是&lt;service&gt;元素所设置的图标，它们都是该服务所有的Intent过滤器的默认图标。 android:label 这个属性用于设定一个要显示给用户的服务的名称。如果没有设置这个属性，则会使用&lt;application&gt;元素的label属性值来代替。 无论是&lt;service&gt;设定的标签，还是&lt;application&gt;元素设定的标签，它们都是该服务所有的Intent过滤器的默认标签。 这个标签应用引用一个字符串资源，以便它能够像用户界面中的字符串一样能够被本地化。但是，为了开发应用程序方便，也可以使用原生字符串来设置这个属性。 android:name 这个属性用于指定实现该服务的Service子类的类名。它应该是完整的Java类名（如：com.example.project.RoomService）。但是，也可以使用简写（如：.RoomService），系统会把&lt;manifest&gt;元素中package属性所设定的值添加到简写名称的前面。 一旦发布了应用程序，就不应该改变这个名称（除非android:exported=”false”）。 这个属性没有默认值，名称必须要指定。 android:permission 这个属性定义了要启动或绑定服务的实体必须要有的权限。如果调用者的startService()、bindService()和stopService()方法没有被授予这个权限，那么这些方法就不会工作，并且Intent对象也不会发送给改服务。 如果这个属性没被设置，那么通过&lt;appliction&gt;元素的permission属性所设定的权限就会适用于该服务。如果&lt;application&gt;元素也没有设置权限，则该服务不受权限保护。 android:process 这个属性用于设定服务所运行的进程名称。通常，应用程序的所有组件都运行在给应用程序创建的进程中，进程名与应用程序的包名相同。&lt;application&gt;元素的process属性能够给应用程序的所有组件设置一个不同的默认名称。但是每个组件自己的process属性都能够覆盖这个默认值，这样允许把应用程序分离到不同的多个进程中。 如果这个属性值用“:”开头，则在需要的时候系统会创建一个新的，应用程序私有的进程，并且该服务也会运行在这个进程中。如果这个属性值用小写字母开头，那该服务就会运行在以这个属性值命名的全局进程中，它提供了使其工作的权限。这样就允许不同的应用程序组件来共享这个进程，从而降低资源的使用。 activity-alias&lt;activity-alias android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permission=\"string\" android:targetActivity=\"string\"> . . . &lt;/activity-alias> 这个元素用于给targetActivity属性所指定Activity设定一个别名，目标Activity必须跟别名Activity在同一个应用程序中，并且这个Activity必须在别名之前被声明。 别名会作为一个独立的实体来代表目标Activity。它能够有自己的Intent过滤器设置，而不是目标Activity自己的Intent过滤器，通过别名和系统处理别名的方式来判断哪个Intent对象能够激活目标。例如：别名中的Intent过滤器可以指定“android.intent.action.MAIN”和“android.intent.category.LAUNCHER”标记，这样即使在目标Activity的过滤器上没有指定这些标记，也会让它在应用的启动器窗口中表示。 除了targetActivity属性以外，&lt;activity-alias&gt;的其他属性是&lt;activity&gt;属性的一个子集。对于子集中的属性，不会把目标Activity中所设置的任何值转交给别名Activity。但是，对于子集中所没有的属性，则给目标Activity所设置的值也会应用到别名Activity。 android:enabled 这个属性用于设定系统能否通过这个别名来实例化目标Activity，如果设置为true，则可以实例化，否则不能实例化。默认值是true。 &lt;application&gt;元素有它自己的enabled属性，这个属性会应用给所有的应用程序组件，包括Activity别名。&lt;application&gt;和&lt;activity-alias&gt;属性都必须是true，这样系统才能够通过别名来实例化目标Activity。如果其中之一是false，那么别名就不会起作用。 android:exported 这个属性用于设定其他的应用程序组件能否通过这个别名来启动目标Activity，如果设置为true，则能够启动，否则不能启动。如果设定为false，则目标Activity只能由与别名相同的应用程序组件或具有相同用户ID的应用程序通过别名来启动。 它的默认值依赖与别名是否包含了Intent过滤器，如果没有过滤器，则意味着这个Activity只能通过确切的别名名称来调用别名Activity，隐含的意思是这个别名只能在应用程序的内部使用（因为其他人不知道它的名称）—因此默认值是false。在另外一方面，如果至少有一个过滤器，则意味着这个别名可以在外部使用—因此默认值是true。 android:icon 当通过别名把目标Activity展示给用户时，使用这个属性给目标Activity设置一个图标。 android:label 当通过别名把目标Activity展示给用户时，使用这个属性给目标Activity设置一个可读的标签。 android:name 给别名设置一个唯一的名字。这个名字应该像一个完全限定的类名，但是不想目标Activity的名字那样，别名的名称是任意的，它不对应一个实际的类名。 android:permission 设定权限的名称，客户端必须有这个权限才能启动目标Activity或通过别名来获取目标Activity以便做某些事情。如果startActivity()或startActivityForResult()方法的调用者没有被授予指定的权限，那么目标Activity就不会被激活。 这个属性值会取代目标Activity自己所设置的任何权限。如果它没有设置，那么不需要权限就可以通过别名来激活目标Activity。 android:targetActivity 这个属性用于设置通过别名所能够激活的那个Activity的名字。这个名字必须跟它前面的元素的name属性匹配。 receiver&lt;receiver android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permission=\"string\" android:process=\"string\"> . . . &lt;/receiver> 这个元素用于声明一个广播接收器（一个BroadcastReceiver 子类），作为应用程序的组件之一。广播接收器能够让应用程序接收那些由系统或其他应用程序发出的广播Intent对象，即使是在该应用程序的其他组件没有运行的时候，也能够接收来自系统或其他应用程序的广播消息。 有两种方式让系统知道本应用程序用户一个广播接收器： 在应用程序的清单文件中，使用本元素来声明注册一个广播接收器； 在代码中动态的创建一个广播接收器，并使用Context.registerReceiver()方法来注册它。有关更多动态创建接收器的方法，请看BoradcastReceiver类说明。 android:enabled 这个属性用于定义系统是否能够实例化这个广播接收器，如果设置为true，则能够实例化，如果设置为false，则不能被实例化。默认值是true。 &lt;application&gt;元素有它自己的enabled属性，这个属性会应用给应用程序的所有组件，包括广播接收器。和元素的这个属性都必须是true，这个广播接收器才能够被启用。如果有一个被设置为false，该广播接收器会被禁止实例化。 android:exported 这个属性用于指示该广播接收器是否能够接收来自应用程序外部的消息，如果设置true，则能够接收，如果设置为false，则不能够接收。如果设置为false，这该接收只能接收那些由相同应用程序组件或带有相同用户ID的应用程序所发出的消息。 它的默认值依赖它所包含的Intent过滤器。如果不包含过滤器，则接收器只能由指定了明确类名的Intent对象来调用，这就意味着该接收器只能在应用程序内部使用（因为通常在应用程序外部是不会知道这个类名的）。这种情况下默认值就是false。另一方面，如果接受器至少包含了一个过滤器，那么就意味着这个接收器能够接收来自系统或其他应用程序的Intent对象，因此默认值是true。 这个属性不是唯一的限制广播接收外部调用的方法，还能够通过全限来限制能够给它发送消息的外部实体。 android:icon 这个属性定义了一个代表广播接收器的图标，这个属性必须用包含图片定义的可绘制资源来设定。如果没有设置这个属性，会是应用元素的icon属性值来代替。 无论是这个属性还是&lt;application&gt;元素的icon属性，它们设置的图标也是所有的接收器的Intent过滤器的默认图标。 android:label 这个属性给广播接收器设定一个用户可读的懂的文本标签。如果这个属性没有设置，那么就会使用&lt;application&gt;元素的label属性值来代替。 无论是这个属性还是&lt;application&gt;元素的label属性，它们设置的标签也是所有的接收器的Intent过滤器的默认标签。 应该使用一个字符串资源来设置这个属性，以便它能够像用户界面中的其他字符串一样能够被本地化。但是，为了应用开发的便利，也能够使用原生的字符串来设置。 android:name 这个属性值要用广播接收器的实现类的类名来设置，它是BroadcastReceiver类的一个子类。通常要使用类的全名来设置（如：com.example.project.ReportReceiver）。但是，也可以使用简写（如：.ReportReceiver）。系统会自动的把&lt;manifest&gt;元素中的package属性所设定的包名添加到这个简写的名称上。 一旦发布了应用程序，就不应该在改变这个名字了（除非android:exported=”false”）。 这个属性没有默认值，这个名字必须被指定。 android:permission 这个属性用于定义把消息发送给该广播接收器的广播器所必须要有的权限。如果没有设置这个属性，那么&lt;application&gt;元素的permission属性所设置的权限就适用于这个广播接收器。如果&lt;application&gt;元素也没有设置权限，那么该接收器就不受权限的保护。 android:process 这个属性用于设置该广播接收器应该运行在那个进程中的进程名。通常，应用程序的所有组件都在给应用程序创建的默认进程中运行，它有与应用程序包名相同的名称。&lt;application&gt;元素的process属性能够给它的所有组件设置一个不同的默认进程，但是它的每个组件自己的process属性能够覆盖这个默认设置，这样就允许把一个应用程序分离到多个进程中。 如果这个属性值用“:”开头，则在需要的时候系统会创建一个新的，应用程序私有的进程，并且该广播接收器也会运行在这个进程中。如果这个属性值用小写字母开头，那么接收器就会运行在以这个属性值命名的全局进程中，它提供使其工作的权限。这样就允许不同的应用程序组件来共享这个进程。 provider&lt;provider android:authorities=\"list\" android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:grantUriPermissions=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:initOrder=\"integer\" android:label=\"string resource\" android:multiprocess=[\"true\" | \"false\"] android:name=\"string\" android:permission=\"string\" android:process=\"string\" android:readPermission=\"string\" android:syncable=[\"true\" | \"false\"] android:writePermission=\"string\"> . . . &lt;/provider> 这个元素用于声明一个内容提供器，它对应一个ContentProvider类的子类。它提供了对由应用程序管理的数据的结构化的访问。应用程序使用的所有的内容提供器都必须在其清单文件中由元素来声明。对于那些没有在清单中声明的内容提供器，系统看不到，也不会运行。（只需要声明那些作为该应用程序一部分的来开发的那些内容提供器，而不是那些由应用程序使用的由其他人开发本应用之外的那些内容提供器）。 Android系统通过content:URI的授权部分来识别内容提供器。例如，假设下列的URI要传递给ContentResolver.query()方法： content://com.example.project.healthcareprovider/nurses/rn content:表示数据是属于内容提供器的，授权（com.example.project.healthcareprovider）：标识着一个具体的提供器。因此授权必须唯一的。通常，就像这个例子一样，授权是一个完整的ContentProvider子类的名称。URI的路径部分被内容提供器用来标识具体的数据子集，但是那些路径没有被声明在清单文件中。 关于使用可开发内容提供器的更多信息，请看内容提供的文档（）。 http://blog.csdn.net/fireofstar/article/details/7307402 android:authorities 标识内容提供器范围内的数据URI的授权列表，有多个授权时，要用分号来分离每个授权。为了避免冲突，授权名应该使用Java样式的命名规则（如：com.example.provider.cartoonprovider）。通常，用ContentProvider子类名称来设定这个属性。 这个属性没有默认值，至少要指定一个授权。 android:enabled 这个属性用于指定这个内容提供器是否能够被系统安装。设置为true，则可以安装；否则不能安装。默认值是true。 &lt;application&gt;元素有它自己的enabled属性，这个属性会应用给所有的应用程序组件，包括内容提供器。&lt;application&gt;和&lt;provider&gt;的enabled属性都必须设置为true（它们的默认值都是true）。如果有一个设置为false，那么提供器就被禁止安装。 android:exported 这个属性用于指定该内容提供器是否能够被其他的应用程序组件使用。如果设置为true，则可以被使用，否则不能被使用。如果设置为false，该提供器只对同名的应用程序或有相同用户ID的应用程序有效。默认值是true。 虽然能够使用这个属性来公开内容提供器，但是依然还要用permission属性来限制对它的访问。 android:grantUriPermission 这个属性用于设定那些对内容提供的数据没有访问权限的访问者，是否能够被授予访问的权限，这个权限是临时性的，它会克服由readPermission、writePermission和permission属性的设置限制。如果这个属性设置为true，那么权限就可以授予访问者，否则不会授予没有访问权限的访问者。如果设置为true，则权限可以临时被授予内容提供器的任何数据。如果设置为false，则权限只能被授予&lt;gran-uri-permission&gt;子元素中所列出的数据子集。默认值是false。 这种授权是应用程序提供了一种一次性访问被权限所保护的数据的方法。例如，当一个e-mail包含了一个附件时，mail应用程序就可以调用适当的浏览器来打开附件，即使这个浏览器没有查看所有内容提供器数据的权限。 在这样的场景中，权限是通过激活组件的Intent对象中的FLAG_GRANT_READ_URI_PERMISSION和FLAG_GRANT_WRITE_URI_PERMISSION标记来授予的。例如，mail应用程序可以把FLAG_GRANT_READ_URI_PERMISSION标记放到传递给Context.startActivity()方法的Intent参数中。这样权限就被授予了Intent对象中所指定的URI。 如果要启用这个功能，既可以通过把这个属性设置为true来完成，也可以通过定义&lt;grant-uri-permission&gt;子元素来实现，在切换RUI时，必须调用Context.revokeUriPermission()方法从提供器把权限删除。 android:icon 这个属性用于定义一个代表内容提供器的图标。它必须要引用一个包含图片定义的可绘制资源。如果这个属性没有设置，那么就会使用应用程序的&lt;application&gt;元素的icon属性值来代替。 android:initOrder 这个属性用于定义内容提供器应该被实例化的顺序，这个顺序是相对与相同进程所拥有的其他内容提供器的。当内容提供器间有相互的依赖时，就需要设置这个属性，以确保它们能够按照其依赖的顺序被创建。这个属性值是一个简单的整数，大的数字要被优先初始化。 android:label 这个属性用于给内容提供器定义一个用户可读的标签。如果这个属性没有设置，那么它会使用&lt;application&gt;元素的label属性值来代替。 这个标签应该引用一个字符串资源来设置，以便它能够像其他的用户界面中的字符串一样被本地化。但是为了方便应用程序的开发，也能够使用原生的字符串来设置这个属性，但正式发布时一定要引用字符串资源。 android:multiprocess 这个属性用于设定是否能够在每个使用该内容提供器的客户端进程中都创建一个内容提供器的实例，如果设置为true，这个能够在其每个客户端进程中创建一个实例，否则不可以。默认值是false。 通常，内容提供器是在定义它的应用程序的进程中被实例化的。但是，如果这个属性被设置为true，系统就能够在每个要与该内容提供器进行交互的客户端进程中创建一个内容提供器的实例，这样就避免了进程间通信的开销。 android:name 这个属性用于定义内容提供器的实现类的名称，它是ContentProvider类的一个子类。这个属性应该使用完整的Java类名来设定（如：com.example.project.TransportationProvider）。但是也可以使用简写（如：.TransporttationProvider），这时系统会使用元素中指定的包名跟这个简写名称的组合来识别内容提供器。 这个属性没有默认值，必须要给这个属性设定一个名称。 android:permission 这个属性用于设定客户端在读写内容提供器的数据时必须要有的权限的名称。这个属性为同时设置读写权限提供了一种便利的方法。但是readPermission和writePermission属性的优先级要比这个属性高。如果readPermission属性也被设置了，那么它就会控制对内容提供器的查询访问。如果writePermission属性被设置，它就会控制对内容提供器数据的修改访问。 android:process 这个属性用于定义内容提供器应该运行在那个进程中的进程名称。通常，应用程序的所有组件都运行在给应用程序创建的默认进程中。它有与应用程序包相同的名称。&lt;application&gt;元素的process属性能够给其所有的组件设置一个不同的默认进程。但是每个组件都能够用它们自己的process属性来覆盖这个默认设置，从而允许把应用程序分离到不同的多个进程中。 如果这个属性值是用“:”开头的，那么在需要这个提供器的时候，系统就会给这个应用程序创建一个新的私有进程，并且对应的Activity也要运行在那个私有进程中。如果用小写字母开头，那么Activity则会运行在一个用这个属性值命名的全局进程中，它提供了对内容提供器的访问权限。这样就允许不同应用程序的组件能够共享这个进程，从而减少对系统资源的使用。 android:readPermission 这个属性用于设置查询内容提供器的数据时，客户端所必须要有的权限。 android:syncable 这个属性用于设定内容提供器控制下的数据是否要与服务器上的数据进行同步，如果设置为true，则要同步，否则不需要同步。 android:writePermission 这个属性用于设置修改内容提供器的数据时，客户端所必须要有的权限。 path-permission&lt;path-permission android:path=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:pathPattern=&quot;string&quot; android:permission=&quot;string&quot; android:readPermission=&quot;string&quot; android:writePermission=&quot;string&quot;/&gt; 这个元素用于定义内容提供器中的具体的数据子集的路径以及必要的权限。这个元素能够多次使用，以便提供多个路径。 android:path 给内容提供器的数据定义一个完整的URI（数据资源标识）路径。权限只能被授予这个路径所标识的具体数据。 android:pathPrefix 这个属性定义了内容提供器的数据子集的URI的初始部分。权限能够被授予所有那些共享这个URI初始部分的数据子集。 android:pathPattern 这个属性给内容提供器数据子集定义了一个完整的URI路径，但是URI中能够使用下列之一的通配符： 星号（）通配符，路径中的星号代表任意多个星号之前的那个字符，如a*，可跟a、aa、aaa、aaaa、…字符串匹配。 点跟星号的组合(.)通配符，它可以跟任意字符串进行匹配，如.html，可以跟abchhtml、chtml、html、dssf.html、…等字符串匹配。 因为系统读取XML中的字符串时，会把’\\’符号作为强制转义字符，因此就需要两次转义。例如，符号””要被写成”\\”，符号’\\’要被写成”\\\\”。这与Java代码中的写法基本相同。 有关这些模式类型的更多信息，请看PatternMatcher类中的PATTERN_LITERAL、PATTERN_PREFIX、PATTERN_SIMPLE_GLOB的说明。 http://developer.android.com/reference/android/os/PatternMatcher.html android:permission 这个属性定义了一个权限名称，为了读写内容提供器中的数，客户端必须要有这个权限。这个属性是给数据设置读写权限的便利的方法，但是readPermission和writePermission属性比这个属性的优先级要高。 android:readPermission 为了读取查询内容提供器中的数据，客户端必须要这个权限。 android:writePermission 为了能够改变由内容提供器所控制的数据，客户端必须要有这个权限。 grant-uri-permission&lt;grant-uri-permission android:path=\"string\" android:pathPattern=\"string\" android:pathPrefix=\"string\"/> 这个元素用于给内容提供器的数据子集授权。数据子集是由content:URI的路径部分来标识的。授权是提供器给客户端提供的一种能力，这样客户就可以访问通常没有权限访问的数据，从而克服基于单次访问的限制。 如果内容提供器的grantUriPermissions属性被设置为true，那么权限能够被授予内容提供器范围内的任何数据。但是，如果grantUriPermission属性被设置为false，那么权限就只能授予这个元素所指定的数据子集。一个内容提供器能够包含任意多个个&lt;grant-uri-permission&gt;元素。每个都只能指定一个路径（三个可能属性中的一个）。 有关如何授权的更多信息，请看``元素的grantUriPermissions属性。 android:pathandroid:pathprefixandroid:pathPattern 一个路径标识了能够被授权的一个或多个数据子集。path属性指定了一个完整的路径，权限只能被授予这个路径所标识的具体的数据子集。pathPrefix属性指定了路径的初始部分，权限能够被授予共享这个初始路径的所有数据子集。pathPattern属性指定了一个完整的路径，但是这个路径中包含了通配符： 星号（）通配符，路径中的星号代表任意多个星号之前的那个字符，如a*，可跟a、aa、aaa、aaaa、…字符串匹配。 点跟星号的组合(.)通配符，它可以跟任意字符串进行匹配，如.html，可以跟abchhtml、chtml、html、dssf.html、…等字符串匹配。 因为系统读取XML中的字符串时，会把’\\’符号作为强制转义字符，因此就需要两次转义。例如，符号””要被写成”\\”，符号’\\’要被写成”\\\\”。这与Java代码中的写法基本相同。 有关这三种模式的更多信息，请看PatternMatcher类中的PATTERN_LITERAL、PATTERN_PREFIX、PATTERN_SIMPLE_GLOB的说明。 http://developer.android.com/reference/android/os/PatternMatcher.html compatible-screen&lt;compatible-screens> &lt;screen android:screenSize=[\"small\" | \"normal\" | \"large\" | \"xlarge\"] android:screenDensity=[\"ldpi\" | \"mdpi\" | \"hdpi\" | \"xhdpi\"] /> ... &lt;/compatible-screens> 这个元素用于指定那些屏幕配置跟应用程序是兼容的。在应用的清单中只允许有一个&lt;compatible-screent&gt;元素的实例，但是它能够包含多个&lt;screen&gt;元素。每个&lt;screen&gt;元素指定一个特定的跟应用程序兼容的尺寸—密度组合。 Android系统不会读取清单元素（无论是在安装的时候，还是在运行的时候）。这个元素的信息只能被外部服务使用（如Google Play），以便使其能够更好的理解应用程序跟指定屏幕配置的兼容性。任何没有在这个元素中声明的屏幕配置，都是跟应用程序不兼容的屏幕。这样，外部服务（如Google Play）就不应该把应用程序提供给带有这样屏幕的设备。 警告：通常不应该使用这个清单元素。因为使用这个元素会显著的降低应用程序潜在的用户群。如果设备带有一个应用程序清单中没有列出屏幕配置，那么就不会允许用户安装这个应用程序。在肯定应用程序在所有的屏幕配置上都不会工作时，最后才使用这个方法。相反为了给多个屏幕提供完全的支持，应该按照“支持屏幕多种配置”指南http://developer.android.com/guide/practices/screens_support.html来给不同的屏幕尺寸和密度来添加可选的资源。 如果只想给应用程序设置一个最小的屏幕尺寸，那么就应该使用&lt;supports-screens&gt;元素。例如，如果要让应用程序只对大屏幕（large）或超大屏幕（xlarge）的设备有效，那么&lt;supports-screen&gt;元素就要声明应用程序不支持小屏幕（small）和普通屏幕（normal）的设备。外部服务（如Google Play）根据&lt;supports-screen&gt;的设置来过滤应用程序。还能够使用&lt;supports-screens&gt;元素来声明系统是否应该调整应用程序，以便适应不同的屏幕尺寸。 screen 这个元素指定一个跟应用程序兼容的屏幕配置。 在&lt;compatible-screens&gt;元素内部，至少要有一个这个元素的实例。这个元素必须同时包含android:screenSize和android:screenDensity属性，如果没有同时声明，那么这个元素就会被忽略。 android:screenSize 指定跟应用程序兼容的屏幕配置的屏幕尺寸。可以是以下的值： · small· normal· large· xlarge android:screenDensity 指定跟应用程序兼容的屏幕配置的屏幕密度，可以是以下值： · ldpi· mdpi· hdpi· xhdpi 例子（EXAMPLE）： 如果应用程序仅跟小屏和普通屏幕的设备兼容，而不管屏幕的密度，那么必须要指定八个不同的元素，因为每个屏幕尺寸都有四种不同密度的配置。必须对这些配置逐一声明；任何没有指定的尺寸和密度的组合，都会被认为这个屏幕配置跟应用程序不兼容。如果应用程序只跟小屏幕和普通屏幕兼容，那么清单配置如下： &lt;manifest ... > ... &lt;compatible-screens> &lt;!-- all small size screens --> &lt;screenandroid:screenSize=\"small\"android:screenDensity=\"ldpi\"/> &lt;screenandroid:screenSize=\"small\"android:screenDensity=\"mdpi\"/> &lt;screenandroid:screenSize=\"small\"android:screenDensity=\"hdpi\"/> &lt;screenandroid:screenSize=\"small\"android:screenDensity=\"xhdpi\"/> &lt;!-- all normal size screens --> &lt;screenandroid:screenSize=\"normal\"android:screenDensity=\"ldpi\"/> &lt;screenandroid:screenSize=\"normal\"android:screenDensity=\"mdpi\"/> &lt;screenandroid:screenSize=\"normal\"android:screenDensity=\"hdpi\"/> &lt;screenandroid:screenSize=\"normal\"android:screenDensity=\"xhdpi\"/> &lt;/compatible-screens> &lt;application ... > ... &lt;application> &lt;/manifest> instrumentation&lt;instrumentation android:functionalTest=[\"true\" | \"false\"] android:handleProfiling=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:targetPackage=\"string\"/> 这个元素声明了一个Instrumentation类，这个类能够监视应用程序跟系统的交互。Instrumentation对象会在应用的其他所有组件被实例化之前实例化。 android:functionalTest 这个属性用于指定Instrumentation类是否应该作为一个功能性的测试来运行，如果设置为true，这要运行，否则不应该运行。默认值是false。 android:handleProfiling 这个属性用于指定Instrumentation对象是否会开启和关闭分析功能。如果设置为true，那么由Instrumentation对象来决定分析功能的启动和终止时机，如果设置为false，则分析功能会持续到Instrumentation对象整个运行周期。如果设置为true，会使Instrumentation对象针对一组特定的操作来进行分析。默认值是false。 android:icon 这个属性用于给Instrumentation类设置一个图标。它必须要应用一个可绘制的资源。 android:label 这个属性用于给Instrumentation类设置一个用户可读的标签。这个标签可用原生字符串，也可以引用一个字符串资源。 android:name 这个属性用于设定Instrumentation子类的名称。应该是完整的Java类名（如：com.example.project.StringInstrumentation）。但是，也可以用简写方式(如：.StringInstrumentation)，它的包名会使用元素的package属性中指定的包名。 它没有默认值，必须被指定。 android:targetPackage 这个属性用于指定Instrumenttation对象所监视的应用程序。由包名所标识的应用程序会跟清单的元素的package属性值相关联。 permission &lt;permission android:description=\"string resource\" android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permissionGroup=\"string\" android:protectionLevel=[\"normal\" | \"dangerous\" | \"signature\"|\"signatureOrSystem\"] /> 这个元素用于声明一个安全权限，以便限制对具体的组件、或组件功能、或其他的应用的访问 android:description 这个属性用于给权限定义一个用户可读的懂的描述，它要比标签更长更详细。它可以显示给用户，以便向用户解释权限的含义—例如，当询问用户是否要给另一个应用程序授予对应的权限的时候，就会把这个属性所定义的说明显示给用户。 android:icon 这个属性要引用一个可绘制的图标资源，用于代表这个权限。 android:label 这个属性定义了一个能够显示给用户的权限名称。 为了方便，在开发应用程序时，这个标签能够直接使用原生的字符串。但是当应用程序要正式发布时，它应用使用一个字符串资源来设置，以便它能够跟用户界面中的其他字符串一样被本地化。 android:name 这个属性定义了权限的名称。它是在程序代码中引用的权限的名称—例如，在一个元素中和应用程序组件中的permission属性。 这个名称必须是唯一的，因此要使用Java样式的命名规则—例如：com.example.project.PERMITTED_ACTION android:permissionGroup这个属性用于把这个权限分配到一个权限组中。这个属性的值是一个权限组的名称，它必须是在本应用程序或另一个应用中用元素声明的权限组。如果这个属性没有被设置，那么这个权限不属于任何权限分组。 android:protectionLevel 特权就意味着潜在的风险，因此在判定是否要把权限授予请求的应用程序时，使用这个属性定义来指示系统应该遵循的过程。它可能是表中的值之一。 值 说明 normal 默认值。这是让请求的应用程序访问独立的应用程序级功能的一个较低风险的权限，它会给另一个应用程序、系统、或用户带来最小化的风险。系统在安装应用程序时会自动的把这种类型的权限授予请求的应用程序，而不需要用户明确的批准（虽然在安装应用程序之前，用户始终可以有选择的查看这些权限）。 dangerous 这个是一个较高风险的授权，它会让请求该权限的应用程序访问私有的用户数据，或者控制用户设备，从而给用户带来负面影响。因为这种权限会引入潜在的风险，因此系统不会自动把这种权限授予请求这个权限的应用程序。例如，应用程序所请求的这些dangerous类型的权限，在确认处理之前，可以显示给用户，或者采用一些其他的方法，以避免用户自动把权限授予所请求的应用程序。 signature 系统只会把这种权限授予具有相同数字签名的应用程序，也就是说，请求该权限的应用程序要与声明该权限的应用程序具有相同的数字签名。如果证书匹配，系统就会自动的把该权限请求权限的应用程序，而不会通知用户，也不会要求用户明确的批准。 signatureOrSystem 系统只会把这种权限授予Android系统镜像中应用程序，或者是那些与系统镜像中具有相同证书签名的应用程序。请避免使用这个选项，因为signature类型的权限应该足以满足大多数工作的需要。SingatureOrSystem权限主要用于某些特定的场景，如：多个厂商有一些要构建在系统镜像中的应用程序，并且它们共享一些明确的特殊功能。 permission-tree&lt;permission-tree android:icon=\"drawable resource\" android:label=\"string resource\" ] android:name=\"string\"/> 这个元素用于声明权限树的根节点名称，应用程序持有树中定义的所有权限名称所对应的权限。通过调用PackageManager.addPermission()方法能够动态的来添加新的权限。树中的名称是通过”.”来分离的。例如：如果跟节点的名称是com.example.project.taxes，那么可以使用下面的格式来添加权限： com.example.project.taxes.CALCULATEcom.example.project.taxes.deductions.MAKE_SOME_UPcom.example.project.taxes.deductions.EXAGGERATE 要注意的是，这个元素本身并不声明权限，它只是一个能够放置更多权限的命名空间。关于声明权限的更多信息，请看&lt;permission&gt;元素。 android:icon这个属性定义了一个代表树中所有权限的图标。这个属性必须要引用一个包含图片定义的可绘制资源来设置。 android:label给权限树定义一个用户可读的名称。为了开发应用程序方便，可以直接使用原生的字符串来设置这个属性，但是，当正式发布应用程序时，应该引用一个字符串资源来设置这个属性，以便它能够像用户界面中的其他属性一样能够被本地化。 android:name这个属性定义了权限树根节点的名称。它被用于树中所有权限名称的前缀。应该使用Java样式命名规则，以确保名称的唯一性。在命名中必须要有两个以上的”.”来进行分离，例如：com.example.base是正确的，但com.example就是错误的。 permission-group&lt;permission-group android:description=\"string resource\" android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\"/> 给相关的权限声明一个逻辑上的分组名称。独立的权限要通过&lt;permission&gt;元素的permissionGroup属性来加入权限分组。同一分组的中成员会一起展现在用户的界面中。 要注意的是这个元素本身并不能声明权限，它只是放置相关权限的一个分类。有关声明权限和权限分组的相关信息，请看&lt;permission&gt;元素。 android:description 这个属性用于给权限组定义一个用户可读的说明性文本。这个文本应该比标签更长、更详细。这个属性必须要引用一个字符串资源，跟label属性不一样，它不能够使用原生的字符串。 android:icon 这个属性定义了一个代表权限的图标。这个属性要使用包含图片定义的可绘制资源来定义。 android:label 这个属性给权限组定义了一个用户可读的名称。为了开发方便，在开发时，可以直接使用原生的字符串来设置这个属性。但是，当应用程序正式发布时，应该使用字符串资源来设置，以便能够像用户界面中其他的字符串一样能够被本地化。 android:name 这个属性定义了权限组的名称，它是能够分配给元素的permissionGroup属性的名称。 supports-screens&lt;supports-screens android:resizeable=[\"true\"|\"false\"] android:smallScreens=[\"true\" | \"false\"] android:normalScreens=[\"true\" | \"false\"] android:largeScreens=[\"true\" | \"false\"] android:xlargeScreens=[\"true\" | \"false\"] android:anyDensity=[\"true\" | \"false\"] android:requiresSmallestWidthDp=\"integer\" android:compatibleWidthLimitDp=\"integer\" android:largestWidthLimitDp=\"integer\"/> 这个元素用于指定应用程序所支持的屏幕尺寸，并针对比应用程序所支持的屏幕还要大屏幕，启用屏幕兼容模式。在应用程序中使用这个元素指定应用程序所支持的屏幕尺寸是至关重要的。 如果应用程序调整尺寸属性来填充整个屏幕，那么应用程序就要支持这个给定的尺寸。通常对于大多数应用程序，系统可以很好的完成这种调整工作，并且为了让应用程序在比一个手持设备大的屏幕上工作，你不需要做任何额外的工作。但是，针对不同的屏幕尺寸，通过提供可选的布局资源来优化应用程序的UI经常是很重要的。例如，一个运行在手持设备上的Activity布局，如果想要运行在平板电脑上，就需要修改这个Activity的布局。 但是，如果为了适应不同的屏幕尺寸而调整了尺寸，但应用程序也不能很好的工作，就可以使用元素的属性来控制应用程序是否应该发布给屏幕较小的设备，或者使用系统的屏幕兼容模式，让UI放大以适应较大屏幕的要求。在没有针对较大屏幕尺寸的设计，并且普通的尺寸不能达到合适结果时，屏幕的兼容模式会通过模拟普通尺寸的屏幕和中等密度来缩放UI，以便它能够填充整个屏幕，这样会导致UI模糊，因此针对大屏幕的优化是比较好的。 注意：Android3.2引入了新的属性：android:requiresSmallestWidthDp、android:compatibleWidthLimitDp和android:largestWidthLimitDp。如果正在开发Android3.2或更高版本的应用程序，应该使用这些属性来声明应用程序所支持的屏幕尺寸，而不是基于一般的屏幕尺寸属性。 有关如何正确的支持不同的屏幕尺寸，以便避免给应用程序使用屏幕兼容模式的更多信息，请阅读“Supporting Multiple Screens” android:resizeable 这个属性用于指示针对不同的屏幕尺寸，应用程序是否可以调整尺寸。默认值是true。如果这个属性设置了false，在大的屏幕上，系统会在屏幕兼容模式中运行该应用程序。 这个属性被废弃了，引入这个属性主要是为了帮助应用程序从1.5过渡到1.6。当多屏幕支持被引入时，就不应该在使用它了。 android:smallScreens 这个属性用于指定应用程序是否支持较小外形的屏幕。一个small类型的屏幕被定义成一个比normal（传统的HVGA）类型的屏幕还要小的屏幕。外部服务（如Google Play）不会把不支持小屏的应用程序提供给小屏设备，因为很少有能够确保该应用程序在小屏幕的设备上正常工作的平台。这个属性的默认值是true。 android:normalScreens 这个属性用于指示应用程序是否支持普通外形的屏幕。典型的是HVGA中等密度的屏幕，但是WQVGA低密度和WVGA高密度屏幕也被认为是普通屏幕。这个属性的默认值是true。 android:largeScreens 这个属性用于指示应用程序是否支持较大外形的屏幕。一个large类型的屏幕被定义成一个比normal类型的手持设备的屏幕明显还要大的屏幕，并且为了让应用程序能够良好的使用，使用这个属性时要特别小心，尽管可以依赖系统来调整尺寸，以便能够填充屏幕。 这个属性的默认值实际上在某些版本之间是不同的，因此最好在任何时候都明确的声明这个属性。如果设置为false，系统会启用屏幕兼容模式，这时要格外的小心。 android:xlargeScreens 这个属性用于指示应用程序是否支持超大外形的屏幕。一个xlarge屏幕被定义成一个比large屏幕还要大的屏幕，如平板电脑，为了能够让应用程序良好的使用，需要特别小心的使用这个属性，尽管可以依赖系统来UI的尺寸来填充屏幕。 android:anyDensity 这个属性指明应用程序是否包含了能够适用于任何屏幕密度的资源。 对于支持Android1.6（API Level 4）和更高版本的应用程序，这个属性的默认值是true，并且除非绝对的确认这是应用程序正常工作所必须的，否则不应该把它设置为false。只是在应用程序直接操作位图时才需要禁止这个属性。 android:requiresSmallestWidthDp 这个属性用于指定smallestWidth的最小需求。smallestWidth是屏幕空间的最短尺寸（以dp为单位），它必须是对应用程序的UI是有效的。也就是说它是有效的屏幕的两个维度的尺寸中最短的那个。因此为了考虑设备跟应用程序的兼容性，设备的smallestWidth的值必须要大于等于这个属性所设置的值。通常这个属性值是针对布局所支持的最小宽度，而不是屏幕当前的方向。 例如，典型的手持设备屏幕smallestWidth是320dp；7英寸的平板电脑的smallestWidth是600dp；10英寸的平板电脑的smallestWidth是720dp。这些值一般都是最小的宽度，因为它们是屏幕可用空间中最短的那个尺寸。 这对这个尺寸值的比较，需要考虑屏幕的装饰和系统UI部分。例如，如果系统有一些固定的UI元素要显示，那么系统声明的设备的最小宽度（smallestWidth）要比实际的屏幕尺寸要小，因为被系统UI占用的屏幕像素对于应用的UI是无效的。因此，这个值应该是应用布局所使用的最小宽度需求，而不管屏幕的当前方向。 如果应用程序能够针对较小屏幕尺寸进行正确的调整（small尺寸或最小宽度是320dp以下的屏幕），那么就不需要这个属性。否则就应该使用这个属性值跟应用程序所使用的最小屏幕宽度限定符的值（swdp）相匹配。 警告：Android系统不会关注这个属性，因此它不会影响应用程序在运行时的行为。相反，它被服务（如Google Play）用于过滤应用程序。但是，当前Google Play不支持用这个属性来过滤（在Android3.2上），因此如果应用程序不支持小屏幕设备，就应该继续使用其他的尺寸属性。这个属性在API Level 13中被引入。 android:compatibleWidthLimitDp 这个属性允许在设计应用程序时，通过指定最大的“smallest screen width”来启用屏幕兼容模式，作为一个用户可选的功能。如果设备的有效屏幕的最小边比这个属性值大，那么用户依然能够安装该应用程序，但是在运行时要使用屏幕兼容模式。默认情况下，屏幕兼容模式似乎被禁止的，并且通过会调整布局的尺寸来填充屏幕，但是在系统栏中会有一个按钮，让用户选择屏幕兼容模式的打开和关闭。 如果应用程序跟所有的屏幕尺寸都兼容，并且它的布局能够被正确的调整尺寸，就不需要使用这个属性。 注意：当前，屏幕兼容模式只能模拟320dp宽度的手持设备屏幕，因此如果android:compatibleWidthLimitDp的值比320大，那么屏幕兼容模式就不被适用。 这个在API Level 13中被引入。 android:largestWidthLimitDp 这个属性允许再设计应用程序时，通过指定最大的“smallest screen width”来强制启用屏幕兼容模式。如果设备有效屏幕的最小边比这个属性值大，应用程序就会运行在屏幕兼容模式中，而用户没有办法禁止这种模式。 如果应用程序跟所有的屏幕尺寸都兼容，并且能够被正确的调整尺寸，就不需使用这个属性。否则首先要考虑使用android:compatibleWidthLimitDp属性。只有在因大屏幕尺寸调整而导致破坏了应用程序的功能的时候，并且使用屏幕兼容模式是唯一的方法的时候，才应该使用这个属性。 注意：当前，屏幕兼容模式只能模拟320dp宽度的手持设备屏幕，因此如果android:compatibleWidthLimitDp的值比320大，那么屏幕兼容模式就不被适用。 这个在API Level 13中被引入。 supports-gl-texture&lt;supports-gl-texture android:name=\"string\"/> 这个元素用于声明一个应用程序所支持的GL纹理压缩格式。 一个应用程序支持一种纹理压缩格式，如果应用程序提供了用该格式压缩纹理资源的能力，那么一旦应用程序被安装在设备上，应用程序就能够从.apk文件的内部提供本地的压缩资源，或者在运行时从服务器上下载它们。 每个&lt;supports-gl-texture&gt;元素用android:name属性明确的声明一个所支持的纹理压缩格式。如果应用程序支持多种纹理压缩格式，可以声明多个&lt;supports-gl-texture&gt;元素，例如： &lt;supports-gl-texture android:name=&quot;GL_OES_compressed_ETC1_RGB8_texture&quot; /&gt; &lt;supports-gl-texture android:name=&quot;GL_OES_compressed_paletted _texture&quot; /&gt; 被声明的是一种信息，这就意味着应用程序在安装时，系统本身并不检查这个元素，以确保与设备的支持相匹配。但是，其他的服务（如Google Play）或应用程序能够检查你的应用程序的&lt;supports-gl-texture&gt;的声明，把它作为与你的应用程序进行交互和处理的一部分。由于这个原因，在你的应用程序中声明所有支持的纹理压缩格式的能力是至关重要的。 通常，应用程序和设备会使用相同的已知的字符串（如下表所示）来声明它们所支持的纹理压缩格式。下表中的格式字符串会根据需要随着时间来增长，并且因为值是字符串，所有应用程序可根据需要自由的声明其他的格式。 假设应用程序是建立在SDK平台工具r3或更高的版本上，那么基于&lt;supports-gl-texture&gt;元素的过滤对所有的API级别都是有效的。 android:name这个属性用描述字符串给指定一个由应用程序支持的一个GL纹理压缩格式，通用的描述符的值在下表中被列出。 纹理压缩格式描述符 注释 GL_OES_compressed_ETC1_RGB8_texture 爱立信纹理压缩。在OpenGL ES2.0中被指定，并且在所有支持OpenGL ES2.0的Android设备上都是有效的。 GL_OES_compressed_paletted_texture 通用的调试版纹理压缩。 GL_AMD_compressed_3DC_texture ATI 3Dc纹理压缩 GL_AMD_compressed_ATC_texture ATI纹理压缩。在运行Adreno GPU的设备上有效，包括HTC的Nexus One、Droid Incredible、EVO等。为了最广泛的兼容性，设备也可以声明一个带有GL_ATI_texture_compression_atitc描述符的&lt;supports-gl-texture&gt;元素 GL_EXT_texture_compression_latc 亮度的透明度纹理压缩。 GL_EXT_texture_compression_dxt1 S3 DXT1纹理压缩。支持运行Nvidia Tegra2平台的设备，包括Motorala Xoom、Motorola Atrix、Droid Bionic等。 GL_EXT_texture_compression_s3tc S3纹理压缩，不特定指DXT变种。在运行Nvidia Tegra2平台的设备上被支持，包括Motorala Xoom、Motorola Atrix、Droid Bionic等。如果应用程序需要一个特定的DXT变种，就要用那个变种的描述符来代替这个描述符。 GL_EXT_texture_compression_pvrtc PowerVR纹理压缩。在运行PowerVr SGX530/540 GPU的设备中有效。如Motorola的DRIOID系列，Samsung Galaxy S，Nexus S，和Galaxy Tab等。 Google Play和纹理压缩过滤 Google Play对应用程序的过滤，对用户来说是可见的，以便用户能够看到并只下载那些跟设备兼容的应用程序。它过滤应用程序的方法之一就是通过纹理压缩的兼容性，它会基于GPU的能力来控制应用程序在各种设备上的可用性。 Google Play会通过以下内容的比较，来判断应用程序的纹理压缩与用户设备的兼容性： 应用程序支持的纹理压缩格式—应用程序会在它的清单文件的&lt;supports-gl-texture&gt;元素中声明它所支持的纹理压缩格式； 设备上GPU所支持的纹理压缩格式—设备会把作为它所支持的只读系统属性来报告。 每次把应用程序发布到Google Play的发布网站上时，Google Play会扫描该应用程序的清单文件，并查看&lt;supports-gl-texture&gt;元素，它从这个元素中提取格式描述符，并把它作为跟应用程序的.apk和版本关联的内部元数据来保存。 如果应用程序所支持的任何一种纹理压缩格式也是设备所支持的，那么Google Play就允许用户看到这个应用程序并可下载它。否则，如果应用程序所支持的格式都不被设备所支持，那么Google Play就会过滤掉这些应用程序，使其不能下载。 如果应用程序没有声明任何&lt;supports-gl-texture&gt;元素，那么Google Play不会使用任何基于纹理压缩格式的过滤。 uses-sdk&lt;uses-sdkAndroid: minSdkVersion=\"integer\" android:targetSdkVersion=\"integer\" android:maxSdkVersion=\"integer\"/> 这个元素用API 的级别（一个整数）来说明应用程序会跟哪些Android平台版本兼容。由应用程序给出的API级别会跟给定不同的设备中的Android系统的API级别比较。 尽管这个元素被用于指定API的级别，但它并不是SDK（软件开发工具包）或Android平台的版本号。API级别始终是用一个整数表示。不能够从根API级别关联的Android版本号中获取API级别信息 android:minSdkVersion 一个整数，它指定了应用程序运行所需要的最小的API级别。如果Android系统的API级别被该应用程序清单中的这个属性值小，那么系统就阻止安装该应用程序，应该始终声明这个属性。 警告：如果没有声明这个属性，Android系统就会假设一个默认值1，它表明该应用程序会跟所有的Android版本兼容。如果应用不是跟所有的Android版本兼容（例如，应用要使用在API Level 3中引入的API），并且也没有声明正确的minSdkVersion属性，那么当应用安装到API Level 3小的系统上时，应用程序会在视图访问无效的API时崩溃。由于这个原因，必须要在minSdkVersion属性中声明适当的API Level。 android:targetSdkVersiion 一个整数，它指定了应用程序要运行的目标的API级别。如果没有设置，它的默认值等于给定的minSdkVersion属性值。 android:maxSdkVersion 一个整数，表明该应用要运行的最大的API Level。 uses-configuration 这个属性用于指定该应用程序所需要的硬件和软件功能。例如，应用程序可以用这个元素指定它所需要的物理键盘或特殊的导航设备，如轨迹球。使用这个规范可以避免把应用程序安装在那些不支持其不能工作的设备上。 如果应用程序能够用不同的设备配置来工作，那么它就应该给每个配置包含一个独立的声明。每个声明必须被完成。例如，应用程序需要一个五向导航控制，就要需要一个支持手指操作的触屏，以及一个标准的QWERTY键盘或12键的数字键盘，因此要用两个元素来指定这些需求： &lt;uses-configuration android:reqFiveWayNav=\"true\" android:reqTouchScreen=\"finger\" android:reqKeyboardType=\"qwerty\"/> &lt;uses-configuration android:reqFiveWayNav=\"true\" android:reqTouchScreen=\"finger\" android:reqKeyboardType=\"twelvekey\"/> android:reqFiveWayNav 这个属性用于指定应用程序是否需要五向导航控制，如果设置为true，则需要，否则不需要。五向控制是指能够上、下、左、右移动所选择的对象，并提供调用当前选择对象的方法。它可以是一个D-pad(方向板)、轨迹球等。 如果应用程序需要一个方向控制，但不是一种特殊类型的控制，就可以把这个属性设置为true，并且忽略reqNavigation属性。但是，如果应用程序需要一种特殊的方向控制类型，那么就可以忽略这个属性，并用reqNavigation属性的设置来代替。 android:reqHardKeyboard 这个属性用于指定应用程序是否需要硬键盘，如果设置为true，则需要，否则不需要。 android:reqKeyboardType 这个属性用于指定该应用程序需要的任何键盘的类型。这个属性不区分软/硬键盘。如果需要某种类型的硬键盘，就用这个属性来指定类型，并把reqHardKeyboard属性设置为true。 它的属性值必须是下表中值之一： 值 说明 undefined 应用程序不需要键盘。（键盘的需求没有被定义。）这是默认值。 nokeys 应用程序不需要键盘，明确定义该应用不需要键盘 qwerty 应用程序需要一个标准的QWERTY键盘。 twelvekey 应用程序需要一个像大多电话那样的12键的数字键盘，键盘中包括0~9的数字和“*”号键、“#”号键。 android:reqNavigation 这个属性定义了应用程序所需要的任何导航设备，属性值必须是下表中的值之一： 值 说明 undefined 应用程序不需要任何类型的导航控制。（应用程序的导航需求没有被定义。）这是默认值。 nonav 应用程序不需要到导航控制。 dpad 应用程序要求使用D-pad(方向板)来进行导航控制 trackball 应用程序要求使用轨迹球来进行导航控制 wheel 应用程序要求使用一个导航滚轮来进行导航控制。 如果应用程序要求一个导航控制，但并不关心具体的控制类型，那么就要把reqFiveWayNav属性设置为true，而不是只设置这一个属性。 android:reqTouchScreen 这个属性用于设置应用程序所需要的任何触屏类型。属性值必须是下表中的字符串之一： 值 说明 undefined 应用程序不需要触屏。（触屏的需求不被定义。）这是默认值。 notouch 应用程序不需要触屏 stylus 应用程序需要带有触控笔操作的触屏。 finger 应用程序需要能够用一个手指进行操作的触屏。 uses-feature&lt;uses-feature android:name=\"string\" android:required=[\"true\" | \"false\"] android:glEsVersion=\"integer\"/> 这个元素用于声明一个单独的被应用程序使用的硬件或软件功能。 &lt;uses-feature&gt;声明的目的是通知其他外部实体，该应用程序所依赖的硬件和软件功能。这个元素提供的required属性会让你指定应用程序在所需的功能不存在时，应用程序是否能够正常运行。因为功能能够所支持的Android设备不同，所以&lt;uses-feature&gt;元素被用于描述应用程序所依赖的、重要的、可用的设备功能。 应用程序所声明的一组可用功能对应着一组由Android的PackageManager类定义的可用的功能常量，为了方便，这些常量会在《Google Play和基于功能的过滤》的“功能参考”表中被列出。 如果应用程序需要多个功能，就要分别使用&lt;uses-feature&gt;元素来指定所需的每一个功能，例如：需要设备中带有蓝牙和camera功能的应用程序，要声明两个&lt;uses-feature&gt;元素： &lt;uses-feature android:name=\"android.hardware.bluetooth\" /> &lt;uses-feature android:name=\"android.hardware.camera\" /> 通常应该确保使用&lt;uses-feature&gt;元素来声明应用程序所需的所有功能。 被声明的&lt;uses-feature&gt;元素只是信息化的，这意味着Android系统本身在安装应用程序之前，不会检查设备上所支持的功能的匹配性。但是其他的服务（如Google Play）或应用程序可以检查该应用程序的&lt;uses-feature&gt;声明，把它作为与该应用程序交互的一部分。由于这个原因，声明应用程序要使用的所有的外部功能是至关重要的。 对于某些功能，有可能存在一个特定的属性，以便定义功能的版本，如被使用的Open GL的版本（用glEsVersion来声明）。而有些功能则不需要指定版本属性，如照相机，就只使用name属性来声明。 尽管&lt;uses-feature&gt;元素只在运行API Level 4或更高的版本上才有效，但是还是推荐在所有的应用程序中包含这个元素，即使minSdkVersion的值是3或更低的版本，那么这些运行旧的平台版本的设备会简单忽略掉这个元素。 注意：在声明一个功能时，要记住必须申请相应的权限。例如，在应用程序能够访问Camera的API之前，必须申请CAMERA权限。申请权限是让应用程序能够访问相应的软/硬件，而声明应用程序所使用的功能是为了确保正确的设备兼容性。 android:name 这个属性用描述性的字符串，指定该应用程序所使用的软/硬件功能。有效描述符在《Google Play和基于功能的过滤》的“硬件功能”和“软件功能”表中被列出。 android:required 这个属性用一个布尔值来指定应用程序是否需要在android:name属性中所指定的功能。 true：在设备上不存在指定的功能时，则该应用不能够正常运行。 false：如果设备上存在指定的功能，则应用程序会倾向使用这个功能，但是如果需要，也可设计成没被指定的功能也能够正常运行。 如果没有声明，这个属性的默认值是true。 android:glEsVersion 这个属性用于声明应用程序所需要的OpenGL ES的版本。它的高16位代表主版本号，低16位代表次要版本号，如：要是指定OpenGL ES的版本号是2.0，那么就要设置为0x00020000。要指定的OpenGL ES的版本号是2.1，就要设置为0x00020001。 应用程序在它的清单中应该最多只能指定一个android:glEsVersion属性，如果指定了多个，那么只会使用版本最高的那个android:glEsVersion属性，而其他的将会被忽略。 如果应用程序没有指定一个android:glEsVersion属性，那么就假定应用程序仅需要OpenGL ES1.0，它是在所有的Android设备上都支持的版本。 应用程序能够假设，如果一个平台支持设定的OpenGL ES版本，那么它还会支持所有被设定版本低的OpenGL ES版本，因此，需要OpenGL ES1.0和OpenGL ES2.0的应用程序，必须要指定它所需要的版本时OpenGL ES2.0。 能够用任何版本的OpenGL ES来工作的应用程序，应该仅指定应用所需的最低版本的OpenGL ES。（应用程序能够在运行时检查较高版本的OpenGL ES是否可用。） uses-permission&lt;uses-permission android:name=\"string\" android:maxSdkVersion=\"integer\" /> 这个属性用于给应用程序授予正确的操作的所必须的权限。这些权限是在应用程序安装时被授予的，而不是在运行时授予的。 有关更多的权限信息，请看《AndroidManifest.xml文件详解（三）》文档中“权限”介绍http://blog.csdn.net/fireofstar/article/details/7543067和《Android的安全性和权限》http://blog.csdn.net/fireofstar/article/details/7536803。在android.Manifest.permission类中能够找到由基础平台定义的一个权限列表http://developer.android.com/reference/android/Manifest.permission.html。 android:name 这个属性用于定义权限的名称。它能够是由该应用程序用元素定义的一个权限，也可以是由另外一个应用程序所定义的权限，还可以是有系统定义的标准的权限，如：android:permission.CAMERA或android:permission.READ_CONTACTS等。就像例子中所显示的那样，权限名通常要用包名做为前缀，以保证其唯一性。 android:maxSdkVersion 允许安装的最大API版本的系统，如果超出最大允许范围，则应用不授予许可，不可使用相关功能 uses-permission-sdk-23&lt;uses-permission-sdk-23 android:name=\"string\" android:maxSdkVersion=\"integer\" /> 这个属性用于给应用程序授予正确的操作的所必须的权限,但只在API23及其以上有效 android:name 这个属性用于定义权限的名称。它能够是由该应用程序用元素定义的一个权限，也可以是由另外一个应用程序所定义的权限，还可以是有系统定义的标准的权限 android:maxSdkVersion 允许安装的最大API版本的系统，如果超出最大允许范围，则应用不授予许可，不可使用相关功能 参考资料FireOfStar的专栏谷歌官方API文档","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"Intent中关于Activity的Flag","slug":"Intent中关于Activity的Flag","date":"2016-07-12T14:00:00.000Z","updated":"2017-11-15T05:54:09.907Z","comments":true,"path":"2016/07/12/Intent中关于Activity的Flag/","link":"","permalink":"https://luoweiguang.github.io/2016/07/12/Intent中关于Activity的Flag/","excerpt":"","text":"launchMode启动时默认的Flag standard 为0，即无Flag singleTop 为0，即无Flag singleTask 为0x10000000，即FLAG_ACTIVITY_NEW_TASK singleInstance 为0x10000000，即FLAG_ACTIVITY_NEW_TASK Flag详解FLAG_ACTIVITY_BROUGHT_TO_FRONT默认标志 This flag is not normally set by application code, but set for you by the system as described in the launchMode documentation for the singleTask mode. 通常在应用代码中不需要设置这个FLAG，当launchMode为singleTask时系统会默认设置这个标志。 然而在实际的测试中并没有测试出，而是在另外两种方式设置了此标志位 当从launchMode为singleInstance的Activity跳转到standard、singleTop和singleTask的 当安装或更新一个app后有两个选项，一个为完成一个为打开，点击打开，不管跳多少个Activity,按Home键再从点击桌面图标进入，都会加载一个新的启动的Activity,而不是刚刚执行的，此时的Activity也设有此标志 解决此问题的方法 if((getIntent().getFlags() &amp; Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != 0) { finish(); return; } FLAG_ACTIVITY_CLEAR_TASK清空任务标志 If set in an Intent passed to Context.startActivity(), this flag will cause any existing task that would be associated with the activity to be cleared before the activity is started. That is, the activity becomes the new root of an otherwise empty task, and any old activities are finished. This can only be used in conjunction with FLAG_ACTIVITY_NEW_TASK. 如果Intent中设置了这个标志，会导致含有待启动Activity的Task在Activity被启动前清空。也就是说，这个Activity会成为一个新的root，并且所有旧的activity都被finish掉。这个标志只能与FLAG_ACTIVITY_NEW_TASK 一起使用。 standard与singleTop设置此Flag的同时还要设置FLAG_ACTIVITY_NEW_TASK才有效，而singleTask启动时默认会有FLAG_ACTIVITY_NEW_TASK，所以只要添加此Flag即可，而singleInstance因为新建了个Task，所以设置不设置效果一样 FLAG_ACTIVITY_CLEAR_TOP清空任务中在其之上的Activity If set, and the activity being launched is already running in the current task, then instead of launching a new instance of that activity, all of the other activities on top of it will be closed and this Intent will be delivered to the (now on top) old activity as a new Intent. For example, consider a task consisting of the activities: A, B, C, D. If D calls startActivity() with an Intent that resolves to the component of activity B, then C and D will be finished and B receive the given Intent, resulting in the stack now being: A, B. The currently running instance of activity B in the above example will either receive the new intent you are starting here in its onNewIntent() method, or be itself finished and restarted with the new intent. If it has declared its launch mode to be “multiple” (the default) and you have not set FLAG_ACTIVITY_SINGLE_TOP in the same intent, then it will be finished and re-created; for all other launch modes or if FLAG_ACTIVITY_SINGLE_TOP is set then this Intent will be delivered to the current instance’s onNewIntent(). This launch mode can also be used to good effect in conjunction with FLAG_ACTIVITY_NEW_TASK: if used to start the root activity of a task, it will bring any currently running instance of that task to the foreground, and then clear it to its root state. This is especially useful, for example, when launching an activity from the notification manager. See Tasks and Back Stack for more information about tasks. 如果设置了这个标志，并且待启动的Activity已经存在于当前的task中，那就不会再给这个activity新起一个实例，而是将task中在它之上的其它activity全部关闭，然后把Intent作为一个新的Intent传给这个Activity（当前已在栈顶）。 例如，一个task中存在A,B,C,D四个Activity。如果D调用startActivity() 启动B，那么C和D会被finish掉并且B收到这个Intent，最后栈中只有A，B。 上面例子中运行的B activity既可以在onNewIntent()中接收新的Intent，也可以将自己finish掉然后使用新的Intent重启。如果在它的launch mode中设置了”multiple”（默认），并且intent中没有设置 FLAG_ACTIVITY_SINGLE_TOP 标志，那它就会被finish掉然后重新创建。如果是其它的launchMode或者是设置了FLAG_ACTIVITY_SINGLE_TOP 属性，那就会使用现有的实例的OnNewIntent()方法来接受Intent。 这种启动模式也可以与 FLAG_ACTIVITY_NEW_TASK 一起使用：如果用来启动一个任务的root activity，它会将这个任务中现在运行的实例调到前台，然后将任务清空至只有根Activity的状态。这很有用，例如要从通知中心里启动一个Activity时。 总结： 如果launchMode为standard，且为设置FLAG_ACTIVITY_SINGLE_TOP,则使用此标记打开Activity时，假如栈内已存在此Activity,那么会将栈中此Activity之上包括本身全部销毁，并创建此Activity,如果设置FLAG_ACTIVITY_SINGLE_TOP则与launchMode为singleTop相同 如果launchMode为singleTop，则使用此标记打开Activity时，假如栈内已存在此Activity,那么会将栈中此Activity之上（但不包括本身）全部销毁，调用onNewIntent()，并恢复此Activity 如果launchMode为singleTask,则无影响，因为 singleTask本身就是以此方式进行处理 如果launchMode为singleInstance，无影响 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET(已废弃)任务重置时将任务中在此标记之后的Activity清空 If set, this marks a point in the task’s activity stack that should be cleared when the task is reset. That is, the next time the task is brought to the foreground with FLAG_ACTIVITY_RESET_TASK_IF_NEEDED (typically as a result of the user re-launching it from home), this activity and all on top of it will be finished so that the user does not return to them, but instead returns to whatever activity preceeded it. This is useful for cases where you have a logical break in your application. For example, an e-mail application may have a command to view an attachment, which launches an image view activity to display it. This activity should be part of the e-mail application’s task, since it is a part of the task the user is involved in. However, if the user leaves that task, and later selects the e-mail app from home, we may like them to return to the conversation they were viewing, not the picture attachment, since that is confusing. By setting this flag when launching the image viewer, that viewer and any activities it starts will be removed the next time the user returns to mail. 设置这个标志意味着在activity栈中做一个标记，在Task重置的时候栈就把从标记往上的activity都清除。也就是说，下次这个Task被通过FLAG_ACTIVITY_RESET_TASK_IF_NEEDED调到前台时（通常是由于用户从桌面重新启动），这个activity和它之上的activity都会被finish掉，这样用户就不会再回到他们，而是直接回到在它们之前的activity。 这在应用切换时非常有用。比如，Email应用会需要查看附件，就要调用查看图片的Activity来显示，那这个查看图片的Activity就会成为Email应用任务里的一部分。但是，如果用户离开了Email的任务，过了一会儿由通过Home来选择Email应用，我们会希望它回到查看邮件会话的页面，而不是浏览图片附件的页面，不然就感觉太诡异了。如果在启动查看图片Activity时设置了这个标志，那这个Activity及由它启动的Activity在下一次用户返回邮件时都会被清除。 已经废弃，请使用FLAG_ACTIVITY_NEW_DOCUMENT 当LaunchMode为standard或singleTop此标记在5.0之前与5.0之后有很大差别 5.0之后使用此标志后，会新建一个task,并且后续的Activity都会在此task中，而在overview screen中（总览画面或者叫最近画面，最近任务表）中可以看到有两个 5.0之前都在一个task中 此标记对singleTask无效 此标记对于singleInstance有效，但5.0后在overview screen中不会产生两个 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS不显示在近期任务中 If set, the new activity is not kept in the list of recently launched activities. 如果设置这个标志，这个Activity就不会在近期任务中显示。等同于android:excludeFromRecents=”true”但似乎没效果？ FLAG_ACTIVITY_FORWARD_RESULT转发结果 If set and this intent is being used to launch a new activity from an existing one, then the reply target of the existing activity will be transfered to the new activity. This way the new activity can call setResult(int) and have that result sent back to the reply target of the original activity. 如果Activity A 在启动 Activity B时设置了这个标志，那A的答复目标目标会传递给B，这样一来B就可以通过调用setResult(int) 将返回结果返回给A的答复目标。 简单如下： O —-startActivityForResult()—-&gt; A —-FLAG_ACTIVITY_FORWARD_RESULT—-&gt; B A的答复目标是O，如果A在启动B时使用了这个标志，A就会把答复目标O的信息传递给B，以便B将O作为它的答复目标。此时B调用setResult()时的结果信息都会传递给O，而不会给A。并且此时在A中调用setResult()的内容不会生效。我还没发现使A中setResult()生效的方法。 注意：这个标志不能与startActivityForResult()一起使用。 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY从近期任务中启动的标志 This flag is not normally set by application code, but set for you by the system if this activity is being launched from history (longpress home key). 这个标志通常情况下不会通过应用的代码来设置，而是在通过最近任务启动activity时由系统设置的。 FLAG_ACTIVITY_MULTIPLE_TASKActivity可在多任务运行的标志 Do not use this flag unless you are implementing your own top-level application launcher. Used in conjunction with FLAG_ACTIVITY_NEW_TASK to disable the behavior of bringing an existing task to the foreground. When set, a new task is always started to host the Activity for the Intent, regardless of whether there is already an existing task running the same thing. Because the default system does not include graphical task management, you should not use this flag unless you provide some way for a user to return back to the tasks you have launched. This flag is ignored if FLAG_ACTIVITY_NEW_TASK is not set. See Tasks and Back Stack for more information about tasks. 除非你实现了自己的顶级应用启动器，否则不要使用这个标志。与 FLAG_ACTIVITY_NEW_TASK 一起使用可以不再把已存在的任务唤起到前台。 当被设置时，系统总会为Intent的Activity启动一个新的task，而不管是否已经有已存在的任务在做同样的事情。 因为默认系统不包含图形化的任务管理功能，所以除非你给用户提供了返回到已启动任务的方法，否则就不要用这个标志。 如果FLAG_ACTIVITY_NEW_TASK没有设置，则这个标志也被忽略。 FLAG_ACTIVITY_NEW_DOCUMENT api 21之后加入的一个标识，用来在intent启动的activity的task栈中打开一个document，和documentLaunchMode效果相等，有着不同的documents的activity的多个实例，将会出现在最近的task列表中。单独使用效果和documentLaunchMode=”intoExisting”一样，如果和FLAG_ACTIVITY_MULTIPLE_TASK一起使用效果就等同于documentLaunchMode=”always” FLAG_ACTIVITY_NEW_TASK尝试在新任务中启动Activity的标志（并不一定就会在新的任务中） If set, this activity will become the start of a new task on this history stack. A task (from the activity that started it to the next task activity) defines an atomic group of activities that the user can move to. Tasks can be moved to the foreground and background; all of the activities inside of a particular task always remain in the same order. See Tasks and Back Stack for more information about tasks. This flag is generally used by activities that want to present a “launcher” style behavior: they give the user a list of separate things that can be done, which otherwise run completely independently of the activity launching them. When using this flag, if a task is already running for the activity you are now starting, then a new activity will not be started; instead, the current task will simply be brought to the front of the screen with the state it was last in. See FLAG_ACTIVITY_MULTIPLE_TASK for a flag to disable this behavior. This flag can not be used when the caller is requesting a result from the activity being launched. 设置这个标志可以为待启动的Activity创建一个新的任务。一个任务（从启动它的Activity到任务中的下一个Activity）就是用户可以跳转到的Activity的原子群。任务可以在前台与后台之间切换；在某一特定任务之中的所有Activity一直会保持同样的顺序。 这个标志通常被用来呈现一种”laucher”类型的行为：为用户提供一个可单独解决的事情列表，完全独立于启动他们的Activity之外运行。 使用这个标志时，如果有一个任务已经运行了你要启动的Activity，那就不会在创建新的Activity，而是将现有的任务保持之前的状态直接唤到前台。参见FLAG_ACTIVITY_MULTIPLE_TASK这个标志，可以禁用掉这个行为。 这个标志不能在调用者向待启动Activity请求返回结果时使用。 注意：假设A启动B，如果要让B在新的task中创建，要求这两个Activity的taskAffinity不同。也就是说，设置了这个标志后，新启动的activity并非就一定在新的task中创建，如果A和B在属于同一个package，而且都是使用默认的taskAffinity，那B还是会在A的task中被创建。 所以，只有A和B的taskAffinity不同时，设置了这个标志才会使B被创建到新的task。 FLAG_ACTIVITY_NO_ANIMATION禁用切换动画 If set in an Intent passed to Context.startActivity(), this flag will prevent the system from applying an activity transition animation to go to the next activity state. This doesn’t mean an animation will never run – if another activity change happens that doesn’t specify this flag before the activity started here is displayed, then that transition will be used. This flag can be put to good use when you are going to do a series of activity operations but the animation seen by the user shouldn’t be driven by the first activity change but rather a later one. 禁用掉系统默认的Activity切换动画。 FLAG_ACTIVITY_NO_HISTORY不保存Activity的历史状态 If set, the new activity is not kept in the history stack. As soon as the user navigates away from it, the activity is finished. This may also be set with the noHistory attribute. 如果设置这个标志，新的Activity就不会在历史栈中保存。用户一旦离开，这个Activity就会finish掉。也可以使用noHistory属性设置。 FLAG_ACTIVITY_NO_USER_ACTION 不响应onUserLeaveHint方法 If set, this flag will prevent the normal onUserLeaveHint() callback from occurring on the current frontmost activity before it is paused as the newly-started activity is brought to the front. Typically, an activity can rely on that callback to indicate that an explicit user action has caused their activity to be moved out of the foreground. The callback marks an appropriate point in the activity’s lifecycle for it to dismiss any notifications that it intends to display “until the user has seen them,” such as a blinking LED. If an activity is ever started via any non-user-driven events such as phone-call receipt or an alarm handler, this flag should be passed to Context.startActivity, ensuring that the pausing activity does not think the user has acknowledged its notification. 如果设置了这个标志，可以在避免用户离开当前Activity时回调到 onUserLeaveHint(). 通常，Activity可以通过这个回调表明有明确的用户行为将当前activity切出前台。 这个回调标记了activity生命周期中的一个恰当的点，可以用来“在用户看过通知之后”将它们清除，如闪烁LED灯。 如果Activity是由非用户驱动的事件（如电话呼入或闹钟响铃）启动的，那这个标志就应该被传入Context.startActivity，以确保被打断的activity不会认为用户已经看过了通知。 FLAG_ACTIVITY_PREVIOUS_IS_TOP If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately. 如果启动Activity时设置了这个标志，那当前这个 Activity 不会被当作顶部的 Activity 来判断是否之后新Intent应该被传给栈顶Activity而不是启动一个新的Activity。之前一个的Activity会被当作栈顶，假定当前的Acitvity会立即自己finish掉。 即 A—&gt; B —&gt;C，若B启动C时用了这个标志位，那在启动时B并不会被当作栈顶的Activity，而是用A做栈顶来启动C。此过程中B充当一个跳转页面。 典型的场景是在应用选择页面，如果在文本中点击一个网址要跳转到浏览器，而系统中又装了不止一个浏览器应用，此时会弹出应用选择页面。在应用选择页面选择某一款浏览器启动时，就会用到这个Flag。然后应用选择页面将自己finish，以保证从浏览器返回时不会在回到选择页面。 经常与FLAG_ACTIVITY_FORWARD_RESULT 一起使用。 FLAG_ACTIVITY_REORDER_TO_FRONT任务中的Activity顺序重排 If set in an Intent passed to Context.startActivity(), this flag will cause the launched activity to be brought to the front of its task’s history stack if it is already running. For example, consider a task consisting of four activities: A, B, C, D. If D calls startActivity() with an Intent that resolves to the component of activity B, then B will be brought to the front of the history stack, with this resulting order: A, C, D, B. This flag will be ignored if FLAG_ACTIVITY_CLEAR_TOP is also specified. 如果设置了这个标志，而且被启动的Activity如果已经在运行，那这个Activity会被调到栈顶。 比如，一个任务中有4个Activity：A，B，C，D。如果D调用了startActivity() 来启动B时使用了这个标志，那B就会被调到历史栈的栈顶，结果顺序：A，C，D，B，否则顺序会是：A，B，C，D，B。 如果使用了标志 FLAG_ACTIVITY_CLEAR_TOP，那这个FLAG_ACTIVITY_REORDER_TO_FRONT标志会被忽略。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED If set, and this activity is either being started in a new task or bringing to the top an existing task, then it will be launched as the front door of the task. This will result in the application of any affinities needed to have that task in the proper state (either moving activities to or from it), or simply resetting that task to its initial state if needed. 这个标记在以下情况下会生效：1.启动Activity时创建新的task来放置Activity实例；2.已存在的task被放置于前台。系统会根据affinity对指定的task进行重置操作，task会压入某些Activity实例或移除某些Activity实例， FLAG_ACTIVITY_RETAIN_IN_RECENTS pi21加入。默认情况下通过FLAG_ACTIVITY_NEW_DOCUMENT启动的activity在关闭之后，task中的记录会相对应的删除。如果为了能够重新启动这个activity你想保留它，就可以使用者个flag，最近的记录将会保留在接口中以便用户去重新启动。接受该flag的activity可以使用autoRemoveFromRecents去复写这个request或者调用Activity.finishAndRemoveTask()方法。 FLAG_ACTIVITY_SINGLE_TOP If set, the activity will not be launched if it is already running at the top of the history stack. 设置这个标志之后，如果被启动的Activity已经在栈顶，那它就不会被再次启动。 FLAG_ACTIVITY_TASK_ON_HOME直接返回桌面 If set in an Intent passed to Context.startActivity(), this flag will cause a newly launching task to be placed on top of the current home activity task (if there is one). That is, pressing back from the task will always return the user to home even if that was not the last activity they saw. This can only be used in conjunction with FLAG_ACTIVITY_NEW_TASK. 这个标志可以将一个新启动的任务置于当前的home任务(home activity task)之上（如果有的话）。也就是说，在任务中按back键总是会回到home界面，而不是回到他们之前看到的activity。这个标志只能与FLAG_ACTIVITY_NEW_TASK标志一起用。 比如，A-&gt;B-&gt;C-&gt;D，如果在C启动D的时候设置了这个标志，那在D中按Back键则是直接回到桌面，而不是C。 注意： 只有D是在新的task中被创建时（也就是D的launchMode是singleInstance时，或者是给D指定了与C不同的taskAffinity并且加了FLAG_ACTIVITY_NEW_TASK标志时），使用 FLAG_ACTIVITY_TASK_ON_HOME标志才会生效。 感觉实际使用效果和用 FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK 的效果一样。 参考资料Android开发——Intent中的各种FLAGandroid深入解析Activity的launchMode启动模式，Intent Flag，taskAffinity","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"Activity的启动模式","slug":"Activity的启动模式","date":"2016-07-10T14:00:00.000Z","updated":"2017-11-15T05:54:09.224Z","comments":true,"path":"2016/07/10/Activity的启动模式/","link":"","permalink":"https://luoweiguang.github.io/2016/07/10/Activity的启动模式/","excerpt":"Activity的启动模式可以使用adb shell dumpsys activity命令查看activity的任务栈","text":"Activity的启动模式可以使用adb shell dumpsys activity命令查看activity的任务栈 standard 标准模式，也是系统的默认模式。 每次启动Activity都会创建一个实例，不管实例是否存在。 一个任务栈可以有多个实例，每个实例也可以属于不同的任务 谁启动了此Activity,那么这个Activity就运行在启动它的那个Activity栈 使用ApplicationContext去启动standard模式的Activity会报错，因为非Activity类型的Context并没有任务栈 被创建的生命周期符合典型情况 singleTop 栈顶复用模式 如果新的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建 如何不位于栈顶则会重新创建 当Activity不会重新创建时，会回调onNewIntent方法 位于栈顶时 不在栈顶时 singleTask 栈内复用模式 当一个栈内不存在时，会创建一个Activity 当一个栈内存在时，则会将此Activity在栈内位置以上的Activity全部出栈，并调用onNewIntent方法 当Activity所在的栈不存在时，则会先创建一个任务栈，再创建Activity 栈内存在时 栈内不存在时 singleInstance 单实例模式，一种加强的singleTask模式 具有singleTask所以的特性 当Activity启动时，系统会为它创建一个新的任务栈 跨应用调用standard与singleTop 5.0之前跨应用之间启动Activity，新生成的Activity会放入发送Intent的Task的栈的顶部 5.0之后跨应用之间启动Activity，会创建一个新的Task，新生成的Activity就会放入刚创建的Task中 singleTask 在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么讲创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中 如果singleTask Activity所在的应用进程存在，但是singleTask Activity实例不存在，那么从别的应用启动这个Activity，新的Activity实例会被创建，并放入到所属进程所在的Task中，并位于栈顶位置 更复杂的一种情况，如果singleTask Activity实例存在，从其他程序被启动，那么这个Activity所在的Task会被移到顶部，并且在这个Task中，位于singleTask Activity实例之上的所有Activity将会被正常销毁掉。如果我们按返回键，那么我们首先会回退到这个Task中的其他Activity，直到当前Task的Activity回退栈为空时，才会返回到调用者的TasksingleInstance 这个模式和singleTask差不多，因为他们在系统中都只有一份实例。唯一不同的就是存放singleInstance Activity实例的Task只能存放一个该模式的Activity实例。如果从singleInstance Activity实例启动另一个Activity，那么这个Activity实例会放入其他的Task中。同理，如果singleInstance Activity被别的Activity启动，它也会放入不同于调用者的Task中。 taskAffinity属性 在某些情况下，Android需要知道一个Activity属于哪个Task，即使它没有被启动到一个具体的Task里。这是通过任务共用性（Affinities）完成的。任务共用性（Affinities）为这个运行一个或多个Activity的Task提供了一个独特的静态名称，默认的一个活动的任务共用性（Affinity）是实现了该Activity的.apk包的名字。 当开始一个没有 Intent.FLAG_ACTIVITY_NEW_TASK标志的Activity时，任务共用性affinities不会影响将会运行该新活动的 Task:它总是运行在启动它的Task里。但是，如果使用了NEW_TASK标志，那么共用性（affinity）将被用来判断是否已经存在一个有相同共用性（affinity）的Task。如果是这样，这项Task将被切换到前面而新的Activity会启动于这个Task的顶层。 这种特性在您必须使用NEW_TASK标志的情况下最有用，尤其是从状态栏通知或桌面快捷方式启动活动时。结果是，当用户用这种方式启动您的应用程序时，它的当前Task将被切换到前台，而且想要查看的Activity被放在最上面。你可以在程序清单（Manifest）文件的应用程序application标签中为.apk包中所有的活动分配你自己的任务共用性Affinites，或者在活动标记中为各个活动进行分配。 一些说明其如何使用的例子如下： 如果您的.apk包含多个用户可以启动的高层应用程序，那么您可能需要对用户看到的每个Activity(活动)指定不同的affinities。一个不错的命名惯例是以附加一个以冒号分隔的字符串来扩展您的.apk包名。例如，“ com.android.contacts ”.apk可以有affinities:“com.android.contacts：Dialer”和“ com.android.contacts：ContactsList”。 如果您正在替换一个通知，快捷方式，或其他可以从外部发起的应用程序的“内部”活动，你可能需要明确设定您替代活动的taskAffinity和您准备替代的应用程序一样。例如，如果您想替换contacts详细信息视图（用户可以创建并调用快捷方式），你得把taskAffinity设置成“com.android.contacts”。 跟Task有关的 manifest文件中Activity的特性值介绍android:allowTaskReparenting用来标记Activity能否从启动的Task移动到有着affinity的Task（当这个Task进入到前台时） “true”，表示能移动，“false”，表示它必须呆在启动时呆在的那个Task里。 如果这个特性没有被设定，设定到元素上的allowTaskReparenting特性的值会应用到Activity上。默认值为“false”。 一般来说，当Activity启动后，它就与启动它的Task关联，并且在那里耗尽它的整个生命周期。当当前的Task不再显示时，你可以使用这个特性来强制Activity移动到有着affinity的Task中。典型用法是：把一个应用程序的Activity移到另一个应用程序的主Task中。例如，如果 email中包含一个web页的链接，点击它就会启动一个Activity来显示这个页面。这个Activity是由Browser应用程序定义的，但是，现在它作为email Task的一部分。如果它重新宿主到Browser Task里，当Browser下一次进入到前台时，它就能被看见，并且，当email Task再次进入前台时，就看不到它了。 Actvity的affinity是由taskAffinity特性定义的。Task的affinity是通过读取根Activity的affinity 决定。因此，根Activity总是位于相同affinity的Task里。由于启动模式为“singleTask”和“singleInstance” 的Activity只能位于Task的底部，因此，重新宿主只能限于“standard”和“singleTop”模式。 android:alwaysRetainTaskState 用来标记Activity所在的Task的状态是否总是由系统来保持。 “true”，表示总是；“false”，表示在某种情形下允许系统恢复Task到它的初始化状态。默认值是“false”。 这个特性只针对Task的根Activity有意义；对其它Activity来说，忽略之。一般来说，特定的情形如当用户从主画面重新选择这个Task时，系统会对这个Task进行清理（从stack中删除位于根Activity之上的所有Activivity）。典型的情况，当用户有一段时间没有访问这个Task时也会这么做，例如30分钟。然而，当这个特性设为“true”时，用户总是能回到这个Task的最新状态，无论他们是如何启动的。这非常有用，例如，像Browser应用程序，这里有很多的状态（例如多个打开的Tab），用户不想丢失这些状态。 android:clearTaskOnLaunch 用来标记是否从Task中清除所有的Activity，除了根Activity外（每当从主画面重新启动时） “true”，表示总是清除至它的根Activity，“false”表示不。默认值是“false”。 这个特性只对启动一个新的Task的Activity（根Activity）有意义；对Task中其它的Activity忽略 当这个值为“true”，每次用户重新启动这个Task时，都会进入到它的根Activity中，不管这个Task最后在做些什么，也不管用户是使用 BACK还是HOME离开的。当这个值为“false”时，可能会在一些情形下（参考alwaysRetainTaskState特性）清除Task的 Activity，但不总是。 假设，某人从主画面启动了Activity P，并从那里迁移至Activity Q。接下来用户按下HOME，然后返回Activity P。一般，用户可能见到的是Activity Q，因为它是P的Task中最后工作的内容。然而，如果P设定这个特性为“true”，当用户按下HOME并使这个Task再次进入前台时，其上的所有的 Activity(在这里是Q)都将被清除。因此，当返回到这个Task时，用户只能看到P。 如果这个特性和allowTaskReparenting都设定为“true”，那些能重新宿主的Activity会移动到共享affinity的Task中；剩下的Activity都将被抛弃，如上所述。 android:finishOnTaskLaunch 用来标记当用户再次启动它的Task（在主画面选择这个Task）时已经存在的Activity实例是否要关闭（结束） “true”，表示应该关闭，“false”表示不关闭。默认值是“false”。如果这个特性和allowTaskReparenting都设定为“true”，这个特性胜出。Activity的affinity忽略。这个Activity不会重新宿主，但是会销毁。 android:launchMode用于指示Activity如何启动。这里有四种模式，与Intent对象中的Activity Flags（FLAGACTIVITY*变量）共同作用，来决定Activity如何启动来处理Intent。 android:noHistory 用于标记当用户从Activity上离开并且它在屏幕上不再可见时Activity是否从Activity stack中清除并结束（调用finish()方法）——“true”，表示它应该关闭，“false”，表示不需要。默认值是“false”。 “true”值意味着Activity不会留下历史痕迹。因为它不会在Activity stack的Task中保留，因此，用户不能返回它。 比如启用界面的就可以借用这个。 android:taskAffinity Activity为Task拥有的一个affinity。拥有相同的affinity的Activity理论上属于相同的Task（在用户的角度是相同的“应用程序”）。Task的affinity是由它的根Activity决定的。 affinity决定两件事情——Activity重新宿主的Task（参考allowTaskReparenting特性）和使用FLAG_ACTIVITY_NEW_TASK标志启动的Activity宿主的Task。 默认情况，一个应用程序中的所有Activity都拥有相同的affinity。捏可以设定这个特性来重组它们，甚至可以把不同应用程序中定义的Activity放置到相同的Task中。为了明确Activity不宿主特定的Task，设定该特性为空的字符串。 如果这个特性没有设置，Activity将从应用程序的设定那里继承下来（参考元素的taskAffinity特性）。应用程序默认的affinity的名字是元素中设定的package名。 参考资料Android开发艺术探索深入讲解Android中Activity launchModeTask Affinity","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"Activity的生命周期","slug":"Activity的生命周期","date":"2016-07-09T14:00:00.000Z","updated":"2017-11-15T05:54:08.160Z","comments":true,"path":"2016/07/09/Activity的生命周期/","link":"","permalink":"https://luoweiguang.github.io/2016/07/09/Activity的生命周期/","excerpt":"","text":"正常的Activity生命周期 启动 onCreate -&gt; onStart -&gt; onResume 当跳转到另一个Activity时，当前Activity先onPause，跳转的Activity执行onCreate -&gt; onStart -&gt; onResume 后，当前的Activity执行onStop 当用户返回原Activity时,当前Activity先onPause，原Activity执行onRestart -&gt; onStart -&gt; onResume 后，当前的Activity执行onStop -&gt; onDestyoy 跳转的Activity为透明主题 当跳转到透明主题Activity时，当前Activity先onPause，跳转的透明主题Activity执行onCreate -&gt; onStart -&gt; onResume 后，当前的Activity 不会执行 onStop 当透明主题跳转的不透明主题时，透明主题Activity执行onPause后,最初Activity会执行onStop(因为不可见了),跳转的不透明主题Activity执行onCreate -&gt; onStart -&gt; onResume 后，透明主题Activity 会执行 onStop 当从不透明主题返回透明主题时，当前的Activity执行onPause后,最初的Activity执行onRestart -&gt; onStart , 而后才会到透明主题Activity的创建onCreate -&gt; onStart -&gt; onResume，不透明主题执行onStop -&gt; onDestyoy 当透明主题Activity返回到最初Activity时，透明主题Activity执行onPause，最初的Activity执行onResume(不执行onRestart -&gt; onStart，因为最初Activiyu是可见的，没有执行到onStop)，透明主题Activity执行onStop -&gt; onDestyoy 屏幕切换时Activity的生命周期屏幕切换是会先销毁当前Activiy并重建此Activity,具体流程为onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume 其中onSaveInstanceState用于保存信息，而onRestoreInstanceState用于还原信息，view中也有onSaveInstanceState与onRestoreInstanceState方法，比如EditView,但EditText需要设置id才有效 在Activity中onSaveInstanceState与onRestoreInstanceState都有两种不同参数的方法，一种是(Bundle outState)，另一种是(Bundle outState, PersistableBundle outPersistentState),第二种是API21新增的，使Activity拥有持久化能力 要使用第二种方法要在配置文件中为我们的Activity设置一个属性：android:persistableMode=”persistAcrossReboots” 会在下述情形中被调用： 点击home键回到主页或长按后选择运行其他程序 按下电源键关闭屏幕 启动新的Activity 横竖屏切换时，肯定会执行，因为横竖屏切换的时候会先销毁Act，然后再重新创建 重要原则：当系统”未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（你可以保存也可以不保存）。 Activity的其他方法 onWindowFocusChanged 在Activity窗口获得或失去焦点时被调用 获取焦点时调用 失去焦点时调用 onApplyThemeResource 设置主题时调用，第一次调用在onCreate()前，使用setTheme()方法也会调用 onConfigurationChanged 在AndroidManifest.xml给Activity配置了相应的configChanges属性，这个时候Activity就不会摧毁后重新创建Activity，而只会回调此方法 参考资料Android开发艺术探索bug修复-android中的onCreate两个参数的方法是什么鬼？","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://luoweiguang.github.io/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"https://luoweiguang.github.io/tags/Android基础/"}]},{"title":"JVM运行时数据区","slug":"JVM运行时数据区","date":"2016-05-23T09:00:00.000Z","updated":"2017-07-31T14:11:30.359Z","comments":true,"path":"2016/05/23/JVM运行时数据区/","link":"","permalink":"https://luoweiguang.github.io/2016/05/23/JVM运行时数据区/","excerpt":"","text":"程序计数器（PC） 每条线程都需要由一个独立的程序计数器 程序计数器可以看作是当前线程所执行的字节码的行号指示器 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器指为空（Undefined） Java虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型 Java虚拟机栈也是线程私有的，它的生命周期与线程相同 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 局部变量表存放了编译器克制的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型（指向了一条字节码指令的地址） 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflow异常 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常 本地方法栈 本地方法栈为虚拟机使用到的Native方法服务 虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它 由的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法和虚拟机栈合二为一 本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常 Java堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建 此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存 方法区 方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 运行时常量池 运行时常量池是方法区的一部分 常量池用于存放编译器生成的各种字面量和符号引用 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java进阶","slug":"Java进阶","permalink":"https://luoweiguang.github.io/tags/Java进阶/"},{"name":"JVM","slug":"JVM","permalink":"https://luoweiguang.github.io/tags/JVM/"}]},{"title":"ServerSocket","slug":"ServerSocket","date":"2016-05-12T13:00:00.000Z","updated":"2017-08-06T07:35:02.696Z","comments":true,"path":"2016/05/12/ServerSocket/","link":"","permalink":"https://luoweiguang.github.io/2016/05/12/ServerSocket/","excerpt":"在Java中，服务器程序的基本生命周期\n\n使用一个ServerSocket()构造函数在一个特定端口创建一个新的ServerSocket。\nServerSocket使用其accept()方法监听这个端口的入站连接。accept()会一直阻塞，直到一个客户端尝试建立连接，此时accept()将返回一个连接客户端和服务器的Socket对象。\n根据服务器的类型，会调用Socket的getInputStream()方法或getOutputStream()方法，或者这两个方法都调用，以获得与客户端通信的输入和输出流。\n服务器和客户端根据已协商的协议交互，直到要关闭连接\n服务器或客户端（或二者）关闭连接\n服务器返回到步骤2，等待下一次连接\n","text":"在Java中，服务器程序的基本生命周期 使用一个ServerSocket()构造函数在一个特定端口创建一个新的ServerSocket。 ServerSocket使用其accept()方法监听这个端口的入站连接。accept()会一直阻塞，直到一个客户端尝试建立连接，此时accept()将返回一个连接客户端和服务器的Socket对象。 根据服务器的类型，会调用Socket的getInputStream()方法或getOutputStream()方法，或者这两个方法都调用，以获得与客户端通信的输入和输出流。 服务器和客户端根据已协商的协议交互，直到要关闭连接 服务器或客户端（或二者）关闭连接 服务器返回到步骤2，等待下一次连接 构造 public ServerSocket()创建非绑定服务器套接字。 public ServerSocket(int port)创建绑定到特定端口的服务器套接字。 public ServerSocket(int port,int backlog)利用指定的backlog创建服务器套接字并将其绑定到指定的本地端口号。 public ServerSocket(int port,int backlog,InetAddress bindAddr)使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。参数：port - 本地TCP端口,当为0时表示选择任意端口backlog - 队列的最大长度bindAddr - 要将服务器绑定到的InetAddress 连接 public Socket accept()侦听并接受到此套接字的连接。 public void bind(SocketAddress endpoint)将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 public void bind(SocketAddress endpoint,int backlog)将 ServerSocket 绑定到特定地址（IP 地址和端口号）。参数：endpoint - 要绑定的 IP 地址和端口号。backlog - 队列的最大长度。 获取ServerSocket信息 public InetAddress getInetAddress()返回此服务器套接字的本地地址。如果套接字是未绑定的，则返回 null。 public int getLocalPort()返回此套接字在其上侦听的端口。 如果尚未绑定套接字，则返回 -1。 getLocalSocketAddress返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。 状态 public boolean isClosed()返回 ServerSocket 的关闭状态。 public boolan isBound()返回 ServerSocket 的绑定状态。 Socket选项 SO_TIMEOUTSO_TIMEOUT是accept()在抛出java.io.INterruptedIOException异常前等待入站连接的时间，以毫秒计，如果为0，表示永远不会超时使用public void setSoTimeout(int timeout)修改使用public int getSoTimeout()查询 SO_REUSEADDR与Socket的SO_REUSEADDR选项类型，它确定了是否允许一个新的Socket绑定到之前使用过的一个端口使用public void setReuseAddress(boolean on)修改使用public boolean getReuseAddress()查询 SO_RCVBUFSO_RCVBUF选项设置了ServerSocket接受的客户单Socket默认接收缓冲区大小设置大于64kb的接收缓冲区大小必须在绑定之前设置使用public void setReceiveBufferSize(int size)修改使用public int getReceiveBufferSize()查询 public void setPerformancePreferences(int connectionTime,int latency,int bandwidth)设置此 ServerSocket 的性能首选项。参数：connectionTime - 表明短连接时间的相对重要性的 intlatency - 表明低延迟的相对重要性的 intbandwidth - 表明高带宽的相对重要性的 int","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"网络","slug":"网络","permalink":"https://luoweiguang.github.io/tags/网络/"}]},{"title":"Socket","slug":"Socket","date":"2016-05-11T12:00:00.000Z","updated":"2017-08-06T07:37:38.777Z","comments":true,"path":"2016/05/11/Socket/","link":"","permalink":"https://luoweiguang.github.io/2016/05/11/Socket/","excerpt":"基本操作Socket是两台主机之间的一个连接。它可以完成7个基本操作\n\n连接远程机器\n发送数据\n接收数据\n关闭连接\n绑定端口\n监听入站数据\n在绑定端口上接收来自远程机器的连接\n\nJava的Socket类提供了对应前4个操作的方法，后三个仅服务器需要，即等待客户端的连接","text":"基本操作Socket是两台主机之间的一个连接。它可以完成7个基本操作 连接远程机器 发送数据 接收数据 关闭连接 绑定端口 监听入站数据 在绑定端口上接收来自远程机器的连接 Java的Socket类提供了对应前4个操作的方法，后三个仅服务器需要，即等待客户端的连接 构造 Socket(InetAddress address, int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 Socket(String host, int port)创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket(InetAddress address, int port, InetAddress localAddr, int localPort)创建一个套接字并将其连接到指定远程地址上的指定远程端口。 Socket(String host, int port, InetAddress localAddr, int localPort)创建一个套接字并将其连接到指定远程主机上的指定远程端口。 以上四种方法在创建对象时都会连接socket如果localPort参数传入0，Java会随机选择1024到65535之间的一个可用端口 Socket()通过系统默认类型的 SocketImpl 创建未连接套接字 Socket(Proxy proxy)创建一个未连接的套接字并指定代理类型（如果有），该代理不管其他设置如何都应被使用。 获取Socket的信息 public InetAddress getInetAddress()返回套接字连接的地址。 public int getPort()返回此套接字连接到的远程端口 public InetAddress getLocalAddress()获取套接字绑定的本地地址 public int getLocalPort()返回此套接字绑定到的本地端口 public InputStream getInputStream()返回此套接字的输入流。 public OutputStream getOutputStream()返回此套接字的输出流。 连接 public void connect(SocketAddress endpoint) public void connect(SocketAddress endpoint,int timeout)当创建未连接套接字后，使用此方法将此套接字连接到服务器参数：endpoint - SocketAddresstimeout - 要使用的超时值（以毫秒为单位）。 关闭 public void close()关闭此套接字。 public void shutdownInput()关闭输入流，关闭输入之后再读取输入流会返回-1 public void shutdownOutput()关闭输出流，关闭输出之后再写入Socket则会抛出一个IOException异常 状态 public boolean isInputShutdown()返回是否关闭套接字连接的半读状态。如果已关闭套接字的输入，则返回 true public boolean isOutputShutdown()返回是否关闭套接字连接的半写状态。如果已关闭套接字的输出，则返回 true public boolean isClosed()如果socket关闭，isClosed()方法会返回ture，否则返回false，如果Socket从一开始从未连接，isClosed()也返回false public boolean isConnected()Socket是否从未连接过一个远程主机 public boolan isBound()Socket是否成功地绑定到本地系统上的出站端口 设置Socket选择 TCP_NODELAY设置TCP_NODELAY为ture可确保包会尽可能块的发送，而无论包的大小。即关闭了Socket的缓冲使用public boolean getTcpNoDelay()查询使用public void setTcpNoDelay(boolean on)修改 SO_TIMEOUT正常情况下，尝试从Socket读取数据时，read()调用会阻塞尽可能长的时间来得到足够的字节。设置SO_TIMEOUT可以确保这次调用组设的时间不会超过某个固定的毫秒数。0被解释为无限超时，这是默认值使用public int getSoTimeout()查询使用public void setSoTimeout(int timeout)修改，timeout以毫秒为单位 SO_LINGERSO_LINGER选项指定了Socket关闭时如何处理尚未发送的数据报。默认情况下，close()方法将立即返回，但系统仍会尝试发送剩余的数据。如果延迟时间设置为0，那么当Socket关闭时，所有未发送的数据包都将被丢弃。如果SO_LINGER打开而且延迟时间设置为正数，close()方法会阻塞（阻塞时间为指定的秒数），等待发送数据和接收确认，当过去相应秒数后，Socket关闭，所有剩余的数据都不会发送，也不会收到确认使用public int getSoLinger()查询，当返回-1时表示该项被禁用使用public void setSoLinger(boolean on, int linger)修改，linger以秒为单位 SO_SNDBUFSO_SNDBUF选项控制用于网络输入的建议的发送缓冲区大小使用public int getSendBufferSize()查询使用public void setSendBufferSize(int size)修改 SO_RCVBUFSO_RCVBUF选项控制用于网络输入的建议的接收缓冲区大小使用public int getReceiveBufferSize()查询使用public void setReceiveBufferSize(int size)修改 SO_KEEPALIVE如果打开了SO_KEEPALIVE,客户端会通过一个空闲连接发送一个数据包（一般两小时一次），以确保服务器未崩溃。如果服务器没有响应这个包，客户端会持续尝试11分钟多的时间，直到接收到响应为止。如果在12分钟内未收到响应，客户端就关闭socket。如果没有SO_KEEPALIVE,不活动的客户端可能会永久存在下去，而不会注意到服务器已经崩溃使用public boolean getKeepAlive()查询使用public void setKeepAlive(boolean on)修改 OOBINLINE默认情况下，此选项是禁用的。如果希望接收正常数据中的紧急数据，就需要设置此项为true使用public boolean getOOBInline()查询使用public void setOOBInline(boolean on)修改 SO_REUSEADDR当一个Socket关闭时，可能不会立即释放本地端口，这将会阻止所有其他Socket绑定到一个已知端口，如果开启SO_REUSEADDR(默认为关闭)，就允许另一个Socket绑定到这个端口使用public boolean getReuseAddress()查询使用public void setReuseAddress(boolean on)修改要正常使用这些方法，setReuseAddress()必须在为这个端口绑定新Socket之前调用。这以为着Socket必须使用无参数构造函数以非连接状态创建，然后调用setReuseAddress(ture),再使用connect()方法连接Socket。之前连接的Socket和重用老地址的新Socket都必须设置SO_REUSEADDR为ture，这样才能生效 IP_TOS使用public int getTrafficClass()查询使用public void setTrafficClass(int tc)修改tc的值为0到255之间，这个字节的高六位包含一个差分服务代码点（DSCP）值，低两位包含一个显式拥塞通知（ECN）值 常用DSCP值和解释 PHB(逐跳行为) 二进制值 用途 默认 00000 Best-effort（尽力）业务流 加速转发 101110 低损耗，低延迟，低抖动业务流，通常仅限于网络容量的30%或更低 保证转发 多个 保证最多以一个指定速率传送 类选择器 xxx000 与IPv4 TOS首部向后兼容 保证转发优先级分类 第一类（最低优先级） 第二类 第三类 第四类（最高优先级） 低丢包率 AF11(001010) AF21(010010) AF31(011010) AF41(100010) 中丢包率 AF12(001100) AF22(010100) AF32(011100) AF42(100100) 高丢包率 AF13(001110) AF23(010110) AF33(011110) AF43(100110) public void setPerformancePreferences(int connectionTime,int latency,int bandwidth)设置此套接字的性能偏好。 此方法在连接套接字后调用此方法无效。参数：connectionTime - 表达短连接时间的相对重要性的 intlatency - 表达低延迟的相对重要性的 intbandwidth - 表达高带宽的相对重要性的 int","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"网络","slug":"网络","permalink":"https://luoweiguang.github.io/tags/网络/"}]},{"title":"URLConnection","slug":"URLConnection","date":"2016-05-09T13:00:00.000Z","updated":"2017-08-06T07:39:39.258Z","comments":true,"path":"2016/05/09/URLConnection/","link":"","permalink":"https://luoweiguang.github.io/2016/05/09/URLConnection/","excerpt":"基本步骤使用URLconnection类的程序遵循以下基本步骤\n\n构造一个URL对象\n调用这个URL对象的openConnection()获取一个对应URL的URLConnected对象\n配置这个URLConnected\n读取首部字段\n获得输入流并读取数据\n获得输出流并写入数据\n关闭连接\n","text":"基本步骤使用URLconnection类的程序遵循以下基本步骤 构造一个URL对象 调用这个URL对象的openConnection()获取一个对应URL的URLConnected对象 配置这个URLConnected 读取首部字段 获得输入流并读取数据 获得输出流并写入数据 关闭连接 配置连接protected URL url;protected boolean doInput = ture;protected boolean doOutput = false;protected boolean allowUserInteraction = defaultAllowUserInteraction;protected boolean useCaches = defaultUseCaches;protected long ifModifiedSince = 0;protected boolean connected = false; protected URL urlurl字段指定了这个URLConnection连接到URL。构造行数会在创建URLConnection时设置这个字段，此后不能再改变使用getURL() URL查询 protected boolean connected如果连接已经打开，boolean字段connected为ture，如果连接关闭，则为false。没有直接读取或改变connected值的方法，不过任何导致URLConnection连接的方法都会将这个变量设置为ture，任何导致断开的方法都会导致设置为false protected boolean allowUserInteractionallowUserInteraction字段指示了是否允许用户交互，默认值为false。值为ture时表示允许用户进行交互，这个值只能在URLConnected连接前设置使用setAllowUserInteraction(boolean allowuserinteraction) void修改使用getAllowUserInteraction() boolean查询 protected boolean doInputURLConnection可以读取服务器，写入服务器，或者同时用于读/写服务器。如果URLconnection可以用来读取，保护类型boolean字段doInput就为ture，否则为false。默认值为ture使用setDoInput(boolean doinput) void修改使用getDoInput() boolean查询 protected boolean doOutput如果URLconnection可以用于写入，保护类型boolean字段doOutput就为ture，否则为false。默认值为false使用setDoOutput(boolean dooutput) void修改使用getDoOutput() boolean查询 protected long ifModifiedSince客户端最后获取文档的时间，即http首部中的If-Modified-Since使用setIfModifiedSince(long ifmodifiedsince)修改使用getIfModifiedSince() long查询 protected boolean useCachesuseCaches变量表示是否使用缓存，默认值为ture，表示使用缓存，false表示不使用缓存使用setUseCaches(boolean usecaches) void修改使用getUseCaches() boolean查询获取任意首部字段 public String getHeaderField(String name)返回指定首部字段的值，首部的名不区分大小写，也不包含结束冒号 public String getHeaderFieldKey(int n)这个方法返回第n个首部字段的字段名，请求方法本身是第0个首部，它的键为null.第一个首部即编号为1 public String getHeaderField(int n)这个方法返回第n个首部字段的值，第一个首部即编号为1 public long getHeaderFiledDate(String name,long default)这个方法首先获取由name参数指定的首部字段，然后尝试将这个字符串转换为一个long，如果无法找到请求的首部字段或无法转换为long，则返回default参数 读取首部 public String getContentType()getContentType()方法返回响应主体的MIME内容类型。它依赖于Web服务器来发送一个有效的内容类型，如果没有提供内容类型，它不会抛出异常，而是返回null public int getContentLength()getContentLength()方法告诉你内容有多少字节，如果没有Content-length首部，getContentLength()就返回-1public long getContentLengthLong()//Java 7同上 public String getContentEncoding()getContentEncoding()方法指出内容是如何编码的，如果发送的内容没有编码，这个方法就返回null public long getDate()文档发送时间，如果HTTP首部不包含Data字段，getDate()就返回0 public long getExpiration()文档过期时间，如果首部不包含Expiration字段,getExpiration()就返回0，这表示文档不会过期 public long getLastModified()返回文档的最后修改日期，如果HTTP首部没有包括Last-modified字段，这个方法就返回0 public int getHeaderFiledInt(String name,long default)这个方法首先获取由name参数指定的首部字段，然后尝试将这个字符串转换为一个int，如果无法找到请求的首部字段或无法转换为int，则返回default参数 读取服务器数据 public InputStreamgetInputStream() 向服务器写入数据 public OutputStream getOutputStream() 超时控制socket等待建立连接的时间使用setConnectTimeout(int timeout) void设置使用getConnectTimeout() int查询 控制输入流等待数据到达的时间使用setReadTimeout(int timeout) void设置使用getReadTimeout() int查询 两种超时都将0看做永远不超时","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"网络","slug":"网络","permalink":"https://luoweiguang.github.io/tags/网络/"}]},{"title":"InetAddress","slug":"InetAddress","date":"2016-05-08T11:00:00.000Z","updated":"2017-08-06T09:12:34.939Z","comments":true,"path":"2016/05/08/InetAddress/","link":"","permalink":"https://luoweiguang.github.io/2016/05/08/InetAddress/","excerpt":"创建InetAddress对象\ngetByAddress(byte[] addr) static InetAddress  根据提供的IP地址创建 InetAddress\ngetByAddress(String host, byte[] addr) static InetAddress  根据提供的主机名和IP地址创建 InetAddress\ngetByName(String host) static InetAddress  根据提供的主机名创建 InetAddress\ngetAllByName(String host) static InetAddress[]  在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组。\ngetLocalHost() static InetAddress  返回本地主机\ngetLoopbackAddress() static InetAddress  返回回送地址，在Windows系统中，采用127.0.0.1\n","text":"创建InetAddress对象 getByAddress(byte[] addr) static InetAddress 根据提供的IP地址创建 InetAddress getByAddress(String host, byte[] addr) static InetAddress 根据提供的主机名和IP地址创建 InetAddress getByName(String host) static InetAddress 根据提供的主机名创建 InetAddress getAllByName(String host) static InetAddress[] 在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组。 getLocalHost() static InetAddress 返回本地主机 getLoopbackAddress() static InetAddress 返回回送地址，在Windows系统中，采用127.0.0.1 获取方法 getHostName() String 获取此IP地址的主机名。 getCanonicalHostName() String 获取此IP 地址的完全限定域名。如果安全检查不允许操作，则返回IP 地址的文本表示形式。 getAddress() byte[] 返回此InetAddress对象的原始 IP 地址。 getHostAddress() String 返回IP地址字符串（以文本表现形式）。 地址类型 isAnyLocalAddress() boolean 如果地址是通配地址，返回ture。IPv4的通配符地址是0.0.0.0 isLoopbackAddress() boolean 如果地址是回送地址，返回ture。IPv4的loopback地址的范围是127.0.0.0 ~ 127.255.255.255 isLinkLocalAddress() boolean 如果地址是本地连接地址，返回ture。IPv4的本地连接地址的范围是 169.254.0.0 ~ 169.254.255.255 isSiteLocalAddress() boolean 如果地址是地区本地地址，返回ture。IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255 isMulticastAddress() boolean 如果地址是广播地址，返回ture。IPv4的广播地址的范围是224.0.0.0 ~ 239.255.255.255 isMCGlobal() boolean 如果地址是全球范围的广播地址，返回ture。IPv4的广播地址除了224.0.0.0和第一个字节是239的IP地址都是全球范围的广播地址 isMCNodeLocal() boolean 如果地址本地接口广播地址，返回ture。所有的IPv4广播地址都不是本地接口广播地址 isMCLinkLocal() boolean 如果地址是子网广播地址，返回ture。IPv4的子网广播地址的范围是 224.0.0.0 ~ 224.0.0.255 isMCSiteLocal() boolean 如果地址是站点范围的广播地址，返回ture。IPv4的站点范围广播地址的范围是239.255.0.0 ~ 239.255.255.255 isMCOrgLocal() boolean 如果地址是组织范围的广播地址，返回ture。IPv4的组织范围广播地址的第一个字节是239，第二个字节不小于192，第三个字节不大于195 测试可达性 isReachable(int timeout) boolean isReachable(NetworkInterface netif, int ttl, int timeout) boolean netif - 将用于完成测试的NetworkInterface；或者用于任何接口的nullttl - 要尝试的最大跳数或默认值 0timeout - 调用中止前的时间（以毫秒为单位） 参考资料Java网络编程利用InetAddress类确定特殊IP地址","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"网络","slug":"网络","permalink":"https://luoweiguang.github.io/tags/网络/"}]},{"title":"Java与正则表达式","slug":"Java与正则表达式","date":"2016-05-04T11:00:00.000Z","updated":"2017-08-06T09:25:08.401Z","comments":true,"path":"2016/05/04/Java与正则表达式/","link":"","permalink":"https://luoweiguang.github.io/2016/05/04/Java与正则表达式/","excerpt":"Pattern类\n\n\n返回类型\n方法名\n解释\n\n\n\n\nstatic Pattern\ncompile(String regex)\n将给定的正则表达式编译到模式中。\n\n\nstatic Pattern\ncompile(String regex, int flags)\n将给定的正则表达式编译到具有给定标志的模式中。\n\n\nint\nflags()\n返回此模式的匹配标志。\n\n\nMatcher\nmatcher(CharSequence input)\n创建匹配给定输入与此模式的匹配器。\n\n\nstatic boolean\nmatches(String regex, CharSequence input)\n编译给定正则表达式并尝试将给定输入与其匹配。\n\n\nString\npattern()\n返回在其中编译过此模式的正则表达式。\n\n\nstatic String\nquote(String s)\n返回指定 String 的字面值模式 String。\n\n\nString[]\nsplit(CharSequence input)\n围绕此模式的匹配拆分给定输入序列。\n\n\nString[]\nsplit(CharSequence input, int limit)\n围绕此模式的匹配拆分给定输入序列。\n\n\nString\ntoString()\n返回此模式的字符串表示形式。\n\n\n","text":"Pattern类 返回类型 方法名 解释 static Pattern compile(String regex) 将给定的正则表达式编译到模式中。 static Pattern compile(String regex, int flags) 将给定的正则表达式编译到具有给定标志的模式中。 int flags() 返回此模式的匹配标志。 Matcher matcher(CharSequence input) 创建匹配给定输入与此模式的匹配器。 static boolean matches(String regex, CharSequence input) 编译给定正则表达式并尝试将给定输入与其匹配。 String pattern() 返回在其中编译过此模式的正则表达式。 static String quote(String s) 返回指定 String 的字面值模式 String。 String[] split(CharSequence input) 围绕此模式的匹配拆分给定输入序列。 String[] split(CharSequence input, int limit) 围绕此模式的匹配拆分给定输入序列。 String toString() 返回此模式的字符串表示形式。 flag的取值范围如下： 编译标志 效果 Pattern.CASE_INSENSITIVE(?i) 默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹配，只要将UNICODE_CASE与这个标志合起来就行了。 Pattern.COMMENTS(?x) 在这种模式下，匹配时会忽略(正则表达式里的)空格字符(注：不是指表达式里的”//s”，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。 Pattern.MULTILINE(?m) 在这种模式下，’^’和’\\$’分别匹配一行的开始和结束。此外，’^’仍然匹配字符串的开始，’\\$’也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。 Pattern.LITERAL 指定此标志后，指定模式的输入字符串就会作为字面值字符序列来对待。输入序列中的元字符或转义序列不具有任何特殊意义。标志 CASE_INSENSITIVE 和 UNICODE_CASE在与此标志一起使用时将对匹配产生影响。其他标志都变得多余了。 Pattern.DOTALL(?s) 在这种模式下，表达式’.’可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式’.’不匹配行的结束符。 Pattern.UNIX_LINES(?d) 在这个模式下，只有’/n’才被认作一行的中止，并且与’.’，’^’，以及’$’进行匹配。 Pattern.UNICODE_CASE(?u) 在这个模式下，如果你还启用了CASE_INSENSITIVE标志，不区分大小写的匹配将以符合 Unicode Standard 的方式完成。默认情况下，不区分大小写的匹配假定仅匹配 US-ASCII 字符集中的字符。 Pattern.CANON_EQ 启用规范等价。指定此标志后，当且仅当其完整规范分解匹配时，两个字符才可视为匹配。例如，当指定此标志时，表达式 “a\\u030A” 将与字符串 “\\u00E5” 匹配。默认情况下，匹配不考虑采用规范等价。 正则表达式的构造 构造 匹配 字符 x 字符x \\^ ^ \\\\ 反斜线字符 \\0n 带有八进制值 0 的字符 n (0 &lt;= n &lt;= 7) \\0nn 带有八进制值 0 的字符 nn (0 &lt;= n &lt;= 7) \\0mnn 带有八进制值 0 的字符 mnn（0 &lt;= m &lt;= 3、0 &lt;= n &lt;= 7） \\xhh 带有十六进制值 0x 的字符 hh \\uhhhh 带有十六进制值 0x 的字符 hhhh \\t 制表符 (‘\\u0009’) \\n 新行（换行）符 (‘\\u000A’) \\r 回车符 (‘\\u000D’) \\f 换页符 (‘\\u000C’) \\a 报警 (bell) 符 (‘\\u0007’) \\e 转义符 (‘\\u001B’) \\cx 对应于 x 的控制符 字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \\d 数字：[0-9] \\D 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] POSIX 字符类（仅 US-ASCII） \\p{Lower} 小写字母字符：[a-z] \\p{Upper} 大写字母字符：[A-Z] \\p{ASCII} 所有 ASCII：[\\x00-\\x7F] \\p{Alpha} 字母字符：[\\p{Lower}\\p{Upper}] \\p{Digit} 十进制数字：[0-9] \\p{Alnum} 字母数字字符：[\\p{Alpha}\\p{Digit}] \\p{Punct} 标点符号：!”#\\$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{\\ }~ \\p{Graph} 可见字符：[\\p{Alnum}\\p{Punct}] \\p{Print} 可打印字符：[\\p{Graph}\\x20] \\p{Blank} 空格或制表符：[ \\t] \\p{Cntrl} 控制字符：[\\x00-\\x1F\\x7F] \\p{XDigit} 十六进制数字：[0-9a-fA-F] \\p{Space} 空白字符：[ \\t\\n\\x0B\\f\\r] java.lang.Character 类（简单的 java 字符类型） \\p{javaLowerCase} 等效于 java.lang.Character.isLowerCase() \\p{javaUpperCase} 等效于 java.lang.Character.isUpperCase() \\p{javaWhitespace} 等效于 java.lang.Character.isWhitespace() \\p{javaMirrored} 等效于 java.lang.Character.isMirrored() Unicode 块和类别的类 \\p{Lu} 大写字母 \\p{Ll} 小写字母 \\p{Sc} 货币符号 边界匹配器 ^ 行的开头 $ 行的结尾 \\b 单词边界 \\B 非单词边界 \\A 输入的开头 \\G 上一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符（如果有的话） \\z 输入的结尾 匹配优先量词 X? X， 一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 忽略优先量词 X?? X， 一次或一次也没有 X*? X，零次或多次 X+? X，一次或多次 X{n}? X，恰好 n 次 X{n,}? X，至少 n 次 X{n,m}? X，至少 n 次，但是不超过 m 次 占用优先量词 X?+ X，一次或一次也没有 X*+ X，零次或多次 X++ X，一次或多次 X{n}+ X，恰好 n 次 X{n,}+ X，至少 n 次 X{n,m}+ X，至少 n 次，但是不超过 m 次 逻辑运算符 XY X 后跟 Y X\\ Y X 或 Y (X) X，作为捕获组 \\n 匹配第n个捕获组 环视 (?&lt;=Expression) 逆序肯定环视，表示所在位置左侧能够匹配Expression (?&lt;!Expression) 逆序否定环视，表示所在位置左侧不能匹配Expression (?=Expression) 顺序肯定环视，表示所在位置右侧能够匹配Expression (?!Expression) 顺序否定环视，表示所在位置右侧不能匹配Expression Java的逆序环视中不支持不定长度的量词如 * + {m,n} 模式修饰符：(?modifier) (?i)...(?-i) 不区分大小写 (?x)...(?-x) 宽松排列和注释模式 (?s)...(?-s) 点号通配模式 (?m)...(?-m) 增强的行锚点模式 宽松排列和注释模式:在此模式下会忽略字符组外部的所有空白字符。#符号和换行符之间的内容视为注释 点号通配模式：在此模式下。号匹配换行符 增强的行锚点模式：在此模式下^ $能够匹配字符串 文字文本模式：\\Q…\\E 模式作用范围(?modifier:…) (?&lt; name &gt;X) 捕获组名(API1.7) 捕获型括号：(…) \\1 \\2 仅分组的括号：(?:…) 固化分组：(?&gt;…) Matcher 返回类型 方法名 解释 Matcher appendReplacement(StringBuffer sb, String replacement) 将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里 StringBuffer appendTail(StringBuffer sb) 将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里 int end() 返回当前匹配的子串的最后一个字符在原目标字符串中的索引位置 int end(int group) 返回与匹配模式里指定的组相匹配的子串最后一个字符的位置 int end(String name) 返回与匹配模式里指定的组相匹配的子串最后一个字符的位置(API1.8) boolean find() 尝试在目标字符串里查找下一个匹配子串 boolean find(int start) 重设 Matcher 对象，并且尝试在目标字符串里从指定的位置开始查找下一个匹配的子串 String group() 返回当前查找而获得的与组匹配的所有子串内容 String group(int group) 返回当前查找而获得的与指定的组匹配的子串内容 String group(String name) 返回当前查找而获得的与指定的组匹配的子串内容(API1.7) int groupCount() 返回当前查找所获得的匹配组的数量 boolean hasAnchoringBounds() 查询此匹配器区域界限的定位。 boolean hasTransparentBounds() 查询此匹配器区域边界的透明度。 boolean hitEnd() 如果匹配器执行的最后匹配操作中搜索引擎遇到输入结尾，则返回 true。 boolean lookingAt() 检测目标字符串是否以匹配的子串起始 boolean matches() 尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值 Pattern pattern() 返回该 Matcher 对象的现有匹配模式，也就是对应的 Pattern 对象 static String quoteReplacement(String s) 返回指定 String 的字面值替换 String Matcher region(int start, int end) 设置此匹配器的区域限制 int regionEnd() 报告此匹配器区域的结束索引(不包括） int regionStart() 报告此匹配器区域的开始索引(包括） String replaceAll(String replacement) 将目标字符串里与既有模式相匹配的子串全部替换为指定的字符串 String replaceFirst(String replacement) 将目标字符串里第一个与既有模式相匹配的子串替换为指定的字符串 int requireEnd() 如果很多输入都可以将正匹配更改为负匹配，则返回true Matcher reset() 重设该 Matcher 对象 Matcher reset(CharSequence input) 重设该 Matcher 对象并且指定一个新的目标字符串 int start() 返回当前查找所获子串的开始字符在原目标字符串中的位置 int start(int group) 返回当前查找所获得的和指定组匹配的子串的第一个字符在原目标字符串中的位置 int start(String name) 返回当前查找所获得的和指定组匹配的子串的第一个字符在原目标字符串中的位置(API1.8) MatchResult toMatchResult() 作为 MatchResult 返回此匹配器的匹配状态 String toString() 返回匹配器的字符串表示形式 Matcher useAnchoringBounds(boolean b) 设置匹配器区域界限的定位。 Matcher usePattern(Pattern newPattern) 更改此 Matcher 用于查找匹配项的 Pattern。 Matcher useTransparentBounds(boolean b) 设置此匹配器区域边界的透明度。 Matcher方法详解matches() | lookingAt() | find() matches() 尝试将整个区域与模式匹配。 lookingAt() 尝试将从区域开头开始的输入序列与该模式匹配与 matches 方法类似，此方法始终从区域的开头开始；与之不同的是，它不需要匹配整个区域。 find() 此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。 ※当上述其中一种方法调用后，才可以调用start、end 和 group 方法 replaceAll(String replacement) | replaceFirst(String replacementString replacement) | appendReplacement(StringBuffer sb, String replacement) | appendTail(StringBuffer sb) replaceAll(String replacement) 使用replacement替代所有匹配的字符串 replaceFirst(String replacement) 使用replacement替代第一个匹配的字符串 appendReplacement(StringBuffer sb, String replacement) 读取开始匹配位置至匹配结束位置的字符串，使用replacement替代匹配的位置，将替换好的字符串添加到sb中 appendTail(StringBuffer sb) 将开始位置至匹配结束位置的字符串添加到sb中 ※使用appendReplacement(StringBuffer sb, String replacement)方法前需使用matches()，lookingAt()或find() useTransparentBounds(boolean b) TransparentBounds属性默认为false，使用region(int start, int end)能够限定匹配的范围，当我们将TransparentBounds设置为ture时，匹配的限定范围将不只于所限定的范围 useAnchoringBounds(boolean b) AnchoringBounds属性默认为ture，在此情况^表示开始\\$表示结束，当设置为false时，^$将不在表示此意思 参考资料精通正则表达式Java学习札记19：详解Java中的Pattern和Matcher","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"}]},{"title":"JavaIO（四）：文件操作","slug":"JavaIO（四）：文件操作","date":"2016-04-30T08:00:00.000Z","updated":"2017-08-06T09:27:51.819Z","comments":true,"path":"2016/04/30/JavaIO（四）：文件操作/","link":"","permalink":"https://luoweiguang.github.io/2016/04/30/JavaIO（四）：文件操作/","excerpt":"新建    /**\n     * 新建文件\n     * @param path 绝对路径\n     * @return 新建成功返回ture，新建失败或以存在此文件返回false\n     */\n    public static boolean newFile(String path)\n    {\n        File file = new File(path);\n        file.getParentFile().mkdirs();\n        try\n        {\n            return file.createNewFile();\n        } catch (IOException e)\n        {\n            e.printStackTrace();\n            return false;\n        }\n    }\n","text":"新建 /** * 新建文件 * @param path 绝对路径 * @return 新建成功返回ture，新建失败或以存在此文件返回false */ public static boolean newFile(String path) { File file = new File(path); file.getParentFile().mkdirs(); try { return file.createNewFile(); } catch (IOException e) { e.printStackTrace(); return false; } } /** * 新建文件夹 * @param path 绝对路径 * @return 新建成功返回ture，新建失败或以存在此文件夹返回false */ public static boolean newFolder(String path) { File file = new File(path); return file.mkdirs(); } 重命名 /** * 文件重命名 * @param path 绝对路径 * @param newname 新名称 * @return 文件重命名 成功返回ture,失败或不存在此文件返回false */ public static boolean renameTo(String path,String newname) { File file = new File(path); if(file.renameTo(new File(file.getParent(), newname))) { return true; } return false; } 删除 /** * 删除文件或文件夹 * @param path 绝对路径 * @return 文件不存在或以删除返回ture */ public static boolean delete(String path) { File file = new File(path); if(!file.exists()) { return true; } if(file.isDirectory()) { String[] filelists = file.list(); for(String childfile : filelists) { delete(path + File.separator + childfile); } } return file.delete(); } 列表 public static List&lt;String> filelists(String path) { return filelists(path,false); } public static List&lt;String> filelists(String path,boolean isSearchChildList) { return filelists(path, isSearchChildList, false); } public static List&lt;String> filelists(String path,boolean isSearchChildList,boolean isAddFolder) { return filelists(path, isSearchChildList,isAddFolder, null); } /** * 列出目录下及其子目录下所有文件名含有fileFilrer字符数组中的文件，但不包含文件夹 * @param path 绝对路径 * @param isSearchChildList 是否搜索子目录 * @param isAddFolder 是否添加文件夹 * @param fileFilter 过滤字符数组 * @return 返回的为绝对路径 */ public static List&lt;String> filelists(String path,boolean isSearchChildList,boolean isAddFolder,String[] fileFilter) { List&lt;String> list = new ArrayList&lt;String>(); File file = new File(path); String[] filelists = file.list(new FilenameFilter() { @Override public boolean accept(File dir, String name) { if(fileFilter == null) { return true; } for(String filterStr: fileFilter) { if(name.contains(filterStr)) { return true; } } return false; } }); for(String str: filelists) { if(new File(path,str).isDirectory()) { if(isAddFolder) list.add(path + File.separator + str); if(isSearchChildList) { List&lt;String> childLists= filelists(path + File.separator + str,isSearchChildList,isAddFolder,fileFilter); list.addAll(childLists); } } else { list.add(path + File.separator + str); } } return list; } 复制public static boolean copy(String path,String newfilepath) throws IOException { //128KB return copy(path,newfilepath,false); } public static boolean copy(String path,String newfilepath,boolean overlay) throws IOException { //128KB return copy(path,newfilepath,overlay,131072); } /** * 复制文件 * @param path 绝对路径 * @param newfilepath 绝对路径 * @param overlay 是否进行覆盖 * @param length 复制缓冲区的大小 * @return 复制文件成功返回ture,未成功返回false * @throws IOException IOException 输入输出流关闭异常 */ public static boolean copy(String path,String newfilepath,boolean overlay,int length) throws IOException { int bufferlength = length; if(newfilepath.startsWith(path)) { return false; } File file = new File(path); File newfile = new File(newfilepath); if(!file.exists()) { return false; } if(newfile.exists()) { if(overlay) { if(!file.isDirectory()) newfile.delete(); } else { return false; } } if(file.isDirectory()) { newfile.mkdirs(); String[] filelists = file.list(); for(String childfile : filelists) { copy(path + File.separator +childfile, newfilepath + File.separator +childfile,overlay,length); } return true; } else { newfile.getParentFile().mkdirs(); InputStream inputStream = null; OutputStream outputStream = null; try { inputStream = new BufferedInputStream(new FileInputStream(file)); outputStream = new BufferedOutputStream(new FileOutputStream(newfile)); byte[] buffer = new byte[bufferlength]; int i; while ((i = inputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, i); } return true; } catch (Exception e) { e.printStackTrace(); return false; } finally { inputStream.close();; outputStream.close();; } } } 大小/** * 文件或文件夹大小 * @param path 绝对路径 * @return 单位为byte */ public static long fileSizes(String path) { long fileSizes = 0; File file = new File(path); if(!file.exists()) { return 0; } if(file.isDirectory()) { String[] filelists = file.list(); for(String childfile : filelists) { fileSizes += fileSizes(path + File.separator + childfile); } } return file.length() + fileSizes; }","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"IO","slug":"IO","permalink":"https://luoweiguang.github.io/tags/IO/"}]},{"title":"JavaIO（三）：Reader与Writer","slug":"JavaIO（三）：Reader与Writer","date":"2016-04-28T13:00:00.000Z","updated":"2017-08-06T09:41:10.780Z","comments":true,"path":"2016/04/28/JavaIO（三）：Reader与Writer/","link":"","permalink":"https://luoweiguang.github.io/2016/04/28/JavaIO（三）：Reader与Writer/","excerpt":"InputStreamReaderpublic class Test\n{\n    public static void main(String[] args) throws IOException\n    {\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;E:\\\\Test11.txt&quot;));\n\n        //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。\n        System.out.println(&quot;markSupported():&quot; + isr.markSupported());\n        //ready() boolean 判断此流是否已经准备好用于读取。\n        System.out.println(&quot;ready():&quot; + isr.ready());\n        //read() int 读取单个字符。\n        System.out.println(&quot;read():&quot; + isr.read());\n        char[] chars1 = new char[26];\n        //read(char[] cbuf) int 将字符读入数组。\n        isr.read(chars1);\n        System.out.println(&quot;read(char[] cbuf):&quot; + new String(chars1));\n        char[] chars2 = new char[26];\n        //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。\n        isr.read(chars2, 0, 13);\n        System.out.println(&quot;read(char[] cbuf, int off, int len):&quot; + new String(chars2));\n        //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。\n        isr.skip(1);\n        //close() void 关闭该流并释放与之关联的所有系统资源。\n        isr.close();\n    }\n}\n","text":"InputStreamReaderpublic class Test { public static void main(String[] args) throws IOException { InputStreamReader isr = new InputStreamReader(new FileInputStream(\"E:\\\\Test11.txt\")); //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。 System.out.println(\"markSupported():\" + isr.markSupported()); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + isr.ready()); //read() int 读取单个字符。 System.out.println(\"read():\" + isr.read()); char[] chars1 = new char[26]; //read(char[] cbuf) int 将字符读入数组。 isr.read(chars1); System.out.println(\"read(char[] cbuf):\" + new String(chars1)); char[] chars2 = new char[26]; //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。 isr.read(chars2, 0, 13); System.out.println(\"read(char[] cbuf, int off, int len):\" + new String(chars2)); //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 isr.skip(1); //close() void 关闭该流并释放与之关联的所有系统资源。 isr.close(); } } E:\\Test11.txt为CharArrayWriter输出 FileReaderpublic class Test { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(\"E:\\\\Test11.txt\"); //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。 System.out.println(\"markSupported():\" + fr.markSupported()); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + fr.ready()); //read() int 读取单个字符。 System.out.println(\"read():\" + fr.read()); char[] chars1 = new char[26]; //read(char[] cbuf) int 将字符读入数组。 fr.read(chars1); System.out.println(\"read(char[] cbuf):\" + new String(chars1)); char[] chars2 = new char[26]; //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。 fr.read(chars2, 0, 13); System.out.println(\"read(char[] cbuf, int off, int len):\" + new String(chars2)); //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 fr.skip(1); //close() void 关闭该流并释放与之关联的所有系统资源。 fr.close(); } } PushbackReaderpublic class Test { public static void main(String[] args) throws IOException { PushbackReader pr = new PushbackReader(new FileReader(\"E:\\\\Test.txt\"),1024); //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。 System.out.println(\"markSupported():\" + pr.markSupported()); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + pr.ready()); //read() int 读取单个字符。 System.out.println(\"read():\" + pr.read()); char[] chars1 = new char[26]; //read(char[] cbuf) int 将字符读入数组。 pr.read(chars1); System.out.println(\"read(char[] cbuf):\" + new String(chars1)); char[] chars2 = new char[26]; //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。 pr.read(chars2, 0, 13); System.out.println(\"read(char[] cbuf, int off, int len):\" + new String(chars2)); //unread(char[] cbuf, int off, int len) void 推回字符数组的某一部分，方法是将其复制到推回缓冲区的前面。 pr.unread(chars2, 0, 13); //unread(char[] cbuf) void 推回一个字符数组，方法是将其复制到推回缓冲区前面。 pr.unread(chars1); //unread(int c) void 推回单个字符：将其复制到推回缓冲区的前面。 pr.unread(97); //reset() void 重置该流。 pr.reset(); //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 pr.skip(1); //close() void 关闭该流并释放与之关联的所有系统资源。 pr.close(); } } CharArrayReaderpublic class Test { public static void main(String[] args) throws IOException { char[] chars1 = new char[512]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('a' + i%26); } CharArrayReader car = new CharArrayReader(chars1); //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。 System.out.println(\"markSupported():\" + car.markSupported()); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + car.ready()); //mark(int readAheadLimit) void 标记流中的当前位置。 car.mark(0); //read() int 读取单个字符。 System.out.println(\"read():\" + car.read()); char[] chars2 = new char[26]; //read(char[] cbuf) int 将字符读入数组。 car.read(chars2); System.out.println(\"read(char[] cbuf):\" + new String(chars2)); char[] chars3 = new char[26]; //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。 car.read(chars3, 0, 13); System.out.println(\"read(char[] cbuf, int off, int len):\" + new String(chars3)); //reset() void 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 car.reset(); //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 car.skip(1); //close() void 关闭该流并释放与之关联的所有系统资源。 car.close(); } } BufferedReaderpublic class Test { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(\"E:\\\\Test11.txt\"),1024); //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。 System.out.println(\"markSupported():\" + br.markSupported()); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + br.ready()); //mark(int readAheadLimit) void 标记流中的当前位置。 br.mark(1024); //read() int 读取单个字符。 System.out.println(\"read():\" + br.read()); char[] chars1 = new char[26]; //read(char[] cbuf) int 将字符读入数组。 br.read(chars1); System.out.println(\"read(char[] cbuf):\" + new String(chars1)); char[] chars2 = new char[26]; //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。 br.read(chars2, 0, 13); System.out.println(\"read(char[] cbuf, int off, int len):\" + new String(chars2)); //reset() void 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 br.reset(); //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 br.skip(1); //readLine() String 读取一个文本行。 System.out.println(\"readLine():\" + br.readLine()); //close() void 关闭该流并释放与之关联的所有系统资源。 br.close(); } } StringReaderpublic class Test { public static void main(String[] args) throws IOException { StringReader sr = new StringReader(\"aHello WorldHelloaabcdefghijklmnopqrstuvwxyzabcdefghijklmHelloHello World\"); //markSupported() boolean 判断此流是否支持 mark() 操作以及支持哪一项操作。 System.out.println(\"markSupported():\" + sr.markSupported()); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + sr.ready()); //mark(int readAheadLimit) void 标记流中的当前位置。 sr.mark(0); //read() int 读取单个字符。 System.out.println(\"read():\" + sr.read()); char[] chars1 = new char[26]; //read(char[] cbuf) int 将字符读入数组。 sr.read(chars1); System.out.println(\"read(char[] cbuf):\" + new String(chars1)); char[] chars2 = new char[26]; //read(char[] cbuf, int off, int len) int 将字符读入数组的某一部分。 sr.read(chars2, 0, 13); System.out.println(\"read(char[] cbuf, int off, int len):\" + new String(chars2)); //reset() void 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 sr.reset(); //skip(long ns) long 将该流重置为最新的标记，如果从未标记过，则将其重置到该字符串的开头。 sr.skip(1); //close() void 关闭该流并释放与之关联的所有系统资源。 sr.close(); } } PipedReader与PipedWriterpublic class Test { public static void main(String[] args) throws IOException { PipedReader pr = new PipedReader(); PipedWriter pw = new PipedWriter(); pr.connect(pw); ReaderThread rt = new ReaderThread(pr); WriterThread wt = new WriterThread(pw); new Thread(rt).start(); new Thread(wt).start(); } } class ReaderThread implements Runnable { private PipedReader pr; public ReaderThread(PipedReader pr) { this.pr = pr; } public void run() { try { System.out.println(\"PipedReader:读取前没有数据,阻塞中...等待数据传过来再输出到控制台...\"); char[] chars1 = new char[26]; //read(byte[] b) int 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中 pr.read(chars1); //ready() boolean 判断此流是否已经准备好用于读取。 System.out.println(\"ready():\" + pr.ready()); System.out.println(\"PipedReader:读取数据成功,阻塞解除...\"); System.out.println(new String(chars1)); //将读取的数据流用字符串以字符串打印出来 //read() int 读取此传送流中的下一个数据字符。 System.out.println(pr.read()); char[] chars2 = new char[26]; //read(char[] cbuf, int off, int len) int 将此传送流中最多 len 个数据字符读入字符数组。 pr.read(chars2, 0, 14); System.out.println(new String(chars2)); //markSupported() boolean 判断此流是否支持 mark()操作 System.out.println(pr.markSupported()); //close() int 关闭此管道输入流并释放与该流相关的所有系统资源。 pr.close(); } catch(Exception e) { throw new RuntimeException(\"PipedReader:管道读取流失败!\"); } } } class WriterThread implements Runnable { private PipedWriter pw; public WriterThread(PipedWriter pw) { this.pw = pw; } @Override public void run() { try { System.out.println(\"PipedWriter:开始将数据写入\"); char[] chars1 = new char[26]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('A' + i%26); } //write(char[] cbuf) void 写入字符数组。 pw.write(chars1); //write(int c) void 将指定的 char 写入管道输出流。 pw.write(97); //write(char[] cbuf, int off, int len) int 将 len 将 len 字符从指定初始偏移量为 off 的字符数组写入到此管道输出流。 pw.write(chars1, 0, 13); //flush() void 刷新此输出流并强制写出所有缓冲的输出字符。 pw.flush(); //append(char c) Writer 将指定字符添加到此 writer。 pw.append('b'); //append(CharSequence csq) Writer 将指定字符序列添加到此 writer。 pw.append(\"Hello World\"); //append(CharSequence csq,int start,int end) Writer 将指定字符序列的子序列添加到此 writer.Appendable。 pw.append(\"Hello World\", 0, 5); Thread.sleep(5000); //close() void 关闭此管道输出流并释放与此流相关的所有系统资源。 pw.close(); } catch(Exception e) { throw new RuntimeException(\"PipedWriter:WriteThread写入失败...\"); } } } StringWriterpublic class Test { public static void main(String[] args) throws IOException { StringWriter sw = new StringWriter(); //append(char c) StringWriter 将指定字符添加到此 writer。 sw.append('a'); //append(CharSequence csq) StringWriter 将指定的字符序列添加到此 writer。 sw.append(\"Hello World\"); //append(CharSequence csq, int start, int end) StringWriter 将指定字符序列的子序列添加到此 writer。 sw.append(\"Hello World\", 0, 5); //write(int c) void 写入单个字符。 sw.write(97); char[] chars1 = new char[26]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('a' + i%26); } //write(char[] cbuf) void 写入字符数组。 sw.write(chars1); //write(char[] cbuf, int off,int len) void 写入字符数组的某一部分。 sw.write(chars1, 0, 13); //write(char[] cbuf, int off, int len) void 写入字符数组的某一部分。 sw.write(\"Hello World\", 0, 5); //write(String str) void 写入一个字符串。 sw.write(\"Hello World\"); //flush() void 刷新该流的缓冲。 sw.flush(); //close() void 关闭 StringWriter 无效。 sw.close(); //toString() String 以字符串的形式返回该缓冲区的当前值。 System.out.println(sw.toString()); //getBuffer() StringBuffer 返回该字符串缓冲区本身。 System.out.println(sw.getBuffer()); } } OutputStreamWriterpublic class Test { public static void main(String[] args) throws IOException { OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"E:\\\\Test9.txt\"),\"UTF-8\"); //write(int c) void 写入单个字符。 osw.write(97); char[] chars1 = new char[26]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('a' + i%26); } //append(char c) StringWriter 将指定字符添加到此 writer。 osw.append('a'); //append(CharSequence csq) StringWriter 将指定的字符序列添加到此 writer。 osw.append(\"Hello World\"); //append(CharSequence csq, int start, int end) StringWriter 将指定字符序列的子序列添加到此 writer。 osw.append(\"Hello World\", 0, 5); //write(char[] cbuf) void 写入字符数组。 osw.write(chars1); //write(char[] cbuf, int off,int len) void 写入字符数组的某一部分。 osw.write(chars1, 0, 13); //write(char[] cbuf, int off, int len) void 写入字符数组的某一部分。 osw.write(\"Hello World\", 0, 5); //write(String str) void 写入一个字符串。 osw.write(\"你好，世界\"); //getEncoding() String 返回此流使用的字符编码的名称。 System.out.println(\"getEncoding():\" + osw.getEncoding()); //flush() void 刷新该流的缓冲。 osw.flush(); //close() void 关闭此流，但要先刷新它。 osw.close(); } } FileWriterpublic class Test { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"E:\\\\Test10.txt\"); //write(int c) void 写入单个字符。 fw.write(97); char[] chars1 = new char[26]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('a' + i%26); } //append(char c) StringWriter 将指定字符添加到此 writer。 fw.append('a'); //append(CharSequence csq) StringWriter 将指定的字符序列添加到此 writer。 fw.append(\"Hello World\"); //append(CharSequence csq, int start, int end) StringWriter 将指定字符序列的子序列添加到此 writer。 fw.append(\"Hello World\", 0, 5); //write(char[] cbuf) void 写入字符数组。 fw.write(chars1); //write(char[] cbuf, int off,int len) void 写入字符数组的某一部分。 fw.write(chars1, 0, 13); //write(char[] cbuf, int off, int len) void 写入字符数组的某一部分。 fw.write(\"Hello World\", 0, 5); //write(String str) void 写入一个字符串。 fw.write(\"你好，世界\"); //getEncoding() String 返回此流使用的字符编码的名称。 System.out.println(\"getEncoding():\" + fw.getEncoding()); //flush() void 刷新该流的缓冲。 fw.flush(); //close() void 关闭此流，但要先刷新它。 fw.close(); } } CharArrayWriterpublic class Test { public static void main(String[] args) throws IOException { CharArrayWriter caw = new CharArrayWriter(1024); //write(int c) void 写入单个字符。 caw.write(97); char[] chars1 = new char[26]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('a' + i%26); } //append(char c) StringWriter 将指定字符添加到此 writer。 caw.append('a'); //append(CharSequence csq) StringWriter 将指定的字符序列添加到此 writer。 caw.append(\"Hello World\"); //append(CharSequence csq, int start, int end) StringWriter 将指定字符序列的子序列添加到此 writer。 caw.append(\"Hello World\", 0, 5); //write(char[] cbuf) void 写入字符数组。 caw.write(chars1); //write(char[] cbuf, int off,int len) void 写入字符数组的某一部分。 caw.write(chars1, 0, 13); //write(char[] cbuf, int off, int len) void 写入字符数组的某一部分。 caw.write(\"Hello World\", 0, 5); //write(String str) void 写入一个字符串。 caw.write(\"你好，世界\"); //toCharArray() char[] 返回输入数据的副本。 System.out.println(\"toCharArray():\" + new String(caw.toCharArray())); FileWriter fw = new FileWriter(\"E:\\\\Test11.txt\"); //writeTo(Writer out) void 将缓冲区的内容写入另一个字符流。 caw.writeTo(fw); fw.flush(); //size() int 返回缓冲区的当前大小。 System.out.println(\"size():\" + caw.size()); //reset() void 重置该缓冲区，以便再次使用它而无需丢弃已分配的缓冲区。 caw.reset(); //flush() void 刷新该流的缓冲。 caw.flush(); //close() void 关闭此流，但要先刷新它。 caw.close(); } } BufferedWriterpublic class Test { public static void main(String[] args) throws IOException { CharArrayWriter caw = new CharArrayWriter(1024); BufferedWriter bw = new BufferedWriter(caw, 2048); //write(int c) void 写入单个字符。 bw.write(97); char[] chars1 = new char[26]; for(int i = 0;i &lt; chars1.length;i++) { chars1[i] = (char) ('a' + i%26); } //append(char c) StringWriter 将指定字符添加到此 writer。 bw.append('a'); //append(CharSequence csq) StringWriter 将指定的字符序列添加到此 writer。 bw.append(\"Hello World\"); //append(CharSequence csq, int start, int end) StringWriter 将指定字符序列的子序列添加到此 writer。 bw.append(\"Hello World\", 0, 5); //write(char[] cbuf) void 写入字符数组。 bw.write(chars1); //write(char[] cbuf, int off,int len) void 写入字符数组的某一部分。 bw.write(chars1, 0, 13); //write(char[] cbuf, int off, int len) void 写入字符数组的某一部分。 bw.write(\"Hello World\", 0, 5); //write(String str) void 写入一个字符串。 bw.write(\"你好，世界\"); //newLine() void 写入一个行分隔符。 bw.newLine(); //flush() void 刷新该流的缓冲。 bw.flush(); //close() void 关闭此流，但要先刷新它。 bw.close(); } }","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"IO","slug":"IO","permalink":"https://luoweiguang.github.io/tags/IO/"}]},{"title":"JavaIO（二）：InputStream与OutputStream","slug":"JavaIO（二）：InputStream与OutputStream","date":"2016-04-26T01:00:00.000Z","updated":"2017-08-06T09:43:31.036Z","comments":true,"path":"2016/04/26/JavaIO（二）：InputStream与OutputStream/","link":"","permalink":"https://luoweiguang.github.io/2016/04/26/JavaIO（二）：InputStream与OutputStream/","excerpt":"ByteArrayInputStreampublic class Test\n{\n    public static void main(String[] args) throws IOException\n    {\n        byte[] bytes1 = new byte[52];\n        for(int i = 0;i &lt; bytes1.length;i++)\n        {\n            bytes1[i] = (byte) (&#39;a&#39; + i%26);\n        }\n\n        ByteArrayInputStream bais1 = new ByteArrayInputStream(bytes1);\n        //skip(long n) long 从此输入流中跳过 n 个输入字节。\n        System.out.println(&quot;skip(long n):&quot; + bais1.skip(256));\n        //available() int 返回可从此输入流读取（或跳过）的剩余字节数。\n        System.out.println(&quot;available():&quot; + bais1.available());\n        //markSupported() boolean 测试此 InputStream 是否支持 mark/reset。\n        System.out.println(&quot;markSupported():&quot; + bais1.markSupported());\n        //mark(int readAheadLimit) void 设置流中的当前标记位置。\n        bais1.mark(512);\n        //read() int 从此输入流中读取下一个数据字节。\n        System.out.println(&quot;read():&quot; + bais1.read());\n        byte[] bytes2 = new byte[512];\n        //read(byte[] int 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。\n        System.out.println(&quot;read(byte[]):&quot; + bais1.read(bytes2));\n        System.out.println(new String(bytes2));\n        //read(byte[] b, int off, int len) int 将最多 len 个数据字节从此输入流读入 byte 数组。\n        System.out.println(&quot;read(byte[] b, int off, int len):&quot; + bais1.read(bytes2, 0, 128));\n        System.out.println(new String(bytes2));\n        //reset() void 将缓冲区的位置重置为标记位置。\n        bais1.reset();\n        System.out.println(&quot;reset():&quot; + bais1.available());\n        //close() void 关闭 ByteArrayInputStream\n        bais1.close();\n    }\n}\n","text":"ByteArrayInputStreampublic class Test { public static void main(String[] args) throws IOException { byte[] bytes1 = new byte[52]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } ByteArrayInputStream bais1 = new ByteArrayInputStream(bytes1); //skip(long n) long 从此输入流中跳过 n 个输入字节。 System.out.println(\"skip(long n):\" + bais1.skip(256)); //available() int 返回可从此输入流读取（或跳过）的剩余字节数。 System.out.println(\"available():\" + bais1.available()); //markSupported() boolean 测试此 InputStream 是否支持 mark/reset。 System.out.println(\"markSupported():\" + bais1.markSupported()); //mark(int readAheadLimit) void 设置流中的当前标记位置。 bais1.mark(512); //read() int 从此输入流中读取下一个数据字节。 System.out.println(\"read():\" + bais1.read()); byte[] bytes2 = new byte[512]; //read(byte[] int 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(byte[]):\" + bais1.read(bytes2)); System.out.println(new String(bytes2)); //read(byte[] b, int off, int len) int 将最多 len 个数据字节从此输入流读入 byte 数组。 System.out.println(\"read(byte[] b, int off, int len):\" + bais1.read(bytes2, 0, 128)); System.out.println(new String(bytes2)); //reset() void 将缓冲区的位置重置为标记位置。 bais1.reset(); System.out.println(\"reset():\" + bais1.available()); //close() void 关闭 ByteArrayInputStream bais1.close(); } } 输出 skip(long n):26 available():26 markSupported():true read():97 read(byte[]):25 bcdefghijklmnopqrstuvwxyz FileInputStreampublic class Test { public static void main(String[] args) throws IOException { FileInputStream in1 = new FileInputStream(\"E:\\\\Test.txt\"); //available() int 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。 System.out.println(\"available():\" + in1.available() ); //skip(long n) long 跳过和丢弃此输入流中数据的 n 个字节。 in1.skip(6); byte[] bytes = new byte[1024]; //read() int 从此输入流中读取一个数据字节。 System.out.println(\"read():\"+in1.read()); //markSupported() boolean 测试此输入流是否支持 mark 和 reset 方法。 System.out.println(\"markSupported():\" + in1.markSupported()); //read(byte[] b) int 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(buffer):\" + in1.read(bytes)); //read(byte[] b, int off, int len) int 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(byte[] b, int off, int len):\" + in1.read(bytes, 512, 512)); //getChannel() FileChannel 返回与此文件输入流有关的唯一 FileChannel 对象。 FileChannel finleChannel = in1.getChannel(); //getFD() FileDescriptor 返回表示到文件系统中实际文件的连接的 FileDescriptor 对象，该文件系统正被此 FileInputStream 使用。 FileDescriptor fileDescriptor = in1.getFD(); //close() void 关闭此文件输入流并释放与此流有关的所有系统资源。 in1.close(); } } 输出 available():496800 read():55 markSupported():false read(buffer):1024 read(byte[] b, int off, int len):512 E:\\Test.txt 1234567890123456789012345678901234567890...... SequenceInputStreampublic class Test { public static void main(String[] args) throws IOException { FileInputStream in1 = new FileInputStream(\"E:\\\\Test3.txt\"); byte[] bytes1 = new byte[1024]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } ByteArrayInputStream bais1 = new ByteArrayInputStream(bytes1); SequenceInputStream sis1 = new SequenceInputStream(in1, bais1); //available() int 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。 System.out.println(\"available():\" + sis1.available()); byte[] bytes2 = new byte[128]; //read() int 从此输入流中读取一个数据字节。 System.out.println(\"read():\" + sis1.read()); //read(byte[] b) int 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(byte[] b):\" + sis1.read(bytes2)); //read(byte[] b, int off, int len) int 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(byte[] b, int off, int len):\" + sis1.read(bytes2,0,26)); //markSupported() boolean 测试此输入流是否支持 mark 和 reset 方法。 System.out.println(\"markSupported():\" +sis1.markSupported()); //close() void 关闭此输入流并释放与此流关联的所有系统资源。 sis1.close(); } } 输出 available():10 read():49 read(byte[] b):9 read(byte[] b, int off, int len):26 markSupported():false BufferedInputStreampublic class Test { public static void main(String[] args) throws IOException { BufferedInputStream bis1 = new BufferedInputStream(new FileInputStream(\"E:\\\\Test.txt\"),2048); //available() int 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。 System.out.println(\"available():\" + bis1.available() ); //skip(long n) long 跳过和丢弃此输入流中数据的 n 个字节。 bis1.skip(6); byte[] bytes = new byte[1024]; //read() int 从此输入流中读取一个数据字节。 System.out.println(\"read():\"+bis1.read()); //markSupported() boolean 测试此输入流是否支持 mark 和 reset 方法。 System.out.println(\"markSupported():\" + bis1.markSupported()); //mark(int readAheadLimit) void 设置流中的当前标记位置。 bis1.mark(1); //read(byte[] b) int 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(buffer):\" + bis1.read(bytes)); //read(byte[] b, int off, int len) int 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(byte[] b, int off, int len):\" + bis1.read(bytes, 512, 512)); //reset() void 将缓冲区的位置重置为标记位置。 bis1.reset(); System.out.println(\"reset():\"+bis1.read()); } } 输出 available():496800 read():55 markSupported():true read(buffer):1024 read(byte[] b, int off, int len):512 reset():56 PushbackInputStreampublic class Test { public static void main(String[] args) throws IOException { final PushbackInputStream pis1 = new PushbackInputStream(new FileInputStream(\"E:\\\\Test.txt\"),2048); //available() int 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。 System.out.println(\"available():\" + pis1.available() ); //skip(long n) long 跳过和丢弃此输入流中数据的 n 个字节。 pis1.skip(6); byte[] bytes1 = new byte[1024]; byte[] bytes2 = new byte[1024]; //read() int 从此输入流中读取一个数据字节。 System.out.println(\"read():\"+pis1.read()); //markSupported() boolean 测试此输入流是否支持 mark 和 reset 方法。 System.out.println(\"markSupported():\" + pis1.markSupported()); //read(byte[] b) int 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(buffer):\" + pis1.read(bytes1)); //read(byte[] b, int off, int len) int 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 System.out.println(\"read(byte[] b, int off, int len):\" + pis1.read(bytes2, 512, 512)); //unread(byte[] b, int off, int len) void 推回 byte 数组的某一部分：将其复制到推回缓冲区之前。 pis1.unread(bytes2, 512, 512); //unread(byte[] b) void 推回一个 byte 数组：将其复制到推回缓冲区之前。 pis1.unread(bytes1); //unread(int b) void 推回一个字节：将其复制到推回缓冲区之前。 pis1.unread(55); //close() void 关闭此输入流并释放与此流关联的所有系统资源。 pis1.close(); } } 输出 available():496800 read():55 markSupported():false read(buffer):1024 read(byte[] b, int off, int len):512 ObjectInputStreampublic class Test { public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException { ObjectInputStream ois1 = new ObjectInputStream(new FileInputStream(\"E:\\\\Test5.txt\")); //readObject() Object 从 ObjectInputStream 读取对象。 System.out.println(\"readObject():\" + (Date)ois1.readObject()); //available() int 返回可以不受阻塞地读取的字节数。 System.out.println(\"available():\" + ois1.available()); byte[] bytes1 = new byte[26]; //read(byte[] b) int 读入 byte 数组。 System.out.println(\"readByte():\" + ois1.read(bytes1)); //read(byte[] buf, int off, int len) int 读入 byte 数组 System.out.println(\"read(byte[] buf, int off, int len):\" + ois1.read(bytes1, 0, 26)); //read() int 读取数据字节。 System.out.println(\"read():\" + ois1.read()); //readBoolean() boolean 读取一个 boolean 值。 System.out.println(\"readBoolean():\" + ois1.readBoolean()); //readByte() byte 读取一个 8 位的字节。 System.out.println(\"readByte():\" + ois1.readByte()); byte[] bytes2 = new byte[11]; System.out.println(\"read(byte[] b):\" + ois1.read(bytes2)); System.out.println(new String(bytes2)); //readChar() char 读取一个 16 位的 char 值。 System.out.println(\"readChar():\" + ois1.readChar()); System.out.println(\"readChar():\" + ois1.readChar()); //skip(long n) int 跳过和丢弃此输入流中数据的 n 个字节。 System.out.println(\"skip(long n):\" + ois1.skip(10)); //skipBytes(int len) int 跳过字节。 System.out.println(\"skipBytes(int len):\" + ois1.skipBytes(10)); //readDouble() double 读取一个 64 位的 double 值。 System.out.println(\"readDouble():\" + ois1.readDouble()); //readFloat() float 读取一个 32 位的 float 值。 System.out.println(\"readFloat():\" + ois1.readFloat()); //readInt() int 读取一个 32 位的 int 值。 System.out.println(\"readInt():\" + ois1.readInt()); //readLong() long 读取一个 64 位的 long 值。 System.out.println(\"readLong():\" + ois1.readLong()); //readShort() short 读取一个 16 位的 short 值。 System.out.println(\"readShort():\" + ois1.readShort()); //readUnshared() Object 从 ObjectInputStream 读取“非共享”对象。 System.out.println(\"readUnshared():\" + (Date)ois1.readUnshared()); //readUTF() String 读取 UTF-8 修改版格式的 String。 System.out.println(\"readUTF():\" + ois1.readUTF()); //close() void 关闭输入流。 ois1.close(); } } 输出 readObject():Sat Apr 23 21:12:41 CST 2016 available():116 readByte():26 read(byte[] buf, int off, int len):26 read():97 readBoolean():true readByte():97 read(byte[] b):11 Hello World readChar():a readChar():H skip(long n):10 skipBytes(int len):10 readDouble():1024.0 readFloat():1024.0 readInt():1024 readLong():1024 readShort():26 readUnshared():Sat Apr 23 21:12:41 CST 2016 readUTF():你好，世界 E:\\Test5.txt为ObjectOutputStream输出 DataInputStreampublic class Test { public static void main(String[] args) throws IOException { DataInputStream dis = new DataInputStream(new FileInputStream(\"E:\\\\Test6.txt\")); //available() int 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。 System.out.println(\"available():\" + dis.available()); byte[] bytes1 = new byte[26]; dis.read(bytes1, 0, 13); System.out.println(\"read(byte[] b, int off, int len):\" + new String(bytes1)); //read() int 从此输入流中读取下一个数据字节。 System.out.println(\"read():\" + dis.read()); //boolean 读取一个输入字节，如果该字节不是零，则返回 true，如果是零，则返回 false。 System.out.println(\"readBoolean():\" + dis.readBoolean()); //readByte() byte 读取并返回一个输入字节。 System.out.println(\"readByte():\" + dis.readByte()); byte[] bytes2 = new byte[11]; //read(byte[] b) int 从此输入流中将 byte.length 个字节的数据读入一个 byte 数组中 dis.read(bytes2); System.out.println(\"read(byte[] b):\" + new String(bytes2)); //readChar() char 读取两个输入字节并返回一个 char 值 System.out.println(\"readChar():\" + dis.readChar()); //skip(long n) long 跳过和丢弃此输入流中数据的 n 个字节。 System.out.println(\"skip(long n):\" + dis.skip(11)); //skipBytes(int n) int 试图在输入流中跳过数据的 n 个字节，并丢弃跳过的字节。 System.out.println(\"skipBytes(int n):\" + dis.skipBytes(11)); //readDouble() double 读取八个输入字节并返回一个 double 值。 System.out.println(\"readDouble():\" + dis.readDouble()); //readFloat() float 读取四个输入字节并返回一个 float 值。 System.out.println(\"readFloat():\" + dis.readFloat()); //readInt() int 读取四个输入字节并返回一个 int 值。 System.out.println(\"readInt():\" + dis.readInt()); //readLong() long 读取八个输入字节并返回一个 long 值。 System.out.println(\"readLong():\" + dis.readLong()); //readShort() short 读取两个输入字节并返回一个 short 值。 System.out.println(\"readShort():\" + dis.readShort()); //readUTF() String 读入一个已使用 UTF-8 修改版格式编码的字符串。 System.out.println(\"readUTF():\" + dis.readUTF()); //markSupported() boolean 测试此输入流是否支持 mark 和 reset 方法 System.out.println(\"markSupported():\" + dis.markSupported()); //close() void 关闭此输入流并释放与此流关联的所有系统资源。 dis.close(); } } 输出 available():94 read(byte[] b, int off, int len):abcdefghijklm read():97 readBoolean():true readByte():98 read(byte[] b):Hello World readChar():c skip(long n):11 skipBytes(int n):11 readDouble():99.9 readFloat():99.8 readInt():100 readLong():101 readShort():102 readUTF():你好，世界 markSupported():false E:\\Test6.txt为DataOutputStream输出 PipedInputStream与PipedOutputStreampublic class Test { public static void main(String[] args) throws Exception { PipedInputStream pis1 = new PipedInputStream(); PipedOutputStream pos1 = new PipedOutputStream(); //connect(PipedInputStream snk) void 将此管道输出流连接到接收者。 pis1.connect(pos1); ReadThread readTh = new ReadThread(pis1); WriteThread writeTh = new WriteThread(pos1); new Thread(readTh).start(); new Thread(writeTh).start(); } } class ReadThread implements Runnable { private PipedInputStream pis; ReadThread(PipedInputStream pis) // { this.pis=pis; } public void run() //由于必须要覆盖run方法,所以这里不能抛,只能try { try { System.out.println(\"PipedInputStream:读取前没有数据,阻塞中...等待数据传过来再输出到控制台...\"); //available() int 返回可以不受阻塞地从此输入流中读取的字节数。 System.out.println(\"available():\" + pis.available()); byte[] bytes1 = new byte[26]; //read(byte[] b) int 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中 pis.read(bytes1); System.out.println(\"PipedInputStream:读取数据成功,阻塞解除...\"); System.out.println(new String(bytes1)); //将读取的数据流用字符串以字符串打印出来 //read() int 读取此管道输入流中的下一个数据字节。 System.out.println(pis.read()); byte[] bytes2 = new byte[26]; //read(byte[] b, int off, int len) int 将最多 len 个数据字节从此管道输入流读入 byte 数组。 pis.read(bytes2, 0, 14); System.out.println(new String(bytes2)); //markSupported() boolean 测试此输入流是否支持 mark 和 reset 方法。 System.out.println(pis.markSupported()); //close() int 关闭此管道输入流并释放与该流相关的所有系统资源。 pis.close(); } catch(Exception e) { throw new RuntimeException(\"PipedInputStream:管道读取流失败!\"); } } } class WriteThread implements Runnable { private PipedOutputStream pos; WriteThread(PipedOutputStream pos) { this.pos= pos; } public void run() { try { System.out.println(\"PipedOutputStream:开始将数据写入\"); byte[] bytes1 = new byte[26]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('A' + i%26); } //write(byte[] b) void 将 b.length 个字节从指定的 byte 数组写入此输出流。 pos.write(bytes1); //write(int b) void 将指定 byte 写入传送的输出流。 pos.write(97); //write(byte[] b, int off, int len) void 将 len 字节从初始偏移量为 off 的指定 byte 数组写入该管道输出流。 pos.write(bytes1, 0, 13); //flush() void 刷新此输出流并强制写出所有缓冲的输出字节。 pos.flush(); Thread.sleep(5000); //close() void 关闭此管道输出流并释放与此流有关的所有系统资源。 pos.close(); } catch(Exception e) { throw new RuntimeException(\"PipedOutputStream:WriteThread写入失败...\"); } } } 输出 PipedInputStream:读取前没有数据,阻塞中...等待数据传过来再输出到控制台... PipedOutputStream:开始将数据写入 available():0 PipedInputStream:读取数据成功,阻塞解除... ABCDEFGHIJKLMNOPQRSTUVWXYZ 97 ABCDEFGHIJKLM ByteArrayOutputStreampublic class Test { public static void main(String[] args) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); //write(int b) void 将指定的字节写入此 byte 数组输出流。 baos.write(97); byte[] bytes1 = new byte[26]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } //write(byte[] b) void 将 b.length 个字节从指定的 byte数组写入此输出流。 baos.write(bytes1); //write(byte[] b, int off, int len) void 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此 byte 数组输出流。 baos.write(bytes1, 0, 13); //toString(String charsetName) String 使用指定的 charsetName，通过解码字节将缓冲区内容转换为字符串。 System.out.println(baos.toString(\"UTF-8\")); //toByteArray() byte[] 创建一个新分配的 byte 数组。 System.out.println(new String(baos.toByteArray())); //size() int 返回缓冲区的当前大小。 System.out.println(baos.size()); //reset() void 将此 byte 数组输出流的 count 字段重置为零，从而丢弃输出流中目前已累积的所有输出。 baos.reset(); //writeTo(OutputStream out) void 将此 byte 数组输出流的全部内容写入到指定的输出流参数中，这与使用 out.write(buf, 0, count) 调用该输出流的 write 方法效果一样。 baos.writeTo(new FileOutputStream(\"E:\\\\Test7.txt\")); //flush() void 刷新此输出流并强制写出所有缓冲的输出字节。 baos.flush(); //close() void 关闭此输出流并释放与此流有关的所有系统资源 baos.close(); } } 输出 aabcdefghijklmnopqrstuvwxyzabcdefghijklm aabcdefghijklmnopqrstuvwxyzabcdefghijklm 40 FileOutputStreampublic class Test { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"E:\\\\Test7.txt\"); byte[] bytes1 = new byte[26]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } //write(byte[] b) void 将 b.length 个字节从指定 byte 数组写入此文件输出流中。 fos.write(bytes1); //write(int b) void 将指定字节写入此文件输出流。 fos.write(97); //write(byte[] b, int off, int len) void 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 fos.write(bytes1, 0, 13); //getChannel() FileChannel 返回与此文件输出流有关的唯一 FileChannel 对象。 fos.getChannel(); //getFD() FileDescriptor 返回与此流有关的文件描述符。 fos.getFD(); //flush() void 刷新此输出流并强制写出所有缓冲的输出字节。 fos.flush(); //close() void 关闭此输出流并释放与此流有关的所有系统资源。 fos.close(); } } BufferedOutputStreampublic class Test { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"E:\\\\Test7.txt\"); BufferedOutputStream bos = new BufferedOutputStream(fos,1024); byte[] bytes1 = new byte[26]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } //write(byte[] b) void 将 b.length 个字节从指定 byte 数组写入此文件输出流中。 bos.write(bytes1); //write(int b) void 将指定字节写入此文件输出流。 bos.write(97); //write(byte[] b, int off, int len) void 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 bos.write(bytes1, 0, 13); //flush() void 刷新此缓冲的输出流。 bos.flush(); //close() void 关闭此输出流并释放与此流有关的所有系统资源。 bos.close(); } } ObjectOutputStreampublic class Test { public static void main(String[] args) throws IOException, IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"E:\\\\Test5.txt\")); //writeObject(Object obj) void 将指定的对象写入 ObjectOutputStream。 oos.writeObject(new Date()); //reset() void 重置将丢弃已写入流中的所有对象的状态。 oos.reset(); byte[] bytes1 = new byte[26]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } //write(byte[] buf) void 写入一个 byte 数组。 void 写入一个 byte数组。 oos.write(bytes1); //write(byte[] buf, int off, int len) void 写入字节的子数组。 oos.write(bytes1, 0, 26); //write(int val) void 写入一个字节。 oos.write(97); //writeBoolean(boolean val) void 写入一个 boolean值。 oos.writeBoolean(true); //writeByte(int val) void 写入一个 8 位字节。 oos.writeByte(97); //writeBytes(String str) void 以字节序列形式写入一个 String。 oos.writeBytes(\"Hello World\"); //writeChar(int val) void 写入一个 16 位的 char值。 v oos.writeChar(97); //writeChars(String str) void 以 char 序列形式写入一个 String。 oos.writeChars(\"Hello World\"); //writeDouble(double val) void 写入一个 64 位的 double 值。 oos.writeDouble(1024); //writeFloat(float val) void 写入一个 32 位的 float 值。 oos.writeFloat(1024f); //writeInt(int val) void 写入一个 32 位的 int值。 oos.writeInt(1024); //writeLong(long val) void 写入一个 64 位的 long 值。 oos.writeLong(1024l); //writeShort(int val) void 写入一个 16 位的 short 值。 oos.writeShort(26); //writeUnshared(Object obj) void 将“未共享”对象写入 ObjectOutputStream。 oos.writeUnshared(new Date()); //writeUTF(String str) void 以 UTF-8 修改版格式写入此 String 的基本数据。 oos.writeUTF(\"你好，世界\"); //flush() void 刷新该流的缓冲。 oos.flush(); //close() void 关闭流。 oos.close(); } } DataOutputStreampublic class Test { public static void main(String[] args) throws IOException { DataOutputStream dos1 = new DataOutputStream(new FileOutputStream(\"E:\\\\Test6.txt\")); byte[] bytes1 = new byte[26]; for(int i = 0;i &lt; bytes1.length;i++) { bytes1[i] = (byte) ('a' + i%26); } //write(byte[] b, int off, int len) void 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入基础输出流。 dos1.write(bytes1, 0, 13); //write(int b) void 将指定字节（参数 b 的八个低位）写入基础输出流。 dos1.write(97); //writeBoolean(boolean v) void 将一个 boolean 值以 1-byte 值形式写入基础输出流。 dos1.writeBoolean(true); //writeByte(int v) void 将一个 byte 值以 1-byte 值形式写出到基础输出流中。 dos1.writeByte(98); //writeBytes(String s) void 将字符串按字节顺序写出到基础输出流中。 dos1.writeBytes(\"Hello World\"); //writeChar(int v) void 将一个 char 值以 2-byte 值形式写入基础输出流中，先写入高字节。 dos1.writeChar(99); //writeChars(String s) void 将字符串按字符顺序写入基础输出流。 dos1.writeChars(\"Hello World\"); //writeDouble(double v) void 使用 Double 类中的 doubleToLongBits 方法将 double 参数转换为一个 long 值，然后将该 long 值以 8-byte 值形式写入基础输出流中，先写入高字节。 dos1.writeDouble(99.9); //writeFloat(float v) void 使用 Float 类中的 floatToIntBits 方法将 float 参数转换为一个 int 值，然后将该 int 值以 4-byte 值形式写入基础输出流中，先写入高字节。 dos1.writeFloat(99.8f); //writeInt(int v) void 将一个 int 值以 4-byte 值形式写入基础输出流中，先写入高字节。 dos1.writeInt(100); //writeLong(long v) void 将一个 long 值以 8-byte 值形式写入基础输出流中，先写入高字节。 dos1.writeLong(101l); //writeShort(int v) void 将一个 short 值以 2-byte 值形式写入基础输出流中，先写入高字节。 dos1.writeShort(102); //writeUTF(String str) void 以与机器无关方式使用 UTF-8 修改版编码将一个字符串写入基础输出流。 dos1.writeUTF(\"你好，世界\"); //size() int 返回计数器 written 的当前值，即到目前为止写入此数据输出流的字节数。 System.out.println(\"size():\" + dos1.size()); //flush() void 清空此数据输出流。 dos1.flush(); //write(byte[] b) void 将 b.length 个字节写入此输出流。 dos1.close(); //close() void 关闭此输出流并释放与此流有关的所有系统资源。 } }","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"IO","slug":"IO","permalink":"https://luoweiguang.github.io/tags/IO/"}]},{"title":"JavaIO（一）：分类","slug":"JavaIO（一）：分类","date":"2016-04-25T11:00:00.000Z","updated":"2017-08-06T09:45:21.875Z","comments":true,"path":"2016/04/25/JavaIO（一）：分类/","link":"","permalink":"https://luoweiguang.github.io/2016/04/25/JavaIO（一）：分类/","excerpt":"","text":"Java流的分类 按流向分:输入流: 程序可以从中读取数据的流。输出流: 程序能向其中写入数据的流。 按数据传输单位分:字节流: 以字节为单位传输数据的流字符流: 以字符为单位传输数据的流 InputStream 类 功能 ByteArrayInputStream 允许将内存的缓冲区当做InputStream使用 StringBufferInputStream(已过时) 将String转换成InputStream FileInputStream 用于从文件中读取信息 PipedInputStream 产生用于写入相关PipedOutputStream的数据。实现管道化概念 SequenceInputStream 将两个或多个InputStream对象转换成单一InputStream FilterInputStream 抽象类，作为”装饰器的”接口。其中”装饰器”为其他的InputStream类提供有用功能 BufferedInputStream BufferedInputStream 为另一个输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力。 DataInputStream DataInputStream允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。 LineNumberInputStream(已过时) 此类是一个输入流过滤器，它提供跟踪当前行号的附加功能。 PushbackInputStream PushbackInputStream 为另一个输入流添加性能，即“推回 (push back)”或“取消读取 (unread)”一个字节的能力。 ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。 OutputStream 类 功能 ByteArrayOutputStream 在内存中创建缓冲区。所有送往“流”的数据都要放置在 此缓冲区 FileOutputStream 用于将信息写入文件 FilterOutputStream 抽象类，作为”装饰器的”接口。其中”装饰器”为其他的InputStream类提供有用功能 ObjectOutputStream ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。 PipedOutputStream 任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现”管道化”概念 BufferedOutputStream 该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。 DataOutputStream 数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。然后，应用程序可以使用数据输入流将数据读入。 PrintStream PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 Writer 类 功能 BufferedWriter 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 CharArrayWriter 此类实现一个可用作 Writer 的字符缓冲区。 FilterWriter 用于写入已过滤的字符流的抽象类。 OutputStreamWriter OutputStreamWriter 是字符流通向字节流的桥梁 FileWriter 用来写入字符文件的便捷类。 PipedWriter 传送的字符输出流。 PrintWriter 向文本输出流打印对象的格式化表示形式。 StringWriter 一个字符流，可以用其回收在字符串缓冲区中的输出来构造字符串。 Reader 类 功能 BufferedReader 字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取 LineNumberReader 跟踪行号的缓冲字符输入流 CharArrayReader 此类实现一个可用作字符输入流的字符缓冲区。 FilterReader 用于读取已过滤的字符流的抽象类 PushbackReader 允许将字符推回到流的字符流 reader InputStreamReader InputStreamReader 是字节流通向字符流的桥梁 FileReader 用来读取字符文件的便捷类 PipedReader 传送的字符输入流。 StringReader 其源为一个字符串的字符流。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"IO","slug":"IO","permalink":"https://luoweiguang.github.io/tags/IO/"}]},{"title":"URI、URL","slug":"URI、URL","date":"2016-04-19T02:00:00.000Z","updated":"2017-08-06T09:15:14.677Z","comments":true,"path":"2016/04/19/URI、URL/","link":"","permalink":"https://luoweiguang.github.io/2016/04/19/URI、URL/","excerpt":"概述URI（uniform resource identifier）统一资源标识符URL（uniform resource locator）统一资源定位器\nURL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置\n●在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。因此URL类只能作用于那些 Java类库知道该如何处理的模式，例如http：，https：，ftp：，本地文件系统(file：)，和Jar文件(jar：)。","text":"概述URI（uniform resource identifier）统一资源标识符URL（uniform resource locator）统一资源定位器 URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置 ●在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。因此URL类只能作用于那些 Java类库知道该如何处理的模式，例如http：，https：，ftp：，本地文件系统(file：)，和Jar文件(jar：)。 ●URI一般由三部组成①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 ●URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 结构URI的结构:[Scheme:][SchemeSpecificPart][#fragment] ||[Scheme:][//Authority][path][?query][#fragment] ||[scheme:][//userinfo@][host][:port][path][?query][#fragment] URL的结构[Protocol:][//Authority][File][#Ref] ||[Protocol:][//userinfo@][host][:port][?query][#Ref] 例子URI public class Test { public static void main(String[] args) throws URISyntaxException, MalformedURLException { String str = \"http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345\"; URI uri1 = new URI(str); URI uri2 = new URI(\"http\",\"//www.baidu.com:8080/123?asd=123\", \"123\"); URI uri3 = new URI(\"http\", \"www.baidu.com\", \"/123\", \"123\"); URI uri4 = new URI(\"http\", \"www.baidu.com\", \"/123\",\"asd=123\", \"123\"); URI uri5 = new URI(\"http\", \"Test%E4%B8%AD%E6%96%87\", \"www.baidu.com\", 8080,\"/123\",\"asd=123\", \"123\"); URI uri6 = new URI(\"http://www.baidu.com\"); URI uri7 = new URI(\"x/../123/../456?asd=123\"); URI uri8 = new URI(\"mailto:java-net@java.sun.com\"); System.out.println(uri1); System.out.println(uri2); System.out.println(uri3); System.out.println(uri4); System.out.println(uri5); //compareTo(URI that) int 将此 URI 与另一个对象（也必须是 URI）进行比较。 System.out.println(\"compareTo(URI that):\" + uri4.compareTo(uri5)); //create(String str) static URI 通过解析给定的字符串创建 URI。 System.out.println(\"create(String str):\" + URI.create(str)); //equals(Object ob) boolean 测试此 URI 与另一对象的相等性。 System.out.println(\"equals(Object ob):\" + uri1.equals(URI.create(str))); //getAuthority() String 返回此 URI 的已解码的授权组成部分。 System.out.println(\"getAuthority():\" + uri1.getAuthority()); //getFragment() String 返回此 URI 的已解码的片段组成部分。 System.out.println(\"getFragment():\" + uri1.getFragment()); //getHost() String 返回此 URI 的主机组成部分。 System.out.println(\"getHost():\" + uri1.getHost()); //getPath() String 返回此 URI 的已解码的路径组成部分。 System.out.println(\"getPath():\" + uri1.getPath()); //getPort() int 返回此 URI 的端口号。 System.out.println(\"getPort():\" + uri1.getPort()); //getQuery() String 返回此 URI 的已解码的查询组成部分。 System.out.println(\"getQuery():\" + uri1.getQuery()); //getRawAuthority() String 返回此 URI 的原始授权组成部分。 System.out.println(\"getRawAuthority():\" + uri1.getRawAuthority()); //getRawFragment() String 返回此 URI 的原始片段组成部分。 System.out.println(\"getRawFragment():\" + uri1.getRawFragment()); //getRawPath() String 返回此 URI 的原始路径组成部分。 System.out.println(\"getRawPath():\" + uri1.getRawPath()); //getRawQuery() String 返回此 URI 的原始查询组成部分。 System.out.println(\"getRawQuery():\" + uri1.getRawQuery()); //getRawSchemeSpecificPart() String 返回此 URI 原始的、特定于方案的部分。 System.out.println(\"getRawSchemeSpecificPart():\" + uri1.getRawSchemeSpecificPart()); //getRawUserInfo() String 返回此 URI 的原始用户信息组成部分。 System.out.println(\"getRawUserInfo():\" + uri1.getRawUserInfo()); //getScheme() String 返回此 URI 的方案组成部分。 System.out.println(\"getScheme():\" + uri1.getScheme()); //getSchemeSpecificPart() String 返回此 URI 的特定于方案的解码部分。 System.out.println(\"getSchemeSpecificPart():\" + uri1.getSchemeSpecificPart()); //getUserInfo() String 返回此 URI 的已解码的用户信息组成部分。 System.out.println(\"getUserInfo():\" + uri1.getUserInfo()); //hashCode() int 返回此 URI 的哈希码值。 System.out.println(\"hashCode():\" + uri1.hashCode()); //isAbsolute() boolean 判断此 URI 是否为绝对的。 System.out.println(\"isAbsolute():\" + uri1.isAbsolute()); //isOpaque() boolean 判断此 URI 是否为不透明的。 System.out.println(\"isOpaque():\" + uri8.isOpaque()); //normalize() URI 规范化此 URI 的路径。 System.out.println(\"normalize():\" + uri7.normalize()); //parseServerAuthority() URI 尝试将此 URI 的授权组成部分（如果已定义）解析为用户信息、主机和端口组成部分。 System.out.println(\"parseServerAuthority():\" + uri1.parseServerAuthority()); //relativize(URI uri) URI 根据此 URI 将给定 URI 相对化。 即把传入去除的URI路径去掉相同的部分 System.out.println(\"relativize(URI uri):\" + uri3.relativize(uri4)); //resolve(String str) URI 解析给定的字符串，然后在此 URI 的基础上构造一个新的 URI。 System.out.println(\"resolve(String str):\" + uri6.resolve(\"/123\")); //resolve(URI uri) URI 根据此 URI 解析给定的 URI。 System.out.println(\"resolve(URI uri):\" + uri4.resolve(uri3)); //toASCIIString() String 以 US-ASCII 字符串形式返回此 URI 的内容。 System.out.println(\"toASCIIString():\" + uri1.toASCIIString()); //toString() String 以字符串形式返回此 URI 的内容。 System.out.println(\"toString():\" + uri1.toString()); //toURL() URL 根据此 URI 构造一个 URL。 System.out.println(\"toURL():\" + uri1.toURL()); } } 结果 http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345 http://www.baidu.com:8080/123?asd=123#123 http://www.baidu.com/123#123 http://www.baidu.com/123?asd=123#123 http://Test%25E4%25B8%25AD%25E6%2596%2587@www.baidu.com:8080/123?asd=123#123 compareTo(URI that):-1 create(String str):http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345 equals(Object ob):true getAuthority():Test中文@user.qzone.qq.com:8080 getFragment():122345 getHost():user.qzone.qq.com getPath():/123456/Test中文 getPort():8080 getQuery():ptsig=中文Test/oR getRawAuthority():Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080 getRawFragment():122345 getRawPath():/123456/Test%E4%B8%AD%E6%96%87 getRawQuery():ptsig=%E4%B8%AD%E6%96%87Test/oR getRawSchemeSpecificPart()://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR getRawUserInfo():Test%E4%B8%AD%E6%96%87 getScheme():http getSchemeSpecificPart()://Test中文@user.qzone.qq.com:8080/123456/Test中文?ptsig=中文Test/oR getUserInfo():Test中文 hashCode():1143769884 isAbsolute():true isOpaque():true normalize():456?asd=123 parseServerAuthority():http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345 relativize(URI uri):?asd=123#123 resolve(String str):http://www.baidu.com/123 resolve(URI uri):http://www.baidu.com/123#123 toASCIIString():http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345 toString():http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345 toURL():http://Test%E4%B8%AD%E6%96%87@user.qzone.qq.com:8080/123456/Test%E4%B8%AD%E6%96%87?ptsig=%E4%B8%AD%E6%96%87Test/oR#122345 URL public class Test { public static void main(String[] args) throws IOException, URISyntaxException { //根据 String 表示形式创建 URL 对象。 URL url1 = new URL(\"https://hao.360.cn:80/?src=360c\"); //根据指定的 protocol 名称、host 名称和 file 名称创建 URL。 URL url2 = new URL(\"http\", \"wwww.baidu.com\", \"/123?asd=123#123\"); //根据指定 protocol、host、port 号和 file 创建 URL 对象。 URL url3 = new URL(\"http\", \"www.baidu.com\", 80, \"baidu?&amp;ie=utf-8&amp;word=\"); //根据指定的 protocol、host、port 号、file 和 handler 创建 URL 对象。 URL url4 = new URL(\"http\", \"wwww.baidu.com\", 80, \"baidu?&amp;ie=utf-8&amp;word=123\",null ); //使用基地址和相对URL创建。 URL url5 = new URL(url2, \"/123\"); URL url6 = new URL(url2, \"/123\", null); URL url7 = new URL(\"http://www.weather.com.cn/data/cityinfo/101010100.html\"); //equals(Object obj) boolean 比较此 URL 是否等于另一个对象。 System.out.println(\"equals(Object obj):\" + url5.equals(url6)); //getAuthority() String 获取此 URL 的授权部分。 System.out.println(\"getAuthority():\" + url1.getAuthority()); //getContent() Object 获取此 URL 的内容。 InputStream in = (InputStream) url7.getContent(); System.out.println(\"getContent():\" + inputStream2String(in)); //getDefaultPort() int 获取与此 URL关联协议的默认端口号。 System.out.println(\"getDefaultPort():\" + url2.getDefaultPort()); //getFile() String 获取此 URL的文件名。 System.out.println(\"getFile():\" + url2.getFile()); //getHost() String 获取此 URL的主机名（如果适用）。 System.out.println(\"getHost():\" + url2.getHost()); //getPath() String 获取此 URL 的路径部分。 System.out.println(\"getPath():\" + url2.getPath()); //getPort() int 获取此 URL的端口号。 System.out.println(\"getPort():\" + url2.getPort()); //getProtocol() String 获取此 URL的协议名称。 System.out.println(\"getProtocol():\" + url2.getProtocol()); //getQuery() String 获取此 URL的查询部分。 System.out.println(\"getQuery():\" + url2.getQuery()); //getRef() String 获取此 URL 的锚点（也称为“引用”）。 System.out.println(\"getRef():\" + url2.getRef()); //getUserInfo() String 获取此 URL 的 userInfo 部分。 System.out.println(\"getUserInfo():\" + url2.getUserInfo()); //hashCode() int 创建一个适合哈希表索引的整数。 System.out.println(\"hashCode():\" + url1.hashCode()); //openConnection() URLConnection 返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。 System.out.println(\"openConnection():\" + url1.openConnection()); //openConnection(Proxy proxy) URLConnection 与 openConnection() 类似，所不同是连接通过指定的代理建立；不支持代理方式的协议处理程序将忽略该代理参数并建立正常的连接。 System.out.println(\"openConnection(Proxy proxy):\" + url1.openConnection(Proxy.NO_PROXY)); //openStream() InputStream 打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream。 InputStream in2 = url7.openStream(); System.out.println(\"openStream():\" + inputStream2String(in2)); //sameFile(URL other) boolean 比较两个 URL，不包括片段部分。 System.out.println(\"sameFile(URL other):\" + url3.sameFile(url4)); //toExternalForm() String 构造此 URL 的字符串表示形式。 System.out.println(\"toExternalForm():\" + url1.toExternalForm()); //toString() String 构造此 URL的字符串表示形式。 System.out.println(\"toString():\" + url1.toString()); //toURI() URI 返回与此 URL 等效的 URI System.out.println(\"toURI():\" + url1.toURI()); } static String inputStream2String(InputStream is) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(is)); StringBuffer buffer = new StringBuffer(); String line = \"\"; while ((line = in.readLine()) != null){ buffer.append(line); } return buffer.toString(); } } 结果 equals(Object obj):true getAuthority():hao.360.cn:80 getContent():{&quot;weatherinfo&quot;:{&quot;city&quot;:&quot;北京&quot;,&quot;cityid&quot;:&quot;101010100&quot;,&quot;temp1&quot;:&quot;-2℃&quot;,&quot;temp2&quot;:&quot;16℃&quot;,&quot;weather&quot;:&quot;晴&quot;,&quot;img1&quot;:&quot;n0.gif&quot;,&quot;img2&quot;:&quot;d0.gif&quot;,&quot;ptime&quot;:&quot;18:00&quot;}} getDefaultPort():80 getFile():/123?asd=123 getHost():wwww.baidu.com getPath():/123 getPort():-1 getProtocol():http getQuery():asd=123 getRef():123 getUserInfo():null hashCode():-1412650423 openConnection():sun.net.www.protocol.https.DelegateHttpsURLConnection:https://hao.360.cn:80/?src=360c openConnection(Proxy proxy):sun.net.www.protocol.https.DelegateHttpsURLConnection:https://hao.360.cn:80/?src=360c openStream():{&quot;weatherinfo&quot;:{&quot;city&quot;:&quot;北京&quot;,&quot;cityid&quot;:&quot;101010100&quot;,&quot;temp1&quot;:&quot;-2℃&quot;,&quot;temp2&quot;:&quot;16℃&quot;,&quot;weather&quot;:&quot;晴&quot;,&quot;img1&quot;:&quot;n0.gif&quot;,&quot;img2&quot;:&quot;d0.gif&quot;,&quot;ptime&quot;:&quot;18:00&quot;}} sameFile(URL other):false toExternalForm():https://hao.360.cn:80/?src=360c toString():https://hao.360.cn:80/?src=360c toURI():https://hao.360.cn:80/?src=360c 参考资料URI和URL有什么区别","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"网络","slug":"网络","permalink":"https://luoweiguang.github.io/tags/网络/"}]},{"title":"File、FileFilter、FilenameFilter","slug":"File、FileFilter、FilenameFilter","date":"2016-04-17T12:00:00.000Z","updated":"2017-08-06T09:47:43.730Z","comments":true,"path":"2016/04/17/File、FileFilter、FilenameFilter/","link":"","permalink":"https://luoweiguang.github.io/2016/04/17/File、FileFilter、FilenameFilter/","excerpt":"概述FileFilter和FilenameFilter都是文件过滤器，都是一个接口，只有方法accept(),accept返回true表示符合所需文件标准，要过滤掉的文件则返回false","text":"概述FileFilter和FilenameFilter都是文件过滤器，都是一个接口，只有方法accept(),accept返回true表示符合所需文件标准，要过滤掉的文件则返回false public interface FileFilter { boolean accept(File pathname); } public interface FilenameFilter { //dir表示文件的当前目录，name表示文件名； boolean accept(File dir, String name); } 例子public class Test { public static void main(String[] args) throws URISyntaxException, IOException { //通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例 File file1 = new File(\"E:\\\\\"); //根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 File file2 = new File(file1, \"Test2.rar\"); //通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。 URI uri = new URI(\"file:///E:/Test.txt\"); File file3 = new File(uri); //根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。 File file4 = new File(\"E:\\\\\", \"Test.txt\"); File file5 = new File(\"E:\\\\\", \"Test3.txt\"); File file6 = new File(\"E:\\\\test\"); File file7 = new File(\"E:\\\\Test\"); //canExecute() boolean 测试应用程序是否可以执行此抽象路径名表示的文件 System.out.println(\"canExecute():\" + file2.canExecute()); //canRead() boolean 测试应用程序是否可以读取此抽象路径名表示的文件 System.out.println(\"canRead():\" + file2.canRead()); //canWrite() boolean 测试应用程序是否可以修改此抽象路径名表示的文件 System.out.println(\"canWrite():\" + file2.canWrite()); //compareTo(File pathname) int 按字母顺序比较两个抽象路径名。 System.out.println(\"compareTo(File pathname):\" + file1.compareTo(file2)); //createNewFile() boolean 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 ture 表示新建成功 System.out.println(\"createNewFile():\" + file5.createNewFile()); //createTempFile(String prefix, String suffix) static File 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。 System.out.println(\"createTempFile(String prefix, String suffix):\" + File.createTempFile(\"test\", \"txt\")); //createTempFile(String prefix, String suffix, File directory) static File 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。 System.out.println(\"createTempFile(String prefix, String suffix, File directory):\" + File.createTempFile(\"test\", \"txt\", file1)); //delete() boolean 删除此抽象路径名表示的文件或目录。 System.out.println(\"delete():\" + file5.delete()); //deleteOnExit() void 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。 file5.deleteOnExit(); System.out.println(\"deleteOnExit():\" + file5); //equals(Object obj) boolean 测试此抽象路径名与给定对象是否相等。 System.out.println(\"equals(Object obj):\" + file3.equals(file4)); //exists() boolean 测试此抽象路径名表示的文件或目录是否存在。 System.out.println(\"exists():\" + file2.exists()); //getAbsoluteFile() File 返回此抽象路径名的绝对路径名形式。 System.out.println(\"getAbsoluteFile():\" + file2.getAbsoluteFile()); //getAbsolutePath() String 返回此抽象路径名的绝对路径名字符串。 System.out.println(\"getAbsolutePath():\" + file2.getAbsolutePath()); //getCanonicalFile() File 返回此抽象路径名的规范形式。 System.out.println(\"getCanonicalFile():\" + file2.getCanonicalPath()); //getCanonicalPath() String 返回此抽象路径名的规范路径名字符串。 System.out.println(\"getCanonicalPath():\" + file2.getCanonicalPath()); //getFreeSpace() long 返回此抽象路径名指定的分区中未分配的字节数。 System.out.println(\"getFreeSpace():\" + file1.getFreeSpace()); //getName() String 返回由此抽象路径名表示的文件或目录的名称。 System.out.println(\"getName():\" + file2.getName()); //getParent() String 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。 System.out.println(\"getParent():\" + file2.getParent()); //getParentFile() File 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。 System.out.println(\"getParentFile():\" + file2.getParentFile()); //getPath() String 将此抽象路径名转换为一个路径名字符串。 System.out.println(\"getPath():\" + file2.getPath()); //getTotalSpace() long 返回此抽象路径名指定的分区大小。 System.out.println(\"getTotalSpace():\" + file1.getTotalSpace()); //getUsableSpace() long 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。 System.out.println(\"getUsableSpace():\" + file1.getUsableSpace()); //hashCode() int 计算此抽象路径名的哈希码。 System.out.println(\"hashCode():\" + file1.hashCode()); //isAbsolute() boolean 测试此抽象路径名是否为绝对路径名。 System.out.println(\"isAbsolute():\" + file2.isAbsolute()); //isDirectory() boolean 测试此抽象路径名表示的文件是否是一个目录。 System.out.println(\"isDirectory():\" + file1.isDirectory()); //isFile() boolean 测试此抽象路径名表示的文件是否是一个标准文件。 System.out.println(\"isFile():\" + file2.isFile()); //isHidden() boolean 测试此抽象路径名指定的文件是否是一个隐藏文件。 假如是文件夹会返回ture System.out.println(\"isHidden():\" + file2.isHidden()); //lastModified() long 返回此抽象路径名表示的文件最后一次被修改的时间。 System.out.println(\"lastModified():\" + file2.lastModified()); //length() long 返回由此抽象路径名表示的文件的长度。 System.out.println(\"length():\" + file2.length()); //list() String[] 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 String[] strs1 = file6.list(); for(String str : strs1) System.out.println(\"list():\" + str); //list(FilenameFilter filter) String[] 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。 String[] strs2 = file6.list(new FilenameFilter() { @Override public boolean accept(File dir, String name) { if(name.endsWith(\".txt\")) return true; return false; } }); for(String str : strs2) System.out.println(\"list(FilenameFilter filter):\" + str); //listFiles() File[] 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 File[] files1 = file6.listFiles(); for(File file : files1) System.out.println(\"listFiles():\" +file); //listFiles(FileFilter filter) File[] 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 File[] files2 = file6.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { if(pathname.getName().endsWith(\".txt\")) return true; return false; } }); for(File file : files2) System.out.println(\"listFiles(FileFilter filter):\" + file); //listFiles(FilenameFilter filter) File[] 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 File[] files3 = file6.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { if(name.endsWith(\".txt\")) return true; return false; } }); for(File file : files3) System.out.println(\"listFiles(FilenameFilter filter):\" + file); //listRoots() static File[] 列出可用的文件系统根。 File[] files4 = File.listRoots(); for(File file : files4) System.out.println(\"listRoots():\" + file); //mkdir() boolean 创建此抽象路径名指定的目录。 System.out.println(\"mkdir():\" + file6.mkdir()); //mkdirs() boolean 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。 System.out.println(\"mkdirs():\" + file6.mkdirs()); //renameTo(File dest) boolean 重新命名此抽象路径名表示的文件。 System.out.println(\"renameTo(File dest):\" + file5.renameTo(file3)); //setExecutable(boolean executable) boolean 设置此抽象路径名所有者执行权限的一个便捷方法。 System.out.println(\"setExecutable(boolean executable):\" + file2.setExecutable(true)); //setExecutable(boolean executable, boolean ownerOnly) boolean 设置此抽象路径名的所有者或所有用户的执行权限。 System.out.println(\"setExecutable(boolean executable, boolean ownerOnly):\" + file2.setExecutable(true, false)); //setLastModified(long time) boolean 设置此抽象路径名指定的文件或目录的最后一次修改时间。 System.out.println(\"setLastModified(long time):\" + file1.setLastModified(new Date().getTime())); //setReadable(boolean readable) boolean 设置此抽象路径名所有者读权限的一个便捷方法。 System.out.println(\"setReadable(boolean readable):\" + file1.setReadable(true)); //setReadable(boolean readable, boolean ownerOnly) boolean 设置此抽象路径名的所有者或所有用户的读权限。 System.out.println(\"setReadable(boolean readable, boolean ownerOnly):\" + file1.setReadable(true, false)); //setReadOnly() boolean 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。 System.out.println(\"setReadOnly():\" + file2.setReadOnly()); //setWritable(boolean writable) boolean 设置此抽象路径名所有者写权限的一个便捷方法。 System.out.println(\"setWritable(boolean writable):\" + file2.setWritable(true)); //setWritable(boolean writable, boolean ownerOnly) boolean 设置此抽象路径名的所有者或所有用户的写权限。 System.out.println(\"setWritable(boolean writable, boolean ownerOnly):\" + file2.setWritable(true, true)); //toString() String 返回此抽象路径名的路径名字符串。 System.out.println(\"toString():\" + file2.toString()); //toURI() URI 构造一个表示此抽象路径名的 file: URI。 System.out.println(\"toURI():\" + file3.toURI()); } } canExecute():true canRead():true canWrite():true compareTo(File pathname):-9 createNewFile():false createTempFile(String prefix, String suffix):C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\test6093908792030020865txt createTempFile(String prefix, String suffix, File directory):E:\\test8672086278670390974txt delete():true deleteOnExit():E:\\Test3.txt equals(Object obj):true exists():true getAbsoluteFile():E:\\Test2.rar getAbsolutePath():E:\\Test2.rar getCanonicalFile():E:\\Test2.rar getCanonicalPath():E:\\Test2.rar getFreeSpace():55538286592 getName():Test2.rar getParent():E:\\ getParentFile():E:\\ getPath():E:\\Test2.rar getTotalSpace():200773988352 getUsableSpace():55538286592 hashCode():1267478 isAbsolute():true isDirectory():true isFile():true isHidden():false lastModified():1460885084640 length():84 list():test list():test1.txt list():test2.txt list(FilenameFilter filter):test1.txt list(FilenameFilter filter):test2.txt listFiles():E:\\test\\test listFiles():E:\\test\\test1.txt listFiles():E:\\test\\test2.txt listFiles(FileFilter filter):E:\\test\\test1.txt listFiles(FileFilter filter):E:\\test\\test2.txt listFiles(FilenameFilter filter):E:\\test\\test1.txt listFiles(FilenameFilter filter):E:\\test\\test2.txt listRoots():C:\\ listRoots():D:\\ listRoots():E:\\ listRoots():F:\\ listRoots():G:\\ listRoots():I:\\ mkdir():false mkdirs():false renameTo(File dest):false setExecutable(boolean executable):true setExecutable(boolean executable, boolean ownerOnly):true setLastModified(long time):true setReadable(boolean readable):true setReadable(boolean readable, boolean ownerOnly):true setReadOnly():true setWritable(boolean writable):true setWritable(boolean writable, boolean ownerOnly):true toString():E:\\Test2.rar toURI():file:/E:/Test.txt","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"},{"name":"IO","slug":"IO","permalink":"https://luoweiguang.github.io/tags/IO/"}]},{"title":"String、StringBuffer、StringBuilder","slug":"String、StringBuffer、StringBuilder","date":"2016-04-16T13:00:00.000Z","updated":"2017-08-06T09:49:43.632Z","comments":true,"path":"2016/04/16/String、StringBuffer、StringBuilder/","link":"","permalink":"https://luoweiguang.github.io/2016/04/16/String、StringBuffer、StringBuilder/","excerpt":"","text":"例子String public class Test { public static void main(String[] args) throws UnsupportedEncodingException { String str = \"Hello World\"; // charAt(int index) char 返回指定索引处的char值 System.out.println(\"charAt(int index):\"+str.charAt(0)); // codePointAt(int index) int 返回指定索引处的字符（Unicode 代码点）。 System.out.println(\"codePointAt(int index):\"+str.codePointAt(0)); // codePointBefore(int index) int 返回指定索引之前的字符（Unicode 代码点）。codePointBefore(index)相当于codePointAt(index - 1); System.out.println(\"codePointBefore(int index):\"+str.codePointBefore(1)); // codePointCoubt(int beginIndex,int endIndex) int 返回此 String 的指定文本范围中的 Unicode 代码点数。 //一般用不到 System.out.println(\"codePointCoubt(int beginIndex,int endIndex):\" + str.codePointCount(1, 10)); // compareTo(String anotherString) int 按字典顺序比较两个字符串。 正数表示str更大 System.out.println(\"compareTo(String anotherString):\" + str.compareTo(\"Hello World\")); // compareToIgnoreCase(String str) int 按字典顺序比较两个字符串，不考虑大小写。 正数表示str更大 System.out.println(\"compareToIgnoreCase(String str):\" + str.compareToIgnoreCase(\"hello world\")); // concat(String str) String 将指定字符串连接到此字符串的结尾。 不会改变str的值 System.out.println(\"concat(String str):\" + str.concat(\".\")); // contains(CharSequence s) boolean 当且仅当此字符串包含指定的 char 值序列时，返回 true。 System.out.println(\"contains(CharSequence s):\" + str.contains(\"Hello World\")); //contentEquals(CharSequence cs) boolean 将此字符串与指定的 CharSequence 比较。 System.out.println(\"contentEquals(CharSequence cs):\" + str.contentEquals(\"He\")); //contentEquals(StringBuffer sb) boolean 将此字符串与指定的 StringBuffer 比较。 System.out.println(\"contentEquals(StringBuffer sb):\" + str.contentEquals(new StringBuffer(\"Hello World\"))); //copyValueOf(char[] data) static String 返回指定数组中表示该字符序列的 String。 char[] array = new char[]{'H','e','l','l','o',' ','W','o','r','l','d'}; System.out.println(\"copyValueOf(char[] data):\" + String.copyValueOf(array)); //copyValueOf(char[] data, int offset, int count) static String 返回指定数组中表示该字符序列的 String。 System.out.println(\"copyValueOf(char[] data, int offset, int count):\" + String.copyValueOf(array, 0, 5)); //endsWith(String suffix) boolean 测试此字符串是否以指定的后缀结束。 System.out.println(\"endsWith(String suffix):\" + str.endsWith(\"World \")); //equals(Object anObject) boolean 将此字符串与指定的对象比较。 System.out.println(\"equals(Object anObject):\" + str.equals(\"Hello World\")); //equalsIgnoreCase(String anotherString) boolean 将此 String 与另一个 String 比较，不考虑大小写。 System.out.println(\"equalsIgnoreCase(String anotherString):\" + str.equalsIgnoreCase(\"hello world\")); //format(Locale l, String format, Object... args) // 转 换 符 说 明 示 例 // %s 字符串类型 \"mingrisoft\" // %c 字符类型 'm' // %b 布尔类型 true // %d 整数类型（十进制） 99 // %x 整数类型（十六进制） FF // %o 整数类型（八进制） 77 // %f 浮点类型 99.99 // %a 十六进制浮点类型 FF.35AE // %e 指数类型 9.38e+5 // %g 通用浮点类型（f和e类型中较短的） // %h 散列码 // %% 百分比类型 ％ // %n 换行符 // %tx 日期与时间类型（x代表不同的日期与时间转换符 // 标 志 说 明 示 例 结 果 // + 为正数或者负数添加符号 (\"%+d\",15) +15 // − 左对齐 (\"%-5d\",15) |15 | // 0 数字前面补0 (\"%04d\", 99) 0099 // 空格 在整数之前添加指定数量的空格 (\"% 4d\", 99) | 99| // , 以“,”对数字分组 (\"%,f\", 9999.99) 9,999.990000 // ( 使用括号包含负数 (\"%(f\", -99.99) (99.990000) // # 如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0 (\"%#x\", 99) 0x63 // (\"%#o\", 99) 0143 // &lt; 格式化前一个转换符所描述的参数 (\"%f和%&lt;3.2f\", 99.45) 99.450000和99.45 // $ 被格式化的参数索引 (\"%1$d,%2$s\", 99,\"abc\") 99,abc // 转 换 符 说 明 示 例 // c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 // F “年-月-日”格式 2007-10-27 // D “月/日/年”格式 10/27/07 // r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 // T “HH:MM:SS”格式（24时制） 14:28:16 // R “HH:MM”格式（24时制） 14:28 // 转 换 符 说 明 示 例 // H 2位数字24时制的小时（不足2位前面补0） 15 // I 2位数字12时制的小时（不足2位前面补0） 03 // k 2位数字24时制的小时（前面不补0） 15 // l 2位数字12时制的小时（前面不补0） 3 // M 2位数字的分钟（不足2位前面补0） 03 // S 2位数字的秒（不足2位前面补0） 09 // L 3位数字的毫秒（不足3位前面补0） 015 // N 9位数字的毫秒数（不足9位前面补0） 562000000 // p 小写字母的上午或下午标记 中：下午英：pm // z 相对于GMT的RFC822时区的偏移量 +0800 // Z 时区缩写字符串 CST // s 1970-1-1 00:00:00 到现在所经过的秒数 1193468128 // Q 1970-1-1 00:00:00 到现在所经过的毫秒数 1193468128984 System.out.println(\"format(Locale l, String format, Object... args):\" + String.format(Locale.CHINA, \"%s\", str)); System.out.println(\"format(Locale l, String format, Object... args):\" + String.format(Locale.CHINA, \"%05d\", 123)); System.out.println(\"format(Locale l, String format, Object... args):\" + String.format(Locale.CHINA, \"%tc\", new Date())); System.out.println(\"format(Locale l, String format, Object... args):\" + String.format(Locale.CHINA, \"%tQ\", new Date())); //format(String format, Object... args) static String 使用指定的格式字符串和参数返回一个格式化字符串。 System.out.println(\"format(String format, Object... args):\" + String.format(\"%#x\", 123)); //getBytes() byte[] 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 System.out.println(\"getBytes():\" + new String(str.getBytes())); //getBytes(Charset charset) byte[] 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 System.out.println(\"getBytes(Charset charset):\" + new String(str.getBytes(Charset.defaultCharset()))); //getBytes(String charsetName) byte[] 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 System.out.println(\"getBytes(String charsetName):\" + new String(str.getBytes(\"UTF-8\"))); //getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) void 将字符从此字符串复制到目标字符数组。 char[] array2 = new char[]{'a','b','c','d','e','f','g','h','i','j','k'}; str.getChars(0, 5, array2, 4); System.out.println(\"getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin):\" + new String(array2)); //hashCode() int 返回此字符串的哈希码。 System.out.println(\"hashCode():\" + str.hashCode()); //indexOf(int ch) int 返回指定字符在此字符串中第一次出现处的索引。 System.out.println(\"indexOf(int ch):\" + str.indexOf('H')); //indexOf(int ch, int fromIndex) int 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 System.out.println(\"indexOf(int ch, int fromIndex):\" + str.indexOf('l',4)); //indexOf(String str) System.out.println(\"indexOf(String str):\" + str.indexOf(\"Hello\")); //indexOf(String str, int fromIndex) int 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 System.out.println(\"indexOf(String str, int fromIndex):\" + str.indexOf(\"l\", 4)); //intern() String 返回字符串对象的规范化表示形式。即将字符串添加到常量池中(假如常量池中没有)，并返回其引用 System.out.println(\"intern():\" + str.intern()); //isEmpty() boolean 当且仅当 length() 为 0 时返回 true。 System.out.println(\"isEmpty():\" + str.isEmpty()); //lastIndexOf(int ch) int 返回指定字符在此字符串中最后一次出现处的索引。 System.out.println(\"lastIndexOf(int ch):\" + str.lastIndexOf('l')); //lastIndexOf(int ch, int fromIndex) int 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 System.out.println(\"lastIndexOf(int ch, int fromIndex):\" + str.lastIndexOf('l', 8)); //lastIndexOf(String str) int 返回指定子字符串在此字符串中最右边出现处的索引。 System.out.println(\"lastIndexOf(String str):\" + str.lastIndexOf(\"World\")); //lastIndexOf(String str, int fromIndex) int 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 System.out.println(\"lastIndexOf(String str, int fromIndex):\" + str.lastIndexOf(\"World\", 5)); //length() int 返回此字符串的长度。 System.out.println(\"length():\" + str.length()); //matches(String regex) boolean 告知此字符串是否匹配给定的正则表达式。 System.out.println(\"matches(String regex):\" + str.matches(\"[H]ello World\")); //offsetByCodePoints(int index, int codePointOffset) int 返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引。 System.out.println(\"offsetByCodePoints(int index, int codePointOffset):\" + str.offsetByCodePoints(2, 5)); //regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) boolean 测试两个字符串区域是否相等。 // 参数： // ignoreCase - 如果为 true，则比较字符时忽略大小写。 // toffset - 此字符串中子区域的起始偏移量。 // other - 字符串参数。 // toffset - 字符串参数中子区域的起始偏移量。 // len - 要比较的字符数。 System.out.println(\"regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len):\" + str.regionMatches(false, 6, \"World\", 0, 3)); //regionMatches(int toffset, String other, int ooffset, int len) boolean 测试两个字符串区域是否相等。 System.out.println(\"regionMatches(int toffset, String other, int ooffset, int len):\" + str.regionMatches(6, \"World\", 0, 3)); //replace(char oldChar, char newChar) String 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 System.out.println(\"replace(char oldChar, char newChar):\" + str.replace('o', '0')); //replace(CharSequence target, CharSequence replacement) String 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 System.out.println(\"replace(CharSequence target, CharSequence replacement):\" + str.replace(\"Hello\", \"Hello \")); //replaceAll(String regex, String replacement) String 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 System.out.println(\"replaceAll(String regex, String replacement):\" + str.replaceAll(\"[l]\", \"L\")); //replaceFirst(String regex, String replacement) String 用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 System.out.println(\"replaceFirst(String regex, String replacement):\" + str.replaceFirst(\"[l]\", \"L\")); //split(String regex) String[] 根据给定正则表达式的匹配拆分此字符串。 String[] strs1 = str.split(\"[l]\"); for(int i = 0 ;i &lt; strs1.length; i++) System.out.println(\"split(String regex):\" +strs1[i]); //split(String regex, int limit) String[] 根据匹配给定的正则表达式来拆分此字符串。 String[] strs2 = str.split(\"[l]\",2); for(int i = 0 ;i &lt; strs2.length; i++) System.out.println(\"split(String regex, int limit):\" +strs2[i]); //startsWith(String prefix) boolean 测试此字符串是否以指定的前缀开始。 System.out.println(\"startsWith(String prefix):\" + str.startsWith(\"Hello\")); //startsWith(String prefix, int toffset) boolean 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 System.out.println(\"startsWith(String prefix, int toffset):\" + str.startsWith(\"World\", 6)); //subSequence(int beginIndex, int endIndex) CharSequence 返回一个新的字符序列，它是此序列的一个子序列。 System.out.println(\"subSequence(int beginIndex, int endIndex):\" + str.substring(2, 5)); //substring(int beginIndex) String 返回一个新的字符串，它是此字符串的一个子字符串。 System.out.println(\"substring(int beginIndex):\" + str.substring(6)); //substring(int beginIndex, int endIndex) String 返回一个新的字符串，它是此字符串的一个子字符串。 System.out.println(\"substring(int beginIndex, int endIndex):\" + str.substring(2, 3)); //toCharArray() char[] 将此字符串转换为一个新的字符数组。 System.out.println(\"toCharArray():\" + new String(str.toCharArray())); //toLowerCase() String 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 System.out.println(\"toLowerCase():\" + str.toLowerCase()); //toLowerCase(Locale locale) String 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 System.out.println(\"toLowerCase(Locale locale):\" + str.toLowerCase(Locale.CHINESE)); //toString() String 返回此对象本身（它已经是一个字符串！）。 System.out.println(\"toString():\" + str.toString()); //toUpperCase() String 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 System.out.println(\"toUpperCase():\" + str.toUpperCase()); //toUpperCase(Locale locale) String 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 System.out.println(\"toUpperCase(Locale locale):\" + str.toUpperCase(Locale.CHINESE)); //trim() String 返回字符串的副本，忽略前导空白和尾部空白。 System.out.println(\"trim():\" + str.trim()); //valueOf(boolean b) static String System.out.println(\"valueOf(boolean b):\" + String.valueOf(Boolean.FALSE)); //valueOf(char c) static String System.out.println(\"valueOf(char c):\" + String.valueOf('a')); //valueOf(char[] data) static String System.out.println(\"valueOf(char[] data):\" + String.valueOf(array2)); //valueOf(char[] data, int offset, int count) static String System.out.println(\"valueOf(char[] data, int offset, int count):\" + String.valueOf(array2,2,3)); //valueOf(double d) static String System.out.println(\"valueOf(double d):\" + String.valueOf(11.2d)); //valueOf(float f) static String System.out.println(\"valueOf(float f):\" + String.valueOf(11.3f)); //valueOf(int i) static String System.out.println(\"valueOf(int i):\" + String.valueOf(12)); //valueOf(long l) static String System.out.println(\"valueOf(long l):\" + String.valueOf(11111111111l)); //valueOf(Object obj) static String System.out.println(\"valueOf(Object obj):\" + String.valueOf(new Date())); } } 输出 charAt(int index):H codePointAt(int index):72 codePointBefore(int index):72 codePointCount(int beginIndex,int endIndex):9 compareTo(String anotherString):0 compareToIgnoreCase(String str):0 concat(String str):Hello World. contains(CharSequence s):true contentEquals(CharSequence cs):false contentEquals(StringBuffer sb):true copyValueOf(char[] data):Hello World copyValueOf(char[] data, int offset, int count):Hello endsWith(String suffix):false equals(Object anObject):true equalsIgnoreCase(String anotherString):true format(Locale l, String format, Object... args):Hello World format(Locale l, String format, Object... args):00123 format(Locale l, String format, Object... args):星期六 四月 16 20:23:41 CST 2016 format(Locale l, String format, Object... args):1460809421630 format(String format, Object... args):0x7b getBytes():Hello World getBytes(Charset charset):Hello World getBytes(String charsetName):Hello World getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin):abcdHellojk hashCode():-862545276 indexOf(int ch):0 indexOf(int ch, int fromIndex):9 indexOf(String str):0 indexOf(String str, int fromIndex):9 intern():Hello World isEmpty():false lastIndexOf(int ch):9 lastIndexOf(int ch, int fromIndex):3 lastIndexOf(String str):6 lastIndexOf(String str, int fromIndex):-1 length():11 matches(String regex):true offsetByCodePoints(int index, int codePointOffset):7 regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len):true regionMatches(int toffset, String other, int ooffset, int len):true replace(char oldChar, char newChar):Hell0 W0rld replace(CharSequence target, CharSequence replacement):Hello World replaceAll(String regex, String replacement):HeLLo WorLd replaceFirst(String regex, String replacement):HeLlo World split(String regex):He split(String regex): split(String regex):o Wor split(String regex):d split(String regex, int limit):He split(String regex, int limit):lo World startsWith(String prefix):true startsWith(String prefix, int toffset):true subSequence(int beginIndex, int endIndex):llo substring(int beginIndex):World substring(int beginIndex, int endIndex):l toCharArray():Hello World toLowerCase():hello world toLowerCase(Locale locale):hello world toString():Hello World toUpperCase():HELLO WORLD toUpperCase(Locale locale):HELLO WORLD trim():Hello World valueOf(boolean b):false valueOf(char c):a valueOf(char[] data):abcdHellojk valueOf(char[] data, int offset, int count):cdH valueOf(double d):11.2 valueOf(float f):11.3 valueOf(int i):12 valueOf(long l):11111111111 valueOf(Object obj):Sat Apr 16 20:23:41 CST 2016 StringBuffer public class Test { public static void main(String[] args) { // 构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。 StringBuffer sb1 = new StringBuffer(); // 构造一个不带字符，但具有指定初始容量的字符串缓冲区。 StringBuffer sb2 = new StringBuffer(512); // 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。 StringBuffer sb3 = new StringBuffer(\"Hello World\"); //append(boolean b) StringBuffer 将指定的boolean值添加到该序列。 System.out.println(\"append(boolean b):\" + sb1.append(true)); //append(char c) StringBuffer 将指定的char值添加到该序列。 System.out.println(\"append(char c):\" + sb1.append('a')); //append(char[] str) StringBuffer 将指定的char[]值添加到该序列。 char[] array = new char[]{'b','c','d','e','f'}; System.out.println(\"append(char[] str) :\" + sb1.append(array)); //append(char[] str, int offset, int len) StringBuffer 将指定的char[]值添加到该序列 System.out.println(\"append(char[] str, int offset, int len) :\" + sb1.append(array,2,3)); //append(CharSequence s) StringBuffer 将指定的 CharSequence 添加到该序列。 CharSequence charSequence = new String(\"ghijk\"); System.out.println(\"append(CharSequence s):\" + sb1.append(charSequence)); //append(CharSequence s, int start, int end) StringBuffer 将指定的 CharSequence 添加到该序列。 System.out.println(\"append(CharSequence s, int start, int end):\" + sb1.append(charSequence,2,5)); //append(double d) StringBuffer 将指定的double值添加到该序列。 System.out.println(\"append(double d):\" + sb1.append(11.2)); //append(float f) StringBuffer 将指定的float值添加到该序列。 System.out.println(\"append(float f):\" + sb1.append(11.3f)); //append(int i) StringBuffer 将指定的int值添加到该序列。 System.out.println(\"append(int i):\" + sb1.append(12)); //append(long lng) StringBuffer 将指定的long值添加到该序列。 System.out.println(\"append(long lng):\" + sb1.append(11111111111l)); //append(Object obj) StringBuffer 将指定的Object值添加到该序列。 System.out.println(\"append(Object obj):\" + sb1.append(new Date())); //append(String str) StringBuffer 将指定的String值添加到该序列。 System.out.println(\"append(String str):\" + sb1.append(\"Hello World\")); //append(StringBuffer sb) StringBuffer 将指定的float值添加到该序列。 System.out.println(\"append(StringBuffer sb):\" + sb1.append(new StringBuffer(\"Hello\"))); //appendCodePoint(int codePoint) StringBuffer 将指定的字符值添加到该序列。 System.out.println(\"appendCodePoint(int codePoint):\" + sb1.appendCodePoint(97)); //capacity() int 获取字符串缓冲区的容量大小，不是字符串长度。 System.out.println(\"capacity():\" + sb2.capacity()); //charAt(int index) char 返回指定索引处的char值 System.out.println(\"charAt(int index):\" + sb1.charAt(4)); //codePointAt(int index) int 返回指定索引处的字符（Unicode 代码点）。 System.out.println(\"codePointAt(int index):\" + sb1.codePointAt(4)); //codePointBefore(int index) int 返回指定索引之前的字符（Unicode 代码点）。codePointBefore(index)相当于codePointAt(index - 1); System.out.println(\"codePointBefore(int index):\" + sb1.codePointBefore(5)); //codePointCount(int beginIndex,int endIndex) int 返回此 String 的指定文本范围中的 Unicode 代码点数。 //一般用不到 System.out.println(\"codePointCount(int beginIndex,int endIndex):\" + sb1.codePointCount(4, 6)); //delete(int start, int end) StringBuffer 删除指定区间以内的所有字符，包含start，不包含end索引值的区间。 System.out.println(\"delete(int start, int end):\" + sb1.delete(0, 4)); //deleteCharAt(int index) StringBuffer 删除指定位置的字符，然后将剩余的内容形成新的字符串 System.out.println(\"deleteCharAt(int index):\" + sb1.deleteCharAt(0)); //ensureCapacity(int minimumCapacity) void 重新设置字符串容量的大小,只能设置比之前更大的数 sb1.ensureCapacity(1024); System.out.println(\"ensureCapacity(int minimumCapacity):\" + sb1.capacity()); //getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) void 将字符从此字符串复制到目标字符数组。 char[] array2 = new char[]{'a','b','c','d','e','f','g','h','i','j','k'}; sb1.getChars(0, 5, array2, 4); System.out.println(\"getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin):\" + new String(array2)); //indexOf(String str) int 返回指定字符在此字符串中第一次出现处的索引。 System.out.println(\"indexOf(String str):\" + sb1.indexOf(\"Hello\")); //indexOf(int ch, int fromIndex) int 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 System.out.println(\"indexOf(int ch, int fromIndex):\" + sb1.indexOf(\"Hello\", 66)); //insert(int offset, boolean b) StringBuffer 在StringBuffer对象指定处插入boolean值，然后形成新的字符串 System.out.println(\"insert(int offset, boolean b):\" + sb2.insert(0, true)); //insert(int offset, char c) StringBuffer 在StringBuffer对象指定处插入char值，然后形成新的字符串 System.out.println(\"insert(int offset, char c):\" + sb2.insert(4, 'a')); //insert(int offset, char[] str) StringBuffer 在StringBuffer对象指定处插入char[]值，然后形成新的字符串 System.out.println(\"insert(int offset, char[] str):\" + sb2.insert(4, array)); //insert(int index, char[] str, int offset, int len) StringBuffer 在StringBuffer对象指定处插入char[]值，然后形成新的字符串 System.out.println(\"insert(int index, char[] str, int offset, int len):\" + sb2.insert(4, array, 3, 2)); //insert(int dstOffset, CharSequence s) StringBuffer 在StringBuffer对象指定处插入CharSequence值，然后形成新的字符串 System.out.println(\"insert(int dstOffset, CharSequence s):\" + sb2.insert(4, charSequence)); //insert(int dstOffset, CharSequence s, int start, int end) StringBuffer 在StringBuffer对象指定处插入CharSequence值，然后形成新的字符串 System.out.println(\"insert(int dstOffset, CharSequence s, int start, int end):\" + sb2.insert(4, charSequence, 2, 4)); //insert(int offset, double d) StringBuffer 在StringBuffer对象指定处插入double值，然后形成新的字符串 System.out.println(\"insert(int offset, double d):\" + sb2.insert(4, 11.2)); //insert(int offset, float f) StringBuffer 在StringBuffer对象指定处插入float值，然后形成新的字符串 System.out.println(\"insert(int offset, float f):\" + sb2.insert(4, 11.3f)); //insert(int offset, int i) StringBuffer 在StringBuffer对象指定处插入int值，然后形成新的字符串 System.out.println(\"insert(int offset, int i):\" + sb2.insert(4, 13)); //insert(int offset, long l) StringBuffer 在StringBuffer对象指定处插入long值，然后形成新的字符串 System.out.println(\"insert(int offset, long l):\" + sb2.insert(4, 11111111111l)); //insert(int offset, Object obj) StringBuffer 在StringBuffer对象指定处插入Object值，然后形成新的字符串 System.out.println(\"insert(int offset, Object obj):\" + sb2.insert(4, new Date())); //insert(int offset, String str) StringBuffer 在StringBuffer对象指定处插入String值，然后形成新的字符串 System.out.println(\"insert(int offset, String str):\" + sb2.insert(4, \"Hello World\")); //lastIndexOf(String str) int 返回指定子字符串在此字符串中最右边出现处的索引。 System.out.println(\"lastIndexOf(String str):\" + sb1.lastIndexOf(\"Hello\")); //lastIndexOf(String str, int fromIndex) int 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 System.out.println(\"lastIndexOf(String str, int fromIndex):\" + sb1.lastIndexOf(\"Hello\", 81)); //length() int 获取字符串长度 System.out.println(\"length():\" + sb1.length()); //offsetByCodePoints(int index, int codePointOffset) int 返回该序列是从给定的索引由codePointOffset代码点偏移中的索引 System.out.println(\"offsetByCodePoints(int index, int codePointOffset):\" + sb1.offsetByCodePoints(12, 16)); //replace(int start, int end, String str) StringBuffer 此方法替换这个序列中的特定字符串的子字符串。 System.out.println(\"replace(int start, int end, String str):\" + sb1.replace(0, 5, \"Hello\")); //reverse() StringBuffer 将StringBuffer对象中的内容反转，然后形成新的字符串。 System.out.println(\"reverse():\" + sb1.reverse()); //setCharAt(int index, char ch) void 修改对象中索引值为index位置的字符为新的字符ch。 sb1.setCharAt(0, 'a'); System.out.println(\"setCharAt(int index, char ch):\" + sb1); //setLength(int newLength) void 设置字符串长度大小。 如果用小于当前字符串长度的值调用setlength()方法，则新长度后面的字符将丢失。 sb1.setLength(10); System.out.println(\"setLength(int newLength):\" + sb1.length()); //subSequence(int start, int end) CharSequence 返回一个新的字符序列，为这个序列的子序列 System.out.println(\"subSequence(int start, int end):\" + sb1.subSequence(0, 5)); //substring(int start) String 返回一个新的String，它包含的字符目前包含在此字符序列子序列 System.out.println(\"substring(int start):\" + sb1.substring(5)); //substring(int start, int end) String 返回一个新的String，它包含的字符目前包含在此字符序列子序列 System.out.println(\"substring(int start, int end):\" + sb1.substring(0, 5)); //toString() String 此方法返回表示此序列中数据的字符串。 System.out.println(\"toString():\" + sb1.toString()); //trimToSize() void 该方法的作用是将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费 sb1.trimToSize(); System.out.println(\"trimToSize():\" + sb1); } } 输出 append(boolean b):true append(char c):truea append(char[] str) :trueabcdef append(char[] str, int offset, int len) :trueabcdefdef append(CharSequence s):trueabcdefdefghijk append(CharSequence s, int start, int end):trueabcdefdefghijkijk append(double d):trueabcdefdefghijkijk11.2 append(float f):trueabcdefdefghijkijk11.211.3 append(int i):trueabcdefdefghijkijk11.211.312 append(long lng):trueabcdefdefghijkijk11.211.31211111111111 append(Object obj):trueabcdefdefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016 append(String str):trueabcdefdefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016Hello World append(StringBuffer sb):trueabcdefdefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016Hello WorldHello appendCodePoint(int codePoint):trueabcdefdefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016Hello WorldHelloa capacity():512 charAt(int index):a codePointAt(int index):97 codePointBefore(int index):97 codePointCount(int beginIndex,int endIndex):2 delete(int start, int end):abcdefdefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016Hello WorldHelloa deleteCharAt(int index):bcdefdefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016Hello WorldHelloa ensureCapacity(int minimumCapacity):1024 getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin):abcdbcdefjk indexOf(String str):65 indexOf(int ch, int fromIndex):76 insert(int offset, boolean b):true insert(int offset, char c):truea insert(int offset, char[] str):truebcdefa insert(int index, char[] str, int offset, int len):trueefbcdefa insert(int dstOffset, CharSequence s):trueghijkefbcdefa insert(int dstOffset, CharSequence s, int start, int end):trueijghijkefbcdefa insert(int offset, double d):true11.2ijghijkefbcdefa insert(int offset, float f):true11.311.2ijghijkefbcdefa insert(int offset, int i):true1311.311.2ijghijkefbcdefa insert(int offset, long l):true111111111111311.311.2ijghijkefbcdefa insert(int offset, Object obj):trueSat Apr 16 20:22:16 CST 2016111111111111311.311.2ijghijkefbcdefa insert(int offset, String str):trueHello WorldSat Apr 16 20:22:16 CST 2016111111111111311.311.2ijghijkefbcdefa lastIndexOf(String str):76 lastIndexOf(String str, int fromIndex):76 length():82 offsetByCodePoints(int index, int codePointOffset):28 replace(int start, int end, String str):Hellodefghijkijk11.211.31211111111111Sat Apr 16 20:22:16 CST 2016Hello WorldHelloa reverse():aolleHdlroW olleH6102 TSC 61:22:02 61 rpA taS11111111111213.112.11kjikjihgfedolleH setCharAt(int index, char ch):aolleHdlroW olleH6102 TSC 61:22:02 61 rpA taS11111111111213.112.11kjikjihgfedolleH setLength(int newLength):10 subSequence(int start, int end):aolle substring(int start):Hdlro substring(int start, int end):aolle toString():aolleHdlro trimToSize():aolleHdlro StringBuilder与StringBuffer的API相同 注意●String是不可变的对象 ●在switch语句中使用String作为case条件?从 JDK7 开始,这是可以的,啰嗦一句,Java 6 及以前的版本都不支持这样做. // 只在java 7及更高版本有效! switch (str.toLowerCase()) { case \"a\": value = 1; break; case \"b\": value = 2; break; } ●StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的 ●如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。 ●不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类 ●为了获得更好的性能，在构造 StirngBuffer 或 StirngBuilder 时应尽可能指定它们的容量 ●相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 参考资料JAVA字符串格式化-String.format()的使用Java：String、StringBuffer和StringBuilder的区别","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"}]},{"title":"设计模式之创建型模式","slug":"设计模式之创建型模式","date":"2016-04-10T13:00:00.000Z","updated":"2017-08-06T09:56:24.057Z","comments":true,"path":"2016/04/10/设计模式之创建型模式/","link":"","permalink":"https://luoweiguang.github.io/2016/04/10/设计模式之创建型模式/","excerpt":"简单工厂（Simple Factory）\n定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式\n\n一般性结构\n\n\n工厂角色:担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体的Java类实现\n抽象产品:担任这个角色的类是由工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现\n具体产品:工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。\n\n","text":"简单工厂（Simple Factory） 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式 一般性结构 工厂角色:担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体的Java类实现 抽象产品:担任这个角色的类是由工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现 具体产品:工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。 优点: 将创建对象与使用对象的职责分开 缺点: 因为工厂类集中了所有产品的创建逻辑，那么工厂类出现问题，会导致所有需要工厂类创建对象的调用都会出现问题。 由于使用静态方法，所以无法被子类继承 每次扩展产品类时，都必须对工厂方法进行修改 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心 例子: public class Factory { public static Product FactoryMethod(String str) { if (\"Apple\".equals(str)) { return new Aplle(); } else if (\"Pear\".equals(str)) { return new Pear(); } else { return null; } } } interface Product { void eat(); } class Aplle implements Product { public void eat() { System.out.println(\"吃苹果\"); } } class Pear implements Product { public void eat() { System.out.println(\"吃梨\"); } } class Test { public static void main(String[] args) { Product product = Factory.FactoryMethod(\"Apple\"); product.eat(); } } 工厂方法（Factory Method） 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 一般性结构 抽象工厂:担任这个角色的是工厂方法模式的核心，它是与应用程序无关的，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象Java类实现。 具体工厂:担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。 抽象产品:工厂方法模式所创建的对象的超类型，也就是产品对象的共有父类或共同拥有的接口。在实际的系统中。常常使用抽象Java类实现。 具体产品:这个角色实现了抽象产品角色所声明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。 优点: 将创建对象与使用对象的职责分开 无需修改客户端的逻辑代码就可以添加具体的产品 缺点: 每次扩展产品类时，都必须添加新的具体工厂类 增加了系统的抽象性与理解难度 适用场景 客户端不知道它所需要的对象的类 抽象工厂类通过其子类来指定创建哪个对象 例子 public class Test { private static FruitCreator mFruitCreator; public static void main(String[] args) { mFruitCreator = new AppleCreator(); mFruitCreator.factory().eat(); } } interface FruitCreator { public Fruit factory(); } interface Fruit { public void eat(); } class AppleCreator implements FruitCreator { @Override public Fruit factory() { return new Apple(); } } class PearCreator implements FruitCreator { @Override public Fruit factory() { return new Pear(); } } class Apple implements Fruit { @Override public void eat() { System.out.println(\"吃苹果\"); } } class Pear implements Fruit { @Override public void eat() { System.out.println(\"吃梨\"); } } 抽象工厂（Abstract Factory） 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式 一般性结构 抽象工厂:担任这个角色的是工厂方法模式的核心，它是与应用系统的商业逻辑无关的。通常使用Java接口或者抽象Java类实现，而所有的具体工厂类必须实现这个Java接口或继承这个抽象Java类 具体工厂:这个角色直接在客户端的调用下创建产品的实例的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。通常使用具体Java类实现这个角色。 抽象产品:担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。通常使用Java接口或抽象Java类实现。 具体产品:抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例，这个客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。通常使用具体Java类实现这个角色。 优点: 将创建对象与使用对象的职责分开 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无须修改已有系统，符合“开闭原则” 缺点: 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。 适用场景 客户端不知道它所需要的对象的类 系统中有多于一个的产品族，而每次只使用其中某一产品族 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 例子: public class Test { public static void main(String[] args) { SkinFactory mSkinFactory= new RedSkinFactory(); mSkinFactory.createButton().paint(); mSkinFactory.createTextView().paint(); } } interface SkinFactory { public Button createButton(); public TextView createTextView(); } class RedSkinFactory implements SkinFactory { @Override public Button createButton() { return new RedButton(); } @Override public TextView createTextView() { return new RedTextView(); } } class GreenSkinFactory implements SkinFactory { @Override public Button createButton() { return new GreenButton(); } @Override public TextView createTextView() { return new GreenTextView(); } } interface Button { public void paint(); } interface TextView { public void paint(); } class RedButton implements Button { @Override public void paint() { System.out.println(\"画一个红色按钮\"); } } class GreenButton implements Button { @Override public void paint() { System.out.println(\"画一个绿色按钮\"); } } class RedTextView implements TextView { @Override public void paint() { System.out.println(\"画一个红色文本\"); } } class GreenTextView implements TextView { @Override public void paint() { System.out.println(\"画一个绿色文本\"); } } 单例（Singleton） 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 优点: 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题 缺点: 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失 适用场景 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例 例子: 饿汉式单例 class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton(){} public static EagerSingleton getInstance() { return instance; } } 懒汉式单例(DCL方式) class LazySingleton { //没有volatile修饰符，可能出现Java中的另一个线程看到个初始化了一半的LazySingleton的情况 private volatile static LazySingleton instance = null; private LazySingleton() { } public static LazySingleton getInstance() { //第一重判断 if (instance == null) { //锁定代码块 synchronized (LazySingleton.class) { //第二重判断 if (instance == null) { instance = new LazySingleton(); //创建单例实例 } } } return instance; } } 登记式单例 class RegSingleton { static private HashMap&lt;String, RegSingleton> mRegistry = new HashMap&lt;String, RegSingleton>(); static { RegSingleton x = new RegSingleton(); mRegistry.put(x.getClass().getName(), x); } protected RegSingleton(){}; static public RegSingleton getInstance(String name) { if(name == null) { name = \"com.singleton.RegSingleton\";//即包名 } if(mRegistry.get(name) == null) { try { mRegistry.put(name, (RegSingleton) Class.forName(name).newInstance()); } catch (Exception e) { System.out.println(\"Error\"); } } return mRegistry.get(name); } } class RegSingletonChild extends RegSingleton { public RegSingletonChild(){} static public RegSingletonChild getInstance() { return (RegSingletonChild) RegSingletonChild.getInstance(\"com.singleton.RegSingletonChild\"); } } IoDH单例 //IoDH，即使用内部类(与编程语言本身的特性相关，很多面向对象语言不支持IoDH) class Singleton { private Singleton() { } private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } } 原型（Prototype）使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 简单形式的原始模型的一般性结构 抽象原型:它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。 具体原型:它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象 客户:：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 登记形式的原始模型的一般性结构 客户:客户端类向管理员提出创建对象的请求 抽象原型:这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体原型类所需的接口 具体原型:被复制的对象。需要实现抽象的原型角色所要求的接口 原型管理器:创建具体原型类的对象，并记录每一个被创建的对象，优点 当创建新的对象实例比较复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类登记结构相同的工厂等级结构，而原型模式就不要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品 可以使用深克隆的方法保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。 缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，但对已有的类进行改造时，需要修改源代码，违背”开闭原则” 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 适应场景 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 简单形式的例子 public class Client { private Prototype prototype; public void operation(Prototype example) { Prototype p = example.clone(); } } interface Prototype extends Cloneable { Prototype clone(); } class ConcretePrototype implements Prototype { public Prototype clone() { try { return (Prototype) super.clone(); } catch (CloneNotSupportedException e) { return null; } } } 登记形式的例子 import java.util.Vector; public class Client { private PrototypeManager pm; private Prototype prototype; public void registerPrototype() { prototype = new ConcretePrototype(); Prototype copytype = (Prototype) prototype.clone(); pm.add(copytype); } } interface Prototype extends Cloneable { public Object clone(); } class ConcretePrototype implements Prototype { public synchronized Object clone() { Prototype temp = null; try { temp = (Prototype) super.clone(); return temp; } catch (CloneNotSupportedException e) { System.out.println(\"Clone failed\"); } finally { return temp; } } } class PrototypeManager { private Vector&lt;Prototype> objects = new Vector&lt;Prototype>(); public void add(Prototype object) { objects.add(object); } public Prototype get(int i) { return objects.get(i); } public int getSize() { return objects.size(); } } 建造者（Builder） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 一般性结构 Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 优点: 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则” 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 缺点: 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。 适用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 例子: public class Test { public static void main(String[] args) { Director director = new Director(new MacbookBuilder()); Computer computer = director.construct(\"英特尔主板\", \"Retina显示器\"); } } abstract class Computer { protected String mBoard; protected String mDisplay; protected String mOS; protected Computer() {} public void setBoard(String board) { mBoard = board; } public void setDisplay(String display) { mDisplay = display; } public void setOS(String OS) { mOS = OS; } } class Macbook extends Computer { protected Macbook(){} } class Lenovo extends Computer { protected Lenovo(){} } abstract class Builder { public abstract void buildBoard(String board); public abstract void buildDisplay(String display); public abstract void buildOS(); public abstract Computer create(); } class MacbookBuilder extends Builder { private static final String MACOSX = \"Mac OS X 10.10\"; private Computer mComputer = new Macbook(); @Override public void buildBoard(String board) { mComputer.setBoard(board); } @Override public void buildDisplay(String display) { mComputer.setDisplay(display); } @Override public void buildOS() { mComputer.setOS(MACOSX); } @Override public Computer create() { return mComputer; } } class LenovoBuilder extends Builder { private static final String WINDOWS = \"Windows 10\"; private Computer mComputer = new Macbook(); @Override public void buildBoard(String board) { mComputer.setBoard(board); } @Override public void buildDisplay(String display) { mComputer.setDisplay(display); } @Override public void buildOS() { mComputer.setOS(WINDOWS); } @Override public Computer create() { return mComputer; } } class Director { Builder mBuilder = null; public Director(Builder builder) { mBuilder = builder; } public Computer construct(String board,String display) { mBuilder.buildBoard(board); mBuilder.buildDisplay(display); mBuilder.buildOS(); return mBuilder.create(); } } 省略指挥者与抽象建造者 public class Test { public static void main(String[] args) { NutritionFacts.Builder builder = new NutritionFacts.Builder(1, 1); NutritionFacts nutritionFacts = builder.calories(1).fat(1).build(); } } class NutritionFacts { private final int servngSize; private final int servings; private final int calories; private final int fat; private final int sodiun; private final int carbohydrate; public static class Builder { private final int servingSize; private final int servings; private int calories = 0; private int fat = 0; private int carbohydrate = 0; private int sodium = 0; public Builder(int servingSize,int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this; } public Builder fat(int val) { fat = val; return this; } public Builder carbohydrate(int val) { carbohydrate = val; return this; } public Builder sodium(int val) { sodium = val; return this; } public NutritionFacts build() { return new NutritionFacts(this); } } private NutritionFacts(Builder builder) { servngSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodiun = builder.sodium; carbohydrate = builder.carbohydrate; } }","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://luoweiguang.github.io/categories/设计模式/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://luoweiguang.github.io/tags/总结/"},{"name":"设计模式","slug":"设计模式","permalink":"https://luoweiguang.github.io/tags/设计模式/"}]},{"title":"Effective Java","slug":"Effective Java","date":"2016-04-08T14:00:00.000Z","updated":"2017-08-06T10:00:10.882Z","comments":true,"path":"2016/04/08/Effective Java/","link":"","permalink":"https://luoweiguang.github.io/2016/04/08/Effective Java/","excerpt":"1. 考虑用静态工厂方法代替构造器优点：\n\n拥有名称，更容易识别\n不必每次调用时，都创建一个新的对象\n可以返回返回类型的任何子类型对象\n使代码更简洁\n\n缺点：\n\n类如果不含共有的或者受保护的构造器，就不能被子类化。\n它们与其他的静态方法实际上没有任何区别。\n\n应用：\n\n服务提供者框架\n","text":"1. 考虑用静态工厂方法代替构造器优点： 拥有名称，更容易识别 不必每次调用时，都创建一个新的对象 可以返回返回类型的任何子类型对象 使代码更简洁 缺点： 类如果不含共有的或者受保护的构造器，就不能被子类化。 它们与其他的静态方法实际上没有任何区别。 应用： 服务提供者框架 2. 遇到多个构造器参数时要考虑用构建器 当有很多参数的时候，重叠构造器模式可行，客户端代码会很难编写，并且仍然较难以阅读 使用javabeans模式，在构造过程中JavaBean可能处于不一定的状态 使用Builder 模式的客户端代码将更易于阅读与编写，构建器也比JavaBeans更加安全。 3. 用私有构造器或者枚举类型强化Singleton属性 使类成为Singleton会是它的客户端测试变得十分困难，因为无法给Singleton替换模拟实现，除非它实现一个充当其类型的接口。 序列化Singleton类使用implement Serializable是不够的，为了维护并保证Singleton，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法，否则每次反序列化一个序列化的实例时，都会创建一个新的实例。 单元素的枚举类型已经成为Singleton的最佳方法例子： public enum Elvis { INSTANCE; public void leaveTheBuilding(){}; } 4. 通过私有构造器强化不可实例化的能力 导致一个类不能被子类化。所有的构造器都必须显示或隐式的调用超类的构造器。如此一来子类就没有可访问的超类构造器可用了 5. 避免创建不必要的对象 使用静态工厂方法而不是构造器，以避免创建不必要的对象 要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。 6. 消除过期的对象引用 只要类是自己管理内存，就应该警惕内存泄露问题 内存泄露的另一个常见来源是缓存 内存泄露的第三个常见来源是监听器和其他回调 7. 避免使用终结方法 不应该依赖终结方法来更新重要的持久状态 使用终结方法有一个非常严重的性能损失 如果终结方法发现资源还未被终止，则应该在日志中记录一条警告 如果类有终结方法，并且子类覆盖了终结方法，子类的终结方法就必须手工调用超类的终结方法，应该在try块中终结子类，并在相应的finally块中调用超类的终结方法 8. 覆盖equals时请遵守通用约定 类的每个实例本质上都是唯一的 不关心类是否提供了”逻辑相等”的测试功能 超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的 类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用 equals方法实现了等价关系 自反性。对于任何非null的引用值x,x.equals(x)必须返回true 对称性。对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true. 传递性。对于任何非null的引用值x、y和z,如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。 一致性。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致的返回false。 非空性。对于任何非null的引用值x，x.equals(null)必须返回false。 无法在扩展可实例化的类的同时，即增加新的组件，同时又保留equals约定 实现高质量equals方法的诀窍 使用==操作符检查”参数是否为这个对象的引用” 使用instanceof操作符检查”参数是否为正确的类型” 把参数转换成正确的类型 对于该类中的每个”关键””域，检查参数中的域是否与该对象中对应的域相匹配 当编写完equals方法之后，应该问自己三个问题，它是否是对称的，传递的，一致的？ 告诫： 覆盖equals时总要覆盖hashCode。 不要企图让equals方法过于智能 不要将equals声明中的Object对象替换为其他的类型 9. 覆盖equals时总要覆盖hashCode 相等的对象必须具有相等的散列码 不要试图从散列码计算中排除掉一个对象的关键部分来提高性能 10. 始终覆盖toString toString()方法应该返回对象中包含的所有值得关注的信息 11. 谨慎的覆盖clone 永远不要让客户去做类库能够替客户完成的事情 必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件 12. 考虑实现Comparable接口 13. 使类和成员的可访问性最小化 尽可能地使每个类或者成员不被外界访问 14. 在公有类中使用访问方法而非公有域 如果类可以在它所在的包的外部进行访问，就提供访问方法。 15. 使可变性最小化 使类成为不可变，要遵循下面五条规则 不要提供改变对象属性的方法 保证类不会被扩展 使所有的域都是final的 使所有的域都成为私有的 确保对于任何可变组件的互斥访问 优点 不可变对象比较简单 不可变对象本质上是线程安全的，它们不要求同步 不可变对象可以被自由地共享 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。 不可变对象为其他对象提供了大量的构件 缺点 对于每个不同的值都需要一个单独的对象、 16. 复合优先于继承 17. 要么为继承而设计，并提供文档说明，要么就禁止继承 构造器决不能调用可被覆盖的方法 18. 接口优于抽象类 现有的类可以很容易被更新，以实现新的接口 接口是定义混合类型的理想选择 接口允许我们构造非层次结构的类型框架 接口使得安全的增强类的功能成为可能 抽象类的演变比接口的演变要容易的多 接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的 19. 接口只用于定义类型 20. 类层次优于标签类 标签类过于冗长、容易出错、并且效率低下 21. 用函数对象表示策略 22. 优先考虑静态成员类 23. 请不要在新代码中使用原生态类型 如果使用原生态类型。就失掉了泛型在安全性和表述性方面的所有优势 如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List这样的参数化类型，则不会 24. 消除非受检警告 要尽可能地消除每一个非受检警告 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下才）可以用一个人@SuppressWarnings(“unchecked”)注解来禁止这条警告 应该始终在尽可能小的范围中使用@SuppressWarnings注解 每当使用SuppressWarnings(“unchecked”)注解时，都要添加一条注释，说明为什么这么做是安全的 25. 列表优先于数组 数组是协变的（convariant）。相反泛型则是不可变的（invariant）。即如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型； 数组是具体化的（reified）。因此数组会在运行时才知道并检查他们的元素类型约束。泛型是通过擦除来实现的。因此泛型只在编译时强化他们的类型信息，并在运行时丢弃（或者擦除）他们元素的类型信息。 创建泛型数组是非法的： 26. 优先考虑泛型 使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。 再设计新类型的时候，要确保他们不需要这种转换就可以使用 27. 优先考虑泛型方法 28. 利用有限制通配符来提升API的灵活性 为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。 如果参数化类型表示一个T生产者，就使用《？ extends T&gt;,如果它表示一个T消费者，就使用&lt;? super T&gt; 不要使用通配符类型作为返回类型 29. 优先考虑类型安全的异构容器 30. 用enum代替int常量 枚举提供了编译时的类型安全。 31. 用实例域代替序数 永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中 32. 用EnumSet代替位域 33. 用EnumMap代替序数索引 34. 用接口模拟可伸缩的枚举 35. 注解优先于命名模式 命名模式的缺点： 无法处理命名失误的情况。 无法确保它们只用于响应的程序元素上 他们没有提供将参数值与程序元素关联起来的好方法。 36. 坚持使用Override注解 37. 用标记接口定义类型 标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型 使用标记接口的方法能够更加精确的对实现它的类型进行锁定。 标记注解胜过标记结构的最大优点在于，他可以通过默认的方式添加一个或多个注解类型元素，给已被使用的注解类型添加更多的信息 38. 检查参数的有效性 39. 必要时进行保护性拷贝 假设类的客户端会尽其所能来破坏这个类的约束条件，因此你必须保护性地设计程序 保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象 对于参数类型可以被不信任方子类化的参数，请不要使用clone方法进行保护性拷贝 40. 谨慎设计方法签名 谨慎的选择方法的名称 不要过于追求提供便利的方法 避免过长的参数列表 分解成多个方法 创建辅助类 对于参数类型，要优先使用接口而不是类 对于boolean参数，要优先使用两个元素的枚举类型 41. 慎用重载 永远不要导出两个具有相同参数数目的重载方法。 必须要保证当传递同样当参数时，所有的重载方法的行为必须一致。 42. 慎用可变参数 不必改造具有final数组参数的每个方法，只当确定是在数量不定的值上执行调用时才使用可变参数 43. 返回零长度的数组或者集合，而不是null 44. 为所有导出的API元素编写文档注释 45. 将局部变量的作用域最小化 要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明 几乎每个局部变量的声明都应该包含一个初始化表达式 46. for-each循环优先于传统的for循环 三种常见的情况无法使用for-each循环 过滤–如果需要遍历集合，并删除选定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法。 转换–如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值 平行迭代–如果需要并行地遍历多个集合，就需要显示地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移 47. 了解和使用类库 48. 如果需要精确的答案，请避免使用float和double 49. 基本类型优先于装箱基本类型 对装箱基本类型运行==操作符几乎总是错误的 当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱 自动装箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险 基本类型和装箱基本类型有三个主要区别： 基本类型只有值，装箱基本类型则具有与它们的值不同的同一性。 基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有个非功能值null 基本类型通常比装箱基本类型更节省时间和空间。 什么时候应该使用装箱基本类型： 作为集合中的元素，键和值 在参数化类型中，必须使用装箱基本类型作为类型参数 反射的方法调用时，必须使用装箱基本类型 50. 如果其他类型更适合，则尽量避免使用字符串 字符串不适合代替其他的值类型 字符串不适合代替枚举类型 字符串不适合代替聚集类型 字符串不适合代替能力表 51. 当心字符串连接的性能 为连接n个字符串而重复第使用字符串连接操作符，需要n的平方级的时间。 52. 通过接口引用对象 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明 53. 接口优先于反射机制 反射机制的缺点： 丧失了编译时类型检查的好处 执行反射访问所需要的代码非常笨拙与冗长 性能损失 54. 谨慎地使用本地方法 使用本地方法来提高性能的做法不值得提倡 本地方法的三种用途： 它们提供了“访问特定于平台的机制”的能力 提供了访问遗留代码库的能力，从而访问遗留数据。 可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能。 55. 谨慎地进行优化 要努力编写好的程序而不是快的程序 努力避免那些限制性能的设计决策 要考虑API设计决策的性能后果 在每次试图做优化之前和之后，要对性能进行测量 56. 遵守普遍接受的命名惯例 57. 只针对异常的情况才使用异常 58. 对可恢复的情况使用受检异常，对编程错误使用运行时异常 如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常 用运行时异常来表面编程错误 实现的所有未受检的抛出结构都应该是RuntimeExecption的子类 59. 避免不必要地使用受检的异常 60. 优先使用标准的异常 61. 抛出与抽象相对应的异常 更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法称为异常转译 尽管异常转译与不加选择的从低层传递异常的做法相比有所改进，但是它也不能被滥用 62. 每个方法抛出的异常都要有文档 始终要单独地声明受检的异常，并且利用Javadoc的@throws标记，准确地记录下抛出每个异常的条件 63. 在细节消息中包含能捕获失败的而信息 异常的toString方法应该尽可能多地返回有关失败原因的信息 为了捕获失败，异常的细节消息应该包含所有“对该异常有贡献”的参数和域的值 64. 努力使失败保持原子性 65. 不要忽略异常 空的catch块会使异常达不到应有的目的，至少应当包含一条说明，解释为什么可以忽略这个异常 66. 同步访问共享的可变数据 为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的 如果读和写操作没有都被同步，同步就不会起作用 将可变数据限制在单个线程中 67. 避免过度同步 68. executor和task优先于线程 69. 并发工具优先于wait和notify 70. 线程安全性的文档化 71. 慎用延迟初始化 72. 不要依赖于线程调度器 73. 避免使用线程组 74. 谨慎地实现Serializable接口 为了继承而设计的类应该尽可能少的实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口 对于为继承而设计的不可序列化的类，你应该考虑提供一个无参构造器 序列化的缺点： 一旦一个类被发布，就大大降低了”改变这个类的实现”的灵活性 它增加了出现Bug和安全漏洞的可能性 随着类发行新的版本，相关的测试负担也增加了 75. 考虑使用自定义的序列化形式 76. 保护性地编写readObject方法 77. 对于实例控制，枚举类型优先于readResolve 78. 考虑用序列化代理代替序列化实例","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoweiguang.github.io/tags/读书笔记/"}]},{"title":"线程池简介","slug":"线程池简介","date":"2016-03-26T07:00:00.000Z","updated":"2017-08-06T10:02:58.761Z","comments":true,"path":"2016/03/26/线程池简介/","link":"","permalink":"https://luoweiguang.github.io/2016/03/26/线程池简介/","excerpt":"一个线程的生命周期由三方面组成\n\n创建线程的时间\n线程执行的时间\n执行销毁的时间\n\n那么只要这三方面中的某一个所需的时间减少，就能够提高程序的性能而线程池技术就是缩短创建与销毁线程的时间。","text":"一个线程的生命周期由三方面组成 创建线程的时间 线程执行的时间 执行销毁的时间 那么只要这三方面中的某一个所需的时间减少，就能够提高程序的性能而线程池技术就是缩短创建与销毁线程的时间。 线程池由至少四部分组成 线程池管理器：用于创建并管理线程池 工作线程：线程池中的线程 任务接口：每个任务必须实现的而接口，以供工作线程调度任务的执行 任务队列：用于存放没有处理的任务。提供一种缓冲机制 简单线程池的实现import java.util.Date; import java.util.List; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class Test { public static void main(String[] args) { ThreadPool t = ThreadPool.getThreadPool(3); t.execute(new Task[] { new TestTask(), new TestTask(), new TestTask() }); System.out.println(t); t.execute(new Task[] { new TestTask(), new TestTask(), new TestTask() }); System.out.println(t); t.destroy();// 所有线程都执行完成才destory System.out.println(t); } static class TestTask extends Task { @Override public void run() { try { Thread.sleep((long)(Math.random()*100)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程编号\"+this.getTaskId()+\"线程产生时间：\"+this.getGenerateTime().getTime()+\"线程提交到任务队列时间：\"+this.getSubmitTime().getTime()+\"线程从任务队列移除的时间:\"+this.getRemoveFinishTime().getTime()+\"线程开始执行时间：\"+this.getBeginExceuteTime().getTime()); } } } final class ThreadPool { // 线程池中线程的默认数 private static int worker_num = 5; // 工作线程 private WorkThread[] workThreads; // 未处理的任务 private static volatile int removefinished_task = 0; private static volatile int taskID = 0; // 任务队列 private BlockingQueue&lt;Task> taskQueue = new LinkedBlockingQueue&lt;Task>(); private static ThreadPool threadPool; // 创建具有默认线程个数的线程池 private ThreadPool() { this(worker_num); } // 创建线程池,worker_num为线程池中工作线程的个数 private ThreadPool(int worker_num) { ThreadPool.worker_num = worker_num; workThreads = new WorkThread[worker_num]; for (int i = 0; i &lt; worker_num; i++) { workThreads[i] = new WorkThread(); workThreads[i].start();// 开启线程池中的线程 } } // 单态模式，获得一个默认线程个数的线程池 public static ThreadPool getThreadPool() { return getThreadPool(ThreadPool.worker_num); } // 单态模式，获得一个指定线程个数的线程池,worker_num(>0)为线程池中工作线程的个数 // worker_num&lt;=0创建默认的工作线程个数 public static ThreadPool getThreadPool(int worker_num) { if (worker_num &lt;= 0) { worker_num = ThreadPool.worker_num; } if (threadPool == null) { threadPool = new ThreadPool(worker_num); } return threadPool; } // 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定 public void execute(Task task) { synchronized (taskQueue) { task.setTaskId(taskID++); task.setSubmitTime(new Date()); taskQueue.add(task); taskQueue.notify(); } } // 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定 public void execute(Task[] task) { synchronized (taskQueue) { for (Task t : task) { t.setTaskId(taskID++); t.setSubmitTime(new Date()); taskQueue.add(t); } taskQueue.notify(); } } // 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定 public void execute(List&lt;Task> task) { synchronized (taskQueue) { for (Task t : task) { t.setTaskId(taskID++); t.setSubmitTime(new Date()); taskQueue.add(t); } taskQueue.notify(); } } // 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁 public void destroy() { while (!taskQueue.isEmpty())// 如果还有任务没执行完成，就先睡会吧 { try { Thread.sleep(10); } catch (Exception e) { e.printStackTrace(); } } // 工作线程停止工作，且置为null for (int i = 0; i &lt; worker_num; i++) { workThreads[i].stopWorker(); workThreads[i] = null; } threadPool = null; taskQueue.clear();// 清空任务队列 } // 返回工作线程的个数 public int getWorkThreadNumber() { return worker_num; } // 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成 public int getFinishedTasknumber() { return removefinished_task; } // 返回任务队列的长度，即还没处理的任务个数 public int getWaitTasknumber() { return taskQueue.size(); } public String toString() { return \"WorkThread number:\" + worker_num + \" finished task number:\" + removefinished_task + \" wait task number:\" + getWaitTasknumber(); } /** * 内部类，工作线程 */ private class WorkThread extends Thread { // 该工作线程是否有效，用于结束该工作线程 private boolean isRunning = true; /* * 关键所在啊，如果任务队列不空，则取出任务执行，若任务队列空，则等待 */ @Override public void run() { Task r = null; while (isRunning)// 注意，若线程无效则自然结束run方法，该线程就没用了 { synchronized (taskQueue) { while (isRunning &amp;&amp; taskQueue.isEmpty())// 队列为空 { try { taskQueue.wait(20); } catch (Exception e) { e.printStackTrace(); } } if (!taskQueue.isEmpty()) { removefinished_task++; r = taskQueue.remove();// 取出任务 r.setRemoveFinishTime(new Date()); } } if (r != null) { r.setBeginExceuteTime(new Date()); r.run();// 执行任务 } r = null; } } // 停止工作，让该线程自然执行完run方法，自然结束 public void stopWorker() { isRunning = false; } } } /** * 所有任务接口 其他任务必须继承访类 * * @author obullxl */ abstract class Task implements Runnable { /* 产生时间 */ private Date generateTime = null; /* 提交执行时间 */ private Date submitTime = null; /* 开始执行时间 */ private Date beginExceuteTime = null; /* 出任务队列的时间 */ private Date removeFinishTime = null; private long taskId; public Task() { this.generateTime = new Date(); } /** * 任务执行入口 */ abstract public void run(); public Date getGenerateTime() { return generateTime; } public Date getBeginExceuteTime() { return beginExceuteTime; } public void setBeginExceuteTime(Date beginExceuteTime) { this.beginExceuteTime = beginExceuteTime; } public Date getRemoveFinishTime() { return removeFinishTime; } public void setRemoveFinishTime(Date finishTime) { this.removeFinishTime = finishTime; } public Date getSubmitTime() { return submitTime; } public void setSubmitTime(Date submitTime) { this.submitTime = submitTime; } public long getTaskId() { return taskId; } public void setTaskId(long taskId) { this.taskId = taskId; } } Java中的线程池Java中的几种线程池最终都会调用此方法。 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程； keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性： TimeUnit.DAYS; //天 TimeUnit.HOURS; //小时 TimeUnit.MINUTES; //分钟 TimeUnit.SECONDS; //秒 TimeUnit.MILLISECONDS; //毫秒 TimeUnit.MICROSECONDS; //微妙 TimeUnit.NANOSECONDS; //纳秒 workQueue：线程池所使用的缓冲队列，该缓冲队列的长度决定了能够缓冲的最大数量，缓冲队列有三种通用策略： 直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性; 无界队列。使用无界队列（例如，不具有预定义容量的LinkedBlockingQueue）将导致在所有 corePoolSize线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性; 有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量. threadFactory：线程工厂，主要用来创建线程； handler：表示当拒绝处理任务时的策略，有以下四种取值： ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 corePoolSize与maximumPoolSize由于ThreadPoolExecutor 将根据 corePoolSize和 maximumPoolSize设置的边界自动调整池大小，当新任务在方法 execute(java.lang.Runnable) 中提交时： 1. 如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的； 2. 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池是大小固定的，如果运行的线程与corePoolSize相同，当有新请求过来时，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理 3. 如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新的线程去处理请求； 4. 如果运行的线程多于corePoolSize 并且等于maximumPoolSize，若队列已经满了，则通过handler所指定的策略来处理新请求； 5. 如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务 也就是说，处理任务的优先级为： - 核心线程corePoolSize &gt; 任务队列workQueue &gt; 最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 - 当池中的线程数大于corePoolSize的时候，多余的线程会等待keepAliveTime长的时间，如果无请求可处理就自行销毁。 newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable>()); } 参数类型 参数名 参数值 int corePoolSize 0 int maximumPoolSize Integer.MAX_VALUE long keepAliveTime 60L TimeUnit unit TimeUnit.SECONDS BlockingQueue workQueue new SynchronousQueue() ThreadFactory threadFactory Executors.defaultThreadFactory() RejectedExecutionHandler handler defaultHandler newFixedThreadPool(int nThreads) 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>()); } 参数类型 参数名 参数值 int corePoolSize nThreads int maximumPoolSize nThreads long keepAliveTime 0L TimeUnit unit TimeUnit.MILLISECONDS BlockingQueue workQueue new LinkedBlockingQueue() ThreadFactory threadFactory Executors.defaultThreadFactory() RejectedExecutionHandler handler defaultHandler newScheduledThreadPool(int corePoolSize) 创建一个定长线程池，支持定时及周期性任务执行。``` javapublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize){ return new ScheduledThreadPoolExecutor(corePoolSize);} public class ScheduledThreadPoolExecutorextends ThreadPoolExecutorimplements ScheduledExecutorService{ public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,new DelayedWorkQueue()); }} |参数类型|参数名|参数值| |:---:|:----:|:---:| |int|corePoolSize|corePoolSize| |int|maximumPoolSize|Integer.MAX_VALUE| |long|keepAliveTime|0| |TimeUnit|unit|NANOSECONDS| |BlockingQueue&lt;Runnable&gt;|workQueue|new DelayedWorkQueue()| |ThreadFactory|threadFactory| Executors.defaultThreadFactory()| |RejectedExecutionHandler|handler|defaultHandler| **newSingleThreadExecutor()** &gt; 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 ``` java public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } 参数类型 参数名 参数值 int corePoolSize 1 int maximumPoolSize 1 long keepAliveTime 0 TimeUnit unit TimeUnit.MILLISECONDS BlockingQueue workQueue new LinkedBlockingQueue() ThreadFactory threadFactory Executors.defaultThreadFactory() RejectedExecutionHandler handler defaultHandler ※defaultHandler即AbortPolicy※threadFactory也可以自定义，以下是默认线程工厂的源码： static class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; } // 为线程池创建新的任务执行线程 public Thread newThread(Runnable r) { // 线程对应的任务是Runnable对象r Thread t = new Thread(group, r,namePrefix + threadNumber.getAndIncrement(), 0); // 设为非守护线程 if (t.isDaemon()) t.setDaemon(false); // 将优先级设为Thread.NORM_PRIORITY if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; } } 参考资料线程池的实现原理Java并发编程：线程池的使用Java 7之多线程线程池 - 线程池原理(1)","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"}]},{"title":"Eclipse的使用","slug":"Eclipse的使用","date":"2016-03-21T12:00:00.000Z","updated":"2017-08-06T10:04:53.007Z","comments":true,"path":"2016/03/21/Eclipse的使用/","link":"","permalink":"https://luoweiguang.github.io/2016/03/21/Eclipse的使用/","excerpt":"常用\nCtrl + Shift + F        格式排版 \nCtrl + 1                快速修正\nCtrl + /                注释\nCtrl + Shift + /        添加块注释\nCtrl + Shift + \\        除去块注释\nCtrl + Shift + Space    方法参数提示\nCtril + F6              页面切换\nCtrl + Shift + O        去掉没用到的包\nF2                      显示提示\nF4                      打开元素继承列表\nCtrl + 鼠标点击         查看源码\nCtrl + Z                撤销\nCtrl + Y                重做\n","text":"常用 Ctrl + Shift + F 格式排版 Ctrl + 1 快速修正 Ctrl + / 注释 Ctrl + Shift + / 添加块注释 Ctrl + Shift + \\ 除去块注释 Ctrl + Shift + Space 方法参数提示 Ctril + F6 页面切换 Ctrl + Shift + O 去掉没用到的包 F2 显示提示 F4 打开元素继承列表 Ctrl + 鼠标点击 查看源码 Ctrl + Z 撤销 Ctrl + Y 重做 跳转查询 Ctrl + T 列出接口的实现类列表或继承的父类 F3 查看源码 Ctrl + O 查看当前文件的结构 Ctrl + Q 回到最后一次编辑的地方 Ctrl + Alt + H 打开调用层次结构 Ctrl + Shift + R 打开资源 Ctrl + Shift + T 打开类型 搜索 Ctrl + H 打开搜索对话框 Ctrl + F 打开文本搜索对话框 Ctrl + G 在workspace中搜索选中元素的声明 Ctrl + Alt + G 在workspace中搜索选中的文本 Ctrl + Shift + G 在workspace中搜索选中元素的引用 编辑页面操作 Ctrl + W 关闭当前页面 Ctrl + E 查看所有页面目录 Alt + ← 前一个编辑的页面 Alt + → 后一个编辑的页面 Ctrl + ↑ 上滚行 Ctrl + ↓ 下滚行 Ctrl + Shift + - 双编辑窗口 文本操作 Ctrl + D 删除行: Tab 把当前选中的文本向右推进 Shift + Tab 把当前选中的文本向左缩进 Ctrl + Shift + Y 把当前选中的文本全部变为小写 Ctrl + Shift + X 把当前选中的文本全部变为大写 Alt + ↑ 将行上移 Alt + ↓ 将行下移 Ctrl + Shift + Enter 在当前行上插入一行 Shift + Enter 在当前行下插入一行 重构 Alt + Shift + T 打开重构菜单 Alt + Shift + R 重命名 Alt + Shift + M 选中内容生成一个方法 Alt + Shift + V 移动 Alt + Shift + C 改变方法参数 Alt + Shift + L 抽取本地变量 调试 F5 单步跳入 F6 单步跳过 F7 单步返回 F8 继续 Ctrl + Shift + D 显示变量的值 Ctrl + Shift + B 在当前行设置或者去掉断点 Ctrl + R 运行至行 设置字体与字体大小Window -&gt; Preferences -&gt; General -&gt; Appearance -&gt; Colors and Fonts右边Basic中的TextFont，再点击Edit进行修改 java智能提示 Window -&gt; Preferences Java －&gt; Editor －&gt; Content Assist 右侧的”Auto-Activation”找到”Auto Activation triggers for java”选项 填入会提示的字符，如”.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ” XML智能提示 Window -&gt; Preferences XML －&gt; XML Files -&gt; Editor －&gt; Content Assist 右侧的”Auto-Activation”找到”Prompt when these characters are inserted “选项 填入会提示的字符，如”&lt;=:.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ” 设置默认编码 Window -&gt; Preferences -&gt; General -&gt; Workspace 面板Text file encoding 设置代码风格 Window -&gt; Preferences Java -&gt; Code Style -&gt; Formatter 点击面板的Edit 在Profile name:中输入一个名称 在下面的设置中设置属性，如果是设置换行，点击Braces设置，完成后点击OK 安装主题（Color Theme） Help-&gt;Install New Software 在Work with中输入http://eclipse-color-theme.github.io/update/ 下方会出现Eclipse Color Theme,在项目前点勾 点击Next &gt;,再点Next &gt; 选择I accept the terms of the license agreements 点击Finish 导入JavaDOC与源码 Window -&gt; Preferences Java -&gt; Installed JREs 选中使用的Jre包，点击Edit Ctrl + A 全选中Jre包 点击Source Attachment.. 点击External location,点击External File 选择Jdk文件夹下的src.zip文件 点击打开，点击OK","raw":null,"content":null,"categories":[{"name":"Tool","slug":"Tool","permalink":"https://luoweiguang.github.io/categories/Tool/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://luoweiguang.github.io/tags/Tool/"}]},{"title":"UML之类图","slug":"UML之类图","date":"2016-03-19T09:00:00.000Z","updated":"2017-08-06T10:08:35.683Z","comments":true,"path":"2016/03/19/UML之类图/","link":"","permalink":"https://luoweiguang.github.io/2016/03/19/UML之类图/","excerpt":"摘自学习UML实现、泛化、依赖、关联、聚合、组合\n实现(Realization):指的是一个类实现接口（可以是多个）的功能；实现是类与接口之间最常见的关系；","text":"摘自学习UML实现、泛化、依赖、关联、聚合、组合 实现(Realization):指的是一个类实现接口（可以是多个）的功能；实现是类与接口之间最常见的关系； 泛化(Generalization):表现为继承或实现关系(is a)。具体形式为类与类之间的继承 关系，接口与接口之间的继承关系，类对接口的实现关系 依赖 (Dependency):表现为函数中的参数(use a)。是类与类之间的连接，表示一个类依赖于另一个类的定义，其中一个类的变化将影响另外一个类。例如如果A依赖于B，则B体现为局部变量，方法的参数、或静态方法的调用。常见的依赖关系如下： 类B以参数的形式传入类A的方法。 类B以局部变量的形式存在于类A的方法中。 类A调用类B的静态方法。 关联（Association）:表现为变量(has a )。类与类之间的联接，它使一个类知道另一个类的属性和方法。例如如果A依赖于B，则B体现为A的成员变量。关联关系有双向关联和单向关联。双向关联：两个类都知道另一个类的公共属性和操作。单向关联：只有一个类知道另外一个类的公共属性和操作。大多数关联应该是单向的，单向关系更容易建立和维护，有助于寻找可服用的类。 聚合(Aggregat ion):是关联关系的一种，是强的关联关系。聚合关系是整体和个体的关系。普通关联关系的两个类处于同一层次上，而聚合关系的两个类处于不同的层次，一个是整体，一个是部分。同时，是一种弱的“拥有”关系。此时整体与部分之间是可分离的，他们可以具有各自的生命周期， 部分可以属于多个整体对象，也可以为多个整体对象共享； 组合(Composition):是关联关系的一种，是比聚合关系强的关联关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。Composition(组合关系)是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一致。他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；","raw":null,"content":null,"categories":[{"name":"UML","slug":"UML","permalink":"https://luoweiguang.github.io/categories/UML/"}],"tags":[{"name":"UML","slug":"UML","permalink":"https://luoweiguang.github.io/tags/UML/"}]},{"title":"设计模式概述|面向对象设计原则","slug":"设计模式概述面向对象设计原则","date":"2016-03-18T13:00:00.000Z","updated":"2017-08-06T10:10:32.002Z","comments":true,"path":"2016/03/18/设计模式概述面向对象设计原则/","link":"","permalink":"https://luoweiguang.github.io/2016/03/18/设计模式概述面向对象设计原则/","excerpt":"设计模式的4个主要优点\n它们提炼出专家的经验和智慧，为普通开发人员所用。\n它们的名字组成了一个词汇表，有助于开发人员更好地交流。\n系统的文档若记载了该系统所使用的模式，则有助于人们更快地理解系统。\n它们使得对系统进行改造变得更加容易，无论系统原来的设计是否采用了模式。","text":"设计模式的4个主要优点 它们提炼出专家的经验和智慧，为普通开发人员所用。 它们的名字组成了一个词汇表，有助于开发人员更好地交流。 系统的文档若记载了该系统所使用的模式，则有助于人们更快地理解系统。 它们使得对系统进行改造变得更加容易，无论系统原来的设计是否采用了模式。 设计模式用于在特定的条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案 设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。 设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。模式名称(Pattern Name)通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名，微笑）；问题(Problem)描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；解决方案(Solution)描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；效果(Consequences)描述了模式的优缺点以及在使用模式时应权衡的问题。 根据它们的用途，设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种。创建型模式主要用于描述如何创建对象结构型模式主要用于描述如何实现类或对象的组合行为型模式主要用于描述类或对象怎样交互以及怎样分配职责 设计模式遵循的七个原则: 单一职责原则（Single Responsibility Principle） 里氏替换原则（Liskov Substitution Principle） 依赖倒置原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（Law Of Demeter） 开闭原则（Open Close Principle） 合成/聚合复用原则（Composite/Aggregate Reuse Principle） 单一职责原则 定义:不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。或者说就一个类而言，应该只有一个引起它变化的原因。 问题由来:类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。解决方案:遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 个人理解：程序设计其实是对复杂性的管理，当复杂性过高，项目将难以开发与维护，据说C语言的项目当代码超过50K后，项目的复杂度就急剧上升，而采取面向对象语言编程，通过对现实世界理解和抽象的方法，极大的帮助我们理解项目，使我们能够顺利的开发大型项目，而Java的出现，又帮助我们减少了开发健壮代码所需的时间以及困难。 面向对象的基本原则是：多聚合，少继承。低耦合，高内聚. 内聚：内聚是从功能角度来度量模块内的联系，它描述的是模块内的功能联系 耦合：耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 一个模块的耦合性越强。那么模块的独立性越差，则越难以修改，对一个地方的修改，必然导致其他的地方需要修改。而内聚性越高，则说明模块各个元素的联系越紧密。低内聚的模块说明模块的职责不明确，比较松散，说明对其他模块的依赖程度高。不容易对模块进行修改。而高内聚，低耦合的系统具有更好的重用性，维护性，扩展性。 单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起变化的原因就越多，这将是导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因 按照职责来控制软件的可维护性和复杂性 单一职责原则的好处： 降低类的复杂性，实现什么样的职责都有清晰的定义提高可读性提高可维护性降低变更引起的风险，对系统扩展性和维护性很有帮助 注意:职责扩散:职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。 里氏替换原则 定义:定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。定义2：子类型必须能够替换掉它们的父类型。 问题由来:有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。解决方案:当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 个人理解:继承是面向对象的三大特性之一，但继承破坏了类的封装性，并且耦合性太大，如果只是通过继承父类的方法与变量来达到减少代码的书写，明显继承是得不偿失的。并且继承使得子类可以重写父类的方法，但这可能造成乱用使子类方法偏离父类方法的意图，使得代码内聚性降低，且不利于代码的扩展与复用。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。(对扩展开放，对修改关闭) 它包含以下4层含义：1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。2.子类中可以增加自己特有的方法。3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 依赖倒置原则定义:高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 个人理解:在传统的软件开发中，常常会把项目进行分层，通过一层层不断的叠加来实现最终的效果，而高层次依赖与低层次的接口。有句话大概是这么说的，计算机世界没有什么不能模拟的，如果没有的话，那就再加一层。这种方式能够帮助我们理清各个功能模块。而且越是大型的系统，层次划分越明确，但是这也造成一个缺点，如果低层次进行了修改，甚至是删除某些Api,那么就会造成高层次的不兼容问题，那么假如我们在高层次与低层次之间定义好统一接口，只要低层次的修改遵守了定义好的接口，那么就会极大的减少高层不兼容问题的发生。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成依赖倒置原则的核心思想是面向接口编程. 依赖倒置有三种方式来实现 通过构造函数传递依赖对象；比如在构造函数中的需要传递的参数是抽象类或接口的方式实现。 通过setter方法传递依赖对象；即在我们设置的setXXX方法中的参数为抽象类或接口，来实现传递依赖对象。 接口声明实现依赖对象，也叫接口注入；即在函数声明中参数为抽象类或接口，来实现传递依赖对象，从而达到直接使用依赖对象的目的。 在实际编程中，我们一般需要做到如下3点：低层模块尽量都要有抽象类或接口，或者两者都有。变量的声明类型尽量是抽象类或接口。使用继承时遵循里氏替换原则。 接口隔离原则 定义:客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。问题由来:类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。解决方案:将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 个人理解:在Java开发中，有种说法是面向接口编程，因为所谓的面向接口就是定义了一个开发规范，是我们对软件系统某一方面的抽象，使我们更容易对软件系统进行修改，维护与更新。而面向接口编程就是通过面向对象语言提供的多态性与接口或抽象类相结合的方式提供支持的。通过接口我们能够知道实现此接口的类有那些功能。假如我们将所有的规范都放入到一个接口中，那么就会造成这个接口的臃肿，使我们不清楚实现此接口的类所具有的功能与特性，并且造成大量的空方法实现。使得我们原本希望通过接口规范进行约束与抽象实现类的功能的作用大大削弱，使得项目的维护难度大大提升，也不利于团队的开发。所以每个接口都应该划分清自己的职责，避免类实现的混乱与对不需要的接口的依赖。 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 迪米特法则 定义:一个对象应该对其他对象保持最少的了解。问题由来:类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。解决方案:尽量降低类与类之间的耦合。 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 开闭原则 定义:一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。问题由来:在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。解决方案:当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 个人理解:当我们写项目时，因为需求的不确定性与业务的发展等原因，要经常会对原有的项目进行不断的修改与添加新的功能，软件工程的出现很大一部分原因就是为了解决这种不确定性。当我们项目的模块之间如果依赖程度较高，或者说耦合性比较大时，那么对与原有项目代码的进行修改，那就会出现噩梦般的情况，一个方法的修改可能会出现一连串的连锁反应。即一个方法的改变就会造成多个类的多个方法发生错误，这时候要排除问题也比较麻烦。所以好的项目就应该少修改原有项目的代码，尤其是一些与业务直接相关的模块，那么不对原有项目进行修改，怎么实现新的需求呢，其实我们可以借助于抽象性对项目进行扩充与替换，而不需要修改原有代码，假如我们在开发时就定义好了接口，那么在后续开发中，我们只要遵循原先定义好的类，就可以将原有的项目模块进行替换与添加，软件开发要写文档的原因很重要的是为了写好规范，让后来者能通过文档快速的了解原有的项目，但跟文档比起来，先设计出有良好的接口更能让开发者快速的对原项目进行修改，而不是陷入到无休止的修改BUG上。很明显要实现开闭原则，其实就是要尽量实现其他的原则。 开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。 在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。 开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。 说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。 合成/聚合复用原则 定义:尽量使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 继承复用优点: 新的实现较为容易，因为基类的大部分功能可以通过继承关系自动进入派生类 修改或扩展继承而来的实现较为容易缺点: 继承复用破坏包装，因为继承将基类的实现细节暴露给派生类，这种复用也称为白箱复用 如果基类的实现发生改变，那么派生类的实现也不得不发生改变 从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活 合成/聚合复用优点: 新对象存取成分对象的唯一方法是通过成分对象的接口； 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的； 这种复用支持包装； 这种复用所需的依赖较少； 每一个新的类可以将焦点集中在一个任务上； 这种复用可以在运行时动态进行，新对象可以使用合成/聚合关系将新的责任委派到合适的对象。缺点: 通过这种方式复用建造的系统会有较多的对象需要管理。 耦合内聚分类 耦合性分类(低――高): 无直接耦合;数据耦合;标记耦合;控制耦合;公共耦合;内容耦合;1 无直接耦合:2 数据耦合: 指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言的值传递;3 标记耦合: 指两个模块之间传递的是数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址;4 控制耦合: 指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能;5 公共耦合: 指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。6 内容耦合: 这是最高程度的耦合，也是最差的耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。 内聚性分类(低――高): 偶然内聚;逻辑内聚;时间内聚;通信内聚;顺序内聚;功能内聚;1 偶然内聚: 指一个模块内的各处理元素之间没有任何联系。2 逻辑内聚: 指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。3 时间内聚: 把需要同时执行的动作组合在一起形成的模块为时间内聚模块。4 通信内聚: 指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。5 顺序内聚: 指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。6 功能内聚: 这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。与其他模块的耦合是最弱的。 参考资料什么是高内聚、低耦合设计模式专栏设计模式6大原则之-单一职责原则设计模式《java与模式》笔记(六) 合成/聚合复用原则","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://luoweiguang.github.io/categories/设计模式/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://luoweiguang.github.io/tags/总结/"},{"name":"设计模式","slug":"设计模式","permalink":"https://luoweiguang.github.io/tags/设计模式/"},{"name":"面向对象","slug":"面向对象","permalink":"https://luoweiguang.github.io/tags/面向对象/"}]},{"title":"JDBC连接SQLServer的配置问题","slug":"JDBC连接SQLServer的配置问题","date":"2016-03-15T01:00:00.000Z","updated":"2017-08-06T10:14:16.430Z","comments":true,"path":"2016/03/15/JDBC连接SQLServer的配置问题/","link":"","permalink":"https://luoweiguang.github.io/2016/03/15/JDBC连接SQLServer的配置问题/","excerpt":"背景：Microsoft SQL Server 2008 R2\n建立SQl Server身份验证账户","text":"背景：Microsoft SQL Server 2008 R2 建立SQl Server身份验证账户 先通过Window 身份验证登录数据库 点击安全性 -&gt; 登录名 ，右键新建登录名 在弹出框中，填写登录名：（即账号名） 点选SQL Server身份验证 填写密码与确认密码 点击选择页的状态 是否允许连接到数据库引擎，选择授予 登录选择启用 点击选择页的用户映射 选择映射的数据库（打钩）并点击 在下方的数据库角色成员身份选择db_datareader（可读）与db_datawriter(可写)（更多选择，请见下方列表） 点击确定 服务器右键属性 在选择页中选择安全性 在服务器身份验证中选择SQL Server 和Window 身份验证模式 点击确定 重启SQl Server服务 重启SQl Server服务 开始菜单 -&gt; 所有程序 -&gt; Microsoft SQL Server 2008 R2 -&gt; 配置工具 -&gt;SQL Server配置管理器 选择SQL Server服务 -&gt; SQl Server(SQLEXPRESS) 点击右键 -&gt; 重新启动 设置连接端口（解决”通过端口 1433 连接到主机 127.0.0.1 的 TCP/IP 连接失败””的问题） 开始菜单 -&gt; 所有程序 -&gt; Microsoft SQL Server 2008 R2 -&gt; 配置工具 -&gt;SQL Server配置管理器 选择SQL Server网络配置 -&gt; SQLEXPRESS的协议 点击TCP/IP，右键属性 点击IP地址，输入TCP端口号，并把TCP动态端口的数据删除 点击确定 再右键,点击启动 重启SQl Server服务导入JDBC的jar包 ※下载JDBC的jar包,需要把jar包复制到lib目录下，如果只是通过Build Path方式导入JDBC的jar包，运行时会报ClassNotFoundException异常 SQL Server中角色与权限管理 服务器角色:按照从最低级别角色(bulkadmin)到最高级别角色(sysadmin)的顺序进行描述: bulkadmin:这个角色可以运行BULK INSERT语句.该语句允许从文本文件中将数据导入到SQL Server2008数据库中,为需要执行大容量插入到数据库的域帐号而设计. dbcreator:这个角色可以创建,更改,删除和还原任何数据库.不仅适合助理DBA角色,也可能适合开发人员角色. diskadmin:这个角色用于管理磁盘文件,比如镜像数据库和添加备份设备适合助理DBA processadmin:SQL Server 2008可以同时多进程处理.这个角色可以结束进程(在SQL Server 2008中称为”删除”) public:有两大特点:第一,初始状态时没有权限;第二,所有数据库用户都是它的成员 securityadmin:这个角色将管理登录名及其属性.可以授权,拒绝和撤销服务器级/数据库级权限.可以重置登录名和密码 serveradmin:这个角色可以更改服务器范围的配置选项和关闭服务器 setupadmin:为需要管理联接服务器和控制启动的存储过程的用户而设计 sysadmin:这个角色有权在SQL Server 2008 中执行任何操作. 数据库角色成员身份: db_accessadmin:可以在数据库中添加和删除数据库用户, 组及角色 db_backupoperator:可以备份数据库 db_datareader 可以读取任何表中的数据 db_datawriter 可以添加、更改或删除所有表中的数据 db_ddladmin 可以添加、更改或删除数据库对象(即可以执行任何DDL语句) db_denydatareader 不能读取任何表中的数据,但仍然可以通过存储过程来查看 db_denydatawriter 不能更改任何表中的数据,但仍然可以通过存储过程来修改 db_owner 执行任何操作 db_securityadmin 可以更改数据中的权限和角色 public:每个数据库用户都属于public角色.未对用户授权之前,该用户将被授予public角色的权限.该角色不能被删除 参考资料SQL Server中角色与权限管理","raw":null,"content":null,"categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://luoweiguang.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://luoweiguang.github.io/tags/JavaWeb/"},{"name":"配置","slug":"配置","permalink":"https://luoweiguang.github.io/tags/配置/"},{"name":"坑","slug":"坑","permalink":"https://luoweiguang.github.io/tags/坑/"}]},{"title":"反射|Class|Field|Method|Constructor类","slug":"反射ClassFieldMethodConstructor类","date":"2016-03-14T12:00:00.000Z","updated":"2017-08-06T09:14:52.728Z","comments":true,"path":"2016/03/14/反射ClassFieldMethodConstructor类/","link":"","permalink":"https://luoweiguang.github.io/2016/03/14/反射ClassFieldMethodConstructor类/","excerpt":"反射的概念是指程序可以访问、检测和修改它本身状态或行为的一种能力，通俗来说就是获得自身的信息并能够进行修改。\n要弄懂反射就要弄懂Java的类加载器机制。在Java中每个，class文件都有一个对应的Class对象，类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。通过Class对象我们就可以知道这个Clas文件的所有信息，如字段，方法，构造方法，父类，注释等。","text":"反射的概念是指程序可以访问、检测和修改它本身状态或行为的一种能力，通俗来说就是获得自身的信息并能够进行修改。 要弄懂反射就要弄懂Java的类加载器机制。在Java中每个，class文件都有一个对应的Class对象，类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。通过Class对象我们就可以知道这个Clas文件的所有信息，如字段，方法，构造方法，父类，注释等。 Class:Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。 Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。 基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。 获取Class对象的方式 运用static method Class.forName(),参数name为Class对应的类的全名(包括包名);Class&lt;?> Test1 = Class.forName(\"com.lwg.Cat\"); 调用类的class属性得到类对应的Class对象Class&lt;?> Test2 = Cat.class; 调用类的实例化对象的getClass()方法Cat mCat = new Cat(); Class&lt;?> Test3 = mCat.getClass(); 运用primitive wrapper classes的TYPE 语法（这里返回的是原生类型，和Boolean.class返回的不同）Class&lt;?&gt; Test4 = Integer.TYPE; 得到对应类的Class对象对应后，我们就可以通过该Class对象得到它所对应的类的一些信息，比如该类的构造函数、成员(属性)、方法(函数)； Class类API(部分): 返回类型 方法 static Class&lt; ? &gt; forName(String className) 返回与带有给定字符串名的类或接口相关联的 Class 对象 ClassLoader getClassLoader() 返回该类的类加载器 Constructor&lt; T &gt; getConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，它反映此 Class对象所表示的类的指定公共构造方法 Constructor&lt; T &gt; getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法 Constructor&lt; ? &gt;[] getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class对象表示的类声明的所有构造方法 Constructor&lt; ? &gt;[] getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class对象所表示的类的所有公共构造方法 Class&lt; ? &gt; getDeclaringClass() 如果此 Class 对象所表示的类或接口是另一个类的成员，则返回的 Class 对象表示该对象的声明类。 Class&lt; ? &gt;[] getDeclaredClasses() 返回类中定义的所有公共、私有、保护的内部类 Class&lt; ? &gt;[] getClasses() 返回类定义的所有公共的内部类,以及从父类、父接口那里继承来的内部类 Field getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class对象所表示的类或接口的指定已声明字段 Field getField(String name) 返回一个 Field 对象，它反映此 Class对象所表示的类或接口的指定公共成员字段 Field[] getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class对象所表示的类或接口所声明的所有字段 Field[] getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段 Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class对象所表示的类或接口的指定已声明方法 Method getMethod(String name,Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反回此 Class对象所表示的类或接口的指定公共成员方法 Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法 Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法 boolean isInterface() 判定指定的 Class 对象是否表示一个接口类型 T newInstance() 创建此Class对象所表示的类的一个新实例（必须带有默认的构造器） Class&lt; ? super T &gt; getSuperclass() 返回超类 Package getPackage() 获取此类的包 Field:Field类型的对象就是描述Class对象对应类的出现包括public、protected、private属性)；一个Field对象对应描述一个类的字段；Field类中定义了一些方法，可以用来查询字段的类型以及设置或读取字段的值。将这些方法与继承而来的member方法结合在一起.就可以使我们能够找出有关字段声明的全部信息，并且能够操纵某个特定对象或类的字段。Field类API(部分): 返回类型 方法 void setAccessible(boolean flag) 参数为true，只要是在类中声明的目标属性均可访问，为false，只有public目标属性可访问 void set(Object object, Object value) 给目标属性设置值(private、protected属性均不能访问，但可以通过先调用setAccessible(true)实现访问)，第一个参数为目标属性所在类的对象，第二个参数为传入的值 Object get(Object object) 得到目标属性的值(private、protected属性均不能访问，但可以通过调用setAccessible(true)实现访问)，参数为目标属性所在类的对象 void setBoolean(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为boolean boolean getBoolean(Object object) 同get(Object object)，只不过得到的数据类型为boolean void setByte(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为byte byte getByte(Object object) 同get(Object object)，只不过得到的数据类型为byte void setShort(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为short short getShort(Object object) 同get(Object object)，只不过得到的数据类型为short void setInt(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为int int getInt(Object object) 同get(Object object)，只不过得到的数据类型为int void setLong(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为long long getLong(Object object) 同get(Object object)，只不过得到的数据类型为long void setFloat(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为float float getFloat(Object object) 同get(Object object)，只不过得到的数据类型为float void setDouble(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为double double getDouble(Object object) 同get(Object object)，只不过得到的数据类型为double void setChar(Object object, boolean value) 同set(Object object, Object value)，只不过操作的数据类型为char char getChar(Object object) 同get(Object object)，只不过得到的数据类型为char String getName() 得到目标属性的名字，不局限于private修饰符，只要是类中声明的属性 Type getGenericType() 得到目标属性的类型，不局限于private修饰符 Class&lt; ? &gt; getType() 得到目标属性的类型对应的Class对象 int getModifiers() 得到目标属性的修饰符值(private为2、protected为4、public为1、static为8、final为16,结果为相加，例如public static final为25) Class&lt; ? &gt; getDeclaringClass() 得到目标属性所在类对应的Class对象 Method: 同Fiel一样，一个Method对象对应描述一个类的方法；Method类API(部分): 返回类型 方法 void setAccessible(boolean flag) 参数为true，只要是在类中声明的目标方法均可访问，为false，只有public目标属性可访问 Object invoke(Object receiver, Object… args) 动态执行调用目标方法，第一个参数为Class对象或者类的实例，第二个参数为可变实参的对象(多个实参) Class&lt; ? &gt; getDeclaringClass() 得到目标方法所在类对应的Class对象 Class&lt; ? &gt; getExceptionTypes() 得到目标方法抛出的异常类型对应的Class对象 Type[] getGenericExceptionTypes() 得到目标方法抛出的异常类型对应的Type对象 Class&lt; ? &gt; getReturnType() 得到目标方法返回类型对应的Class对象 Type getGenericReturnType() 得到目标方法返回类型对应的Type对象 Class&lt; ? &gt;[] getParameterTypes() 得到目标方法各参数类型对应的Class对象 Type[] getGenericParameterTypes() 得到目标方法各参数类型对应的Type对象 int getModifiers() 得到目标方法修饰符的值 String getName() 得到目标方法的名字 Constructor:Constructor对象对应于类的构造方法。Constructor类API(部分): 返回类型 方法 String getName() 以字符串形式返回此构造方法的名称 int getModifiers() 以整数形式返回此 Constructor 对象所表示构造方法的 Java 语言修饰符 Class&lt; ? &gt;[] getParameterTypes() 按照声明顺序返回一组 Class 对象，这些对象表示此 Constructor 对象所表示构造方法的形参类型 T newInstance(Object… initargs) 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例 void setAccessible(boolean flag) 参数为true，只要是在类中声明的构造方法均可访问，为false，只有public目标属性可访问 代码: package com.lwg; public class Animal { public String name; public Animal(String name) { this.name = name; } public void a() { } } package com.lwg; public class Cat extends Animal { public static final int NUMBER = 1; public String Color = \"白色\"; private static String Sex =\"公\"; private int size; public Cat() { this(\"Cat\"); } public Cat(String name) { super(name); // TODO Auto-generated constructor stub } private Cat(String name,String Color) { super(name); this.Color = Color; } public void Shout() { System.out.println(\"瞄\"); } public static void Cry() { System.out.println(\"瞄...瞄\"); } public static void Smile(int fish) { for(int i = 0;i &lt; fish;i++) { System.out.print(\"瞄\"); } System.out.println(\"\"); } public int getSize() { return size; } private void setSize(int size) { this.size = size; } } package com.lwg; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Type; import jdk.nashorn.internal.runtime.linker.InvokeByName; import com.sun.org.apache.bcel.internal.generic.NEW; public class Test { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, NoSuchFieldException, IllegalArgumentException, InvocationTargetException { //运用static method Class.forName(),参数name为Class对应的类的全名(包括包名); Class&lt;?> Test1 = Class.forName(\"com.lwg.Cat\"); //运用static method Class.forName(),参数name为Class对应的类的全名(包括包名); Class&lt;?> Test2 = Cat.class; //调用类的实例化对象的getClass()方法 Cat mCat = new Cat(); Class&lt;?> Test3 = mCat.getClass(); //运用primitive wrapper classes的TYPE Class&lt;?> Test4 = Integer.TYPE; //通过ClassLoader获得Class对象 ClassLoader mClassLoader = Test1.getClassLoader(); Class&lt;?> Test5 = mClassLoader.loadClass(\"com.lwg.Animal\"); //获得父类的Class对象 Class&lt;?> Test6 = Test1.getSuperclass(); Class&lt;?> Test7 = mClassLoader.loadClass(\"com.lwg.Cat\"); //通过newInstance()创建对象 Cat mCat1 = (Cat) Test1.newInstance(); mCat1.Shout(); System.out.println(\"-----------Constructor----------\"); //获得指定公共构造方法 Constructor&lt;Cat> constructor1 = (Constructor&lt;Cat>) Test2.getConstructor(new Class[]{String.class}); //返回Java语音修饰符 System.out.println(\"返回Java语音修饰符:\"+constructor1.getModifiers()); //获得类名 System.out.println(\"获得类名:\"+constructor1.getName()); //获得所有公共构造方法 Constructor&lt;Cat>[] constructor2 = (Constructor&lt;Cat>[]) Test2.getConstructors(); System.out.println(\"公共的构造方法数为：\"+constructor2.length); for(Constructor&lt;Cat> constructor3 : constructor2) { //获得所有参数的类 Class&lt;?>[] constructorclasses1 = (Class&lt;?>[]) constructor3.getParameterTypes(); for(Class&lt;?> constructorclass1 : constructorclasses1) { System.out.print(constructorclass1.getName()); } System.out.println(); } //获得指定构造方法 Constructor&lt;Cat> constructor4 = (Constructor&lt;Cat>) Test2.getDeclaredConstructor(new Class[]{String.class,String.class}); //返回Java语音修饰符 System.out.println(\"返回Java语音修饰符:\"+constructor4.getModifiers()); //获得所有构造方法 Constructor&lt;Cat>[] constructor5 = (Constructor&lt;Cat>[]) Test2.getDeclaredConstructors(); System.out.println(\"公共的构造方法数为：\"+constructor5.length); for(Constructor&lt;Cat> constructor6 : constructor5) { Class&lt;?>[] constructorclasses2 = (Class&lt;?>[]) constructor6.getParameterTypes(); for(Class&lt;?> constructorclass2 : constructorclasses2) { System.out.print(constructorclass2.getName()+\"、\"); } System.out.println(); } //为ture表示类中声明的构造方法均可访问 constructor4.setAccessible(true); //构造有参数的类 System.out.print(\"构造有参数的类:\"); Cat mCat2 = constructor4.newInstance(\"小黑\",\"黑色\"); System.out.println(mCat2.name+\"是\"+mCat2.Color); System.out.println(\"-----------Field----------\"); //获得指定的公共字段 Field field1 = Test3.getField(\"NUMBER\"); //得到目标属性的修饰符值 System.out.println(\"得到目标属性的修饰符值:\"+field1.getModifiers()); //得到目标属性的类型 Type type= field1.getGenericType(); System.out.println(\"得到目标属性的类型:\"+type.toString()); //得到目标属性的类型对应的Class对象 Class&lt;?> fieldClass1 = field1.getType(); System.out.println(fieldClass1.getName()); //获得属性值 System.out.println(\"获得属性值:\"+field1.getInt(null)); //获得所有的字段 Field[] field2 = Test3.getFields(); //获得指定的字段 Field field3 = Test3.getDeclaredField(\"Sex\"); //设置为均可访问，即使只是访问私有字段而不是修改，也要设置为true field3.setAccessible(true); //获得静态字段 System.out.println(\"获得静态字段:\"+field3.get(null)); //设置属性值 field3.set(null, \"母\"); System.out.println(\"修改为:\"+field3.get(null)); //获得所有的字段 Field[] field4 = Test3.getDeclaredFields(); Field field5 = Test3.getDeclaredField(\"Color\"); System.out.println(\"获得非静态字段：\"+field5.get(new Cat())); System.out.println(\"-----------Method----------\"); //获得指定公共方法 Method method1 = Test7.getMethod(\"Cry\", new Class[]{}); //执行静态无参无返回值方法 method1.invoke(null, null); //得到返回类型的类 Class&lt;?> methodClass1 = method1.getReturnType(); System.out.println(\"得到返回类型的类\"+methodClass1.getName()); //获得指定带参数的公共方法 Method method2 = Test7.getMethod(\"Smile\", new Class[]{int.class}); //执行非静态有参无返回值方法 method2.invoke(Test7.newInstance(),10); //得到目标方法各参数类型对应的Class对象 Class&lt;?>[] methodClass2 = method2.getParameterTypes(); for(int i = 0; i &lt; methodClass2.length;i++) { System.out.println(methodClass2[i].getName()); } //获得所有公共方法，包括继承父类的方法 Method[] method3 = Test7.getMethods(); System.out.println(\"公共方法总数：\"+method3.length); for(int i = 0;i &lt; method3.length;i++) { System.out.println(method3[i].getName()); } //获得指定方法 Method method4 = Test7.getDeclaredMethod(\"setSize\", new Class[]{int.class}); Cat mCat3 = (Cat) Test7.newInstance(); //执行私有非静态方法 method4.setAccessible(true); method4.invoke(mCat3, 20); System.out.println(\"执行私有非静态方法:\"+mCat3.getSize()); //获得所有方法,包括重写的方法但不包括父类的其他方法 Method[] method5 = Test7.getDeclaredMethods(); System.out.println(\"方法总数：\"+method5.length); for(int i = 0;i &lt; method5.length;i++) { System.out.println(method5[i].getName()); } } } 结果: 瞄 -----------Constructor---------- 返回Java语音修饰符:1 获得类名:com.lwg.Cat 公共的构造方法数为：2 java.lang.String 返回Java语音修饰符:2 公共的构造方法数为：3 java.lang.String、 java.lang.String、java.lang.String、 构造有参数的类:小黑是黑色 -----------Field---------- 得到目标属性的修饰符值:25 得到目标属性的类型:int int 获得属性值:1 获得静态字段:公 修改为:母 获得非静态字段：白色 -----------Method---------- 瞄...瞄 得到返回类型的类void 瞄瞄瞄瞄瞄瞄瞄瞄瞄瞄 int 公共方法总数：14 getSize Shout Cry Smile a wait wait wait equals toString hashCode getClass notify notifyAll 执行私有非静态方法:20 方法总数：5 getSize setSize Shout Cry Smile 参考资料Java反射机制知识点深入研究java.lang.Class类解析Java中的Field类和Method类","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"},{"name":"API","slug":"API","permalink":"https://luoweiguang.github.io/tags/API/"}]},{"title":"异常丢失","slug":"异常丢失","date":"2016-03-11T13:00:00.000Z","updated":"2017-08-06T10:16:25.868Z","comments":true,"path":"2016/03/11/异常丢失/","link":"","permalink":"https://luoweiguang.github.io/2016/03/11/异常丢失/","excerpt":"异常丢失指的是在finally的代码块里有return或throw语句时，此语句会覆盖前面的return语句或throw语句，但在eclipse中，在finally的代码块加入return或throw语句时，会报“finally block does not complete normally”警告，所以稍微知道一下就好了。","text":"异常丢失指的是在finally的代码块里有return或throw语句时，此语句会覆盖前面的return语句或throw语句，但在eclipse中，在finally的代码块加入return或throw语句时，会报“finally block does not complete normally”警告，所以稍微知道一下就好了。 代码: public class TestException { void Test1() { try { if(Test1Test()) { throw new Exception(); } } catch (Exception e) { System.out.println(\"Test1,catch\"); } finally { System.out.println(\"Test1,finally\"); } } boolean Test1Test() { try { throw new Exception(); } catch (Exception e) { System.out.println(\"Test1Test,catch\"); return true; } finally { System.out.println(\"Test1Test,finally\"); } } void Test2() { try { if(Test2Test()) { throw new Exception(); } } catch (Exception e) { System.out.println(\"Test2,catch\"); } finally { System.out.println(\"Test2,finally\"); } } boolean Test2Test() { try { throw new Exception(); } catch (Exception e) { System.out.println(\"Test2Test,catch\"); } finally { System.out.println(\"Test2Test,finally\"); return false; } } void Test3() { try { if(Test3Test()) { throw new Exception(); } } catch (Exception e) { System.out.println(\"Test3,catch\"); } finally { System.out.println(\"Test3,finally\"); } } boolean Test3Test() throws Exception { try { throw new Exception(); } catch (Exception e) { System.out.println(\"Test3Test,catch\"); return true; } finally { System.out.println(\"Test3Test,finally\"); return false; } } void Test4() { try { if(Test4Test()) { throw new Exception(); } } catch (Exception e) { System.out.println(\"Test4,catch\"); } finally { System.out.println(\"Test4,finally\"); } } boolean Test4Test() throws Exception { try { throw new Exception(); } catch (Exception e) { System.out.println(\"Test4Test,catch\"); throw new Exception(\"aaaTest4Test,catch\"); } finally { System.out.println(\"Test1Test,finally\"); return false; } } void Test5() { try { if(Test5Test()) { throw new Exception(); } } catch (Exception e) { System.out.println(\"Test5,catch\"); System.out.println(e.toString()); } finally { System.out.println(\"Test5,finally\"); } } boolean Test5Test() throws Exception { try { throw new Exception(); } catch (Exception e) { System.out.println(\"Test5Test,catch\"); return false; } finally { System.out.println(\"Test5Test,finally\"); throw new Exception(\"bbbTest5Test,catch\"); } } void Test6() { try { if(Test6Test()) { throw new Exception(); } } catch (Exception e) { System.out.println(\"Test6,catch\"); System.out.println(e.toString()); } finally { System.out.println(\"Test6,finally\"); } } boolean Test6Test() throws Exception { try { throw new Exception(); } catch (Exception e) { System.out.println(\"Test6Test,catch\"); throw new Exception(\"aaaTest6Test,catch\"); } finally { System.out.println(\"Test1Test,finally\"); throw new Exception(\"bbbTest1Test,catch\"); } } public static void main(String[] args) { System.out.println(\"--------------------------------------------------\"); new TestException().Test1(); System.out.println(\"--------------------------------------------------\"); new TestException().Test2(); System.out.println(\"--------------------------------------------------\"); new TestException().Test3(); System.out.println(\"--------------------------------------------------\"); new TestException().Test4(); System.out.println(\"--------------------------------------------------\"); new TestException().Test5(); System.out.println(\"--------------------------------------------------\"); new TestException().Test6(); } } 运行结果 -------------------------------------------------- Test1Test,catch Test1Test,finally Test1,catch Test1,finally -------------------------------------------------- Test2Test,catch Test2Test,finally Test2,finally -------------------------------------------------- Test3Test,catch Test3Test,finally Test3,finally -------------------------------------------------- Test4Test,catch Test1Test,finally Test4,finally -------------------------------------------------- Test5Test,catch Test5Test,finally Test5,catch java.lang.Exception: bbbTest5Test,catch Test5,finally -------------------------------------------------- Test6Test,catch Test1Test,finally Test6,catch java.lang.Exception: bbbTest1Test,catch Test6,finally","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://luoweiguang.github.io/tags/Java基础/"}]},{"title":"Java注释","slug":"Java注释","date":"2016-03-05T07:00:00.000Z","updated":"2017-08-06T09:22:39.568Z","comments":true,"path":"2016/03/05/Java注释/","link":"","permalink":"https://luoweiguang.github.io/2016/03/05/Java注释/","excerpt":"java注释//注释一行/*.....*/注释若干行/**.....*/注释若干行，并写入javadoc文档\njavadoc标记javadoc中可以插入html标签","text":"java注释//注释一行/*.....*/注释若干行/**.....*/注释若干行，并写入javadoc文档 javadoc标记javadoc中可以插入html标签 通用注释 关键字 意义 @author 作者名 @version 版本标识 @since 最早出现的JDK版本 @deprecated 引用不推荐使用的警告 @see 引用其他类 注释内使用 关键字 意义 @link 链接到类 @linkplain 链接到类 @code 代码 方法注释 关键字 意义 @return 返回值 @throws 异常类及抛出条件 @param 参数名及其意义 导出javadoceclipse，在项目列表中按右键，选择Export(导出) -&gt; java -&gt; javadoc点击Next&gt;(下一步)，在javadoc command中选择javadoc.exe程序的路径（jdk目录下的bin\\javadoc.exe）;再Use standard doclet中选择javadoc的生成路径。点击Finish(完成)。 例子package com.lwg; /** * * @author Luoweigaung * @version 1.0.1 * @since JDK1.7 */ public class Vehicles { /** * 速度 */ public float speed; /** * * @return speed {@link #speed} * @see #setSpeed() */ public float getSpeed() { return speed; } /** * * @param speed {@linkplain #speed 速度} * @see #getSpeed() */ public void setSpeed(float speed) { this.speed = speed; } } package com.lwg.bean; import java.io.IOException; import com.lwg.Vehicles; /** * &lt;p>Car简介&lt;/p> * {@code Car}继承至{@link Vehicles},请参考{@linkplain Bicycle 自行车}与{@linkplain Bus 巴士}等 * * * @author Luoweiguang * @version 1.0.1 * @see Vehicles * @since JDK1.7 * */ public class Car extends Vehicles { /** * 花费 */ public int money; /** * 该方法用于获取价格 * @throws IOException &lt;p>如果money为0,则报异常&lt;/p> * @return {@link #money} * @see #setMoney(int) * @throws */ public int getMoney() throws IOException { if(money == 0) { throw new IOException(); } return money; } /** * 该方法用于修改价格 * @deprecated &lt;p>使用此方法可能使数据异常&lt;/p> * @param {@link #money} * @see #getMoney() * @see &lt;a href=\"www.baidu.com\">百度&lt;/a> */ public void setMoney(int money) { this.money = money; } //入口方法 public static void main(String[] args) { System.out.println(\"Hello World\"); } }","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luoweiguang.github.io/tags/Java/"},{"name":"规范","slug":"规范","permalink":"https://luoweiguang.github.io/tags/规范/"}]},{"title":"个人收藏","slug":"个人收藏","date":"2016-02-17T14:50:00.000Z","updated":"2017-07-31T14:02:01.768Z","comments":true,"path":"2016/02/17/个人收藏/","link":"","permalink":"https://luoweiguang.github.io/2016/02/17/个人收藏/","excerpt":"\n.center {\n        text-align: center;\n        }\n\n\n网站 | 主要    github  stackoverflow  Android Developers  Android Developers镜像  ","text":".center { text-align: center; } 网站 | 主要 github stackoverflow Android Developers Android Developers镜像 网站 | 技术 掘金 慕课网 伯乐在线 importnew 泡在网上的日子 安卓巴士 open-open Android Developers视频 开发技术前线 DroidSec 网站 | 工具 | 代码 android开源项目汇总 Awesome-MaterialDesign javaapk awesome-android awesome-android-libraries android-arsenal Codota searchcode 网站 | 工具 | 设计 百度识图 AndroidAssetStudio 材料设计调色板 Adobe Color CC colorhunter 摩秀创意在线配色 中国传统色彩 日本传统色彩 网站 | 资源 | 书籍 Android Design Android的官方培训课程中文版 脚本之家 百度云搜索 网站 | 资源 | API webxml 网站 | 资源 | 设计 | 图标 站酷搜素材 icons8 iconmonstr 阿里巴巴矢量图标库 icondeposit 网站 | 资源 | 图片 365psd 天堂图片网 摄图网 forwallpaper sitebuilderreport pexels pixabay finda cssauthor foter wallhaven stocksnap designerspics pickupimage freeimages 4freephotos zerospace stockvault canweimage publicdomainfiles 网站 | 设计 | 欣赏 站酷 Dribbble 网站 | 设计 | 界面 | 欣赏 学UI lovelyui apkui inspired-ui mobile-patterns capptivate uiparade 博客 | Android Android开发技术周报 干货集中营 李元静 郭霖 代码家 方杰 任玉刚 技术小黑屋 码农明明桑 Jacksgong Mr.Simple kymjs张涛 eclipse_xu Drakeet 张明云 Gracker 邓老师 Trinea Jlog hujiaweibujidao 张兴业 鸿洋_ 恺风 Android_Tutor stormzhang 罗升阳 markzhai liguojin1230 hudashi xingfuzzhd Ruthless Devin Zhang 半棵树 Lippi-浮生志 工匠若水 moble_xie yudajun 废墟的树 全速前行 harvic880925 CankingApp AigeStudio greenrobot 安卓弟 ljphhj 杨辉 feelang 赵凯强 WaylenWang 卢俊 coder-pig Keegan小钢 博客 | Java 终点 rulinma xiaoxian8023 xdp-gacl 兰亭风雨 博客 | 其他 阮一峰 廖雪峰","raw":null,"content":null,"categories":[{"name":"Tool","slug":"Tool","permalink":"https://luoweiguang.github.io/categories/Tool/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://luoweiguang.github.io/tags/Blog/"},{"name":"Website","slug":"Website","permalink":"https://luoweiguang.github.io/tags/Website/"}]},{"title":"Hello World | Markdown使用 | hexo","slug":"hello-world","date":"2016-02-16T12:00:00.000Z","updated":"2017-07-31T13:54:08.796Z","comments":true,"path":"2016/02/16/hello-world/","link":"","permalink":"https://luoweiguang.github.io/2016/02/16/hello-world/","excerpt":"MarkDown基础语法","text":"MarkDown基础语法 标题# 一级标题 &#39;Hello World&#39; ## 二级标题 &#39;Hello World&#39; ### 三级标题 &#39;Hello World&#39; #### 四级标题 &#39;Hello World&#39; ##### 五级标题 &#39;Hello World&#39; ###### 六级标题 &#39;Hello World&#39; 二级标题 ‘Hello World’三级标题 ‘Hello World’四级标题 ‘Hello World’五级标题 ‘Hello World’六级标题 ‘Hello World’粗体**Hello World** Hello World 斜体*Hello World* Hello World 删除~~Hello World~~ Hello World 分割线--- *** 列表- Hello World - Hello World - Hello World * Hello World * Hello World * Hello World 1. Hello World 2. Hello World 3. Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World 嵌套列表- Hello World + Hello World + Hello World + Hello World - Hello World + Hello World + Hello World + Hello World + Hello World + Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World 链接[Hello World](http://www.google.com) [Hello World][1] [1]:http://www.google.com Hello WorldHello World 表格| Hello World | Hello World | Hello World | |-------------|-------------|-------------| | Hello World | Hello World | Hello World | | Hello World | Hello World | Hello World | |-------------|------------:|:--------:| | Hello World | Hello World | Hello World | Hello World | Hello World | Hello World -----|------|---- Hello World | Hello World | Hello World Hello World | Hello World | Hello World Hello World | Hello World | Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World 代码框`Hello World` Hello World 引用 &gt; Hello World &gt; Hello World &gt; Hello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello World &gt;&gt; Hello World &gt; &gt; Hello World Hello WorldHello World Hello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello World Hello World Hello World 单行长文字 Hello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello World Hello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello World 图片![头像](http://luoweiguang.github.io/img/head.jpg) 转义字符\\\\ \\` \\* \\_ \\{ \\} \\[ \\] \\( \\) \\# \\+ \\- \\. \\! \\`*_{}[]()#+-.! 高亮一段代码public class HelloWorld { // Hello World public static void main(String args[]) { System.out.println(\"Hello World\"); } } Front-mattertitle: Hello World | Markdown使用 | hexo #文章标题 date: 2016/02/16 20:00:00 #建立日期 updated: #更新日期 description: #文章描述 categories: #分类 - Tool tags: #标签 - Hexo - Markdown toc: true # 生成目录 comments: true #开启文章的评论功能 参考资料Markdown使用指南Hexo的使用介绍Front-matter | Hexo","raw":null,"content":null,"categories":[{"name":"Tool","slug":"Tool","permalink":"https://luoweiguang.github.io/categories/Tool/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luoweiguang.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://luoweiguang.github.io/tags/Markdown/"}]}]}